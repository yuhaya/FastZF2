<?php 

namespace Zend\Mvc; use Zend\EventManager\EventsCapableInterface; use Zend\Http\Request; use Zend\Http\Response; interface ApplicationInterface extends EventsCapableInterface { public function getServiceManager(); public function getRequest(); public function getResponse(); public function run(); } 
namespace Zend\EventManager; interface EventsCapableInterface { public function getEventManager(); } 
namespace Zend\EventManager; interface EventManagerAwareInterface extends EventsCapableInterface { public function setEventManager(EventManagerInterface $eventManager); } 
namespace Zend\Mvc; use Zend\EventManager\EventManagerAwareInterface; use Zend\EventManager\EventManagerInterface; use Zend\ServiceManager\ServiceManager; use Zend\Stdlib\ResponseInterface; class Application implements ApplicationInterface, EventManagerAwareInterface { const ERROR_CONTROLLER_CANNOT_DISPATCH = 'error-controller-cannot-dispatch'; const ERROR_CONTROLLER_NOT_FOUND = 'error-controller-not-found'; const ERROR_CONTROLLER_INVALID = 'error-controller-invalid'; const ERROR_EXCEPTION = 'error-exception'; const ERROR_ROUTER_NO_MATCH = 'error-router-no-match'; protected $configuration = null; protected $defaultListeners = array( 'RouteListener', 'DispatchListener', 'ViewManager', 'SendResponseListener', ); protected $event; protected $events; protected $request; protected $response; protected $serviceManager = null; public function __construct($configuration, ServiceManager $serviceManager) { $this->configuration = $configuration; $this->serviceManager = $serviceManager; $this->setEventManager($serviceManager->get('EventManager')); $this->request = $serviceManager->get('Request'); $this->response = $serviceManager->get('Response'); } public function getConfig() { return $this->serviceManager->get('Config'); } public function bootstrap(array $listeners = array()) { $serviceManager = $this->serviceManager; $events = $this->events; $listeners = array_unique(array_merge($this->defaultListeners, $listeners)); foreach ($listeners as $listener) { $events->attach($serviceManager->get($listener)); } $this->event = $event = new MvcEvent(); $event->setTarget($this); $event->setApplication($this) ->setRequest($this->getRequest()) ->setResponse($this->getResponse()) ->setRouter($serviceManager->get('Router')); $events->trigger(MvcEvent::EVENT_BOOTSTRAP, $event); return $this; } public function getServiceManager() { return $this->serviceManager; } public function getRequest() { return $this->request; } public function getResponse() { return $this->response; } public function getMvcEvent() { return $this->event; } public function setEventManager(EventManagerInterface $eventManager) { $eventManager->setIdentifiers(array( __CLASS__, get_class($this), )); $this->events = $eventManager; return $this; } public function getEventManager() { return $this->events; } public static function init($configuration = array()) { $smConfig = isset($configuration['service_manager']) ? $configuration['service_manager'] : array(); $listeners = isset($configuration['listeners']) ? $configuration['listeners'] : array(); $serviceManager = new ServiceManager(new Service\ServiceManagerConfig($smConfig)); $serviceManager->setService('ApplicationConfig', $configuration); $serviceManager->get('ModuleManager')->loadModules(); return $serviceManager->get('Application')->bootstrap($listeners); } public function run() { $events = $this->getEventManager(); $event = $this->getMvcEvent(); $shortCircuit = function ($r) use ($event) { if ($r instanceof ResponseInterface) { return true; } if ($event->getError()) { return true; } return false; }; $result = $events->trigger(MvcEvent::EVENT_ROUTE, $event, $shortCircuit); if ($result->stopped()) { $response = $result->last(); if ($response instanceof ResponseInterface) { $event->setTarget($this); $event->setResponse($response); $events->trigger(MvcEvent::EVENT_FINISH, $event); return $response; } if ($event->getError()) { return $this->completeRequest($event); } return $event->getResponse(); } if ($event->getError()) { return $this->completeRequest($event); } $result = $events->trigger(MvcEvent::EVENT_DISPATCH, $event, $shortCircuit); $response = $result->last(); if ($response instanceof ResponseInterface) { $event->setTarget($this); $event->setResponse($response); $events->trigger(MvcEvent::EVENT_FINISH, $event); return $response; } $response = $this->getResponse(); $event->setResponse($response); $this->completeRequest($event); return $this; } public function send() { } protected function completeRequest(MvcEvent $event) { $events = $this->getEventManager(); $event->setTarget($this); $events->trigger(MvcEvent::EVENT_RENDER, $event); $events->trigger(MvcEvent::EVENT_FINISH, $event); return $this; } } 
namespace Zend\ServiceManager; interface ServiceLocatorInterface { public function get($name); public function has($name); } 
namespace Zend\ServiceManager; use ReflectionClass; class ServiceManager implements ServiceLocatorInterface { const SCOPE_PARENT = 'parent'; const SCOPE_CHILD = 'child'; protected $canonicalNames = array(); protected $allowOverride = false; protected $invokableClasses = array(); protected $factories = array(); protected $abstractFactories = array(); protected $delegators = array(); protected $pendingAbstractFactoryRequests = array(); protected $lastAbstractFactoryUsed = null; protected $lastCanonicalNameUsed = null; protected $shared = array(); protected $instances = array(); protected $aliases = array(); protected $initializers = array(); protected $peeringServiceManagers = array(); protected $shareByDefault = true; protected $retrieveFromPeeringManagerFirst = false; protected $throwExceptionInCreate = true; protected $canonicalNamesReplacements = array('-' => '', '_' => '', ' ' => '', '\\' => '', '/' => ''); public function __construct(ConfigInterface $config = null) { if ($config) { $config->configureServiceManager($this); } } public function setAllowOverride($allowOverride) { $this->allowOverride = (bool) $allowOverride; return $this; } public function getAllowOverride() { return $this->allowOverride; } public function setShareByDefault($shareByDefault) { if ($this->allowOverride === false) { throw new Exception\RuntimeException(sprintf( '%s: cannot alter default shared service setting; container is marked immutable (allow_override is false)', get_class($this) . '::' . __FUNCTION__ )); } $this->shareByDefault = (bool) $shareByDefault; return $this; } public function shareByDefault() { return $this->shareByDefault; } public function setThrowExceptionInCreate($throwExceptionInCreate) { $this->throwExceptionInCreate = $throwExceptionInCreate; return $this; } public function getThrowExceptionInCreate() { return $this->throwExceptionInCreate; } public function setRetrieveFromPeeringManagerFirst($retrieveFromPeeringManagerFirst = true) { $this->retrieveFromPeeringManagerFirst = (bool) $retrieveFromPeeringManagerFirst; return $this; } public function retrieveFromPeeringManagerFirst() { return $this->retrieveFromPeeringManagerFirst; } public function setInvokableClass($name, $invokableClass, $shared = null) { $cName = $this->canonicalizeName($name); if ($this->has(array($cName, $name), false)) { if ($this->allowOverride === false) { throw new Exception\InvalidServiceNameException(sprintf( 'A service by the name or alias "%s" already exists and cannot be overridden; please use an alternate name', $name )); } $this->unregisterService($cName); } if ($shared === null) { $shared = $this->shareByDefault; } $this->invokableClasses[$cName] = $invokableClass; $this->shared[$cName] = (bool) $shared; return $this; } public function setFactory($name, $factory, $shared = null) { $cName = $this->canonicalizeName($name); if (!($factory instanceof FactoryInterface || is_string($factory) || is_callable($factory))) { throw new Exception\InvalidArgumentException( 'Provided abstract factory must be the class name of an abstract factory or an instance of an AbstractFactoryInterface.' ); } if ($this->has(array($cName, $name), false)) { if ($this->allowOverride === false) { throw new Exception\InvalidServiceNameException(sprintf( 'A service by the name or alias "%s" already exists and cannot be overridden, please use an alternate name', $name )); } $this->unregisterService($cName); } if ($shared === null) { $shared = $this->shareByDefault; } $this->factories[$cName] = $factory; $this->shared[$cName] = (bool) $shared; return $this; } public function addAbstractFactory($factory, $topOfStack = true) { if (!$factory instanceof AbstractFactoryInterface && is_string($factory)) { $factory = new $factory(); } if (!$factory instanceof AbstractFactoryInterface) { throw new Exception\InvalidArgumentException( 'Provided abstract factory must be the class name of an abstract' . ' factory or an instance of an AbstractFactoryInterface.' ); } if ($topOfStack) { array_unshift($this->abstractFactories, $factory); } else { array_push($this->abstractFactories, $factory); } return $this; } public function addDelegator($serviceName, $delegatorFactoryName) { $cName = $this->canonicalizeName($serviceName); if (!isset($this->delegators[$cName])) { $this->delegators[$cName] = array(); } $this->delegators[$cName][] = $delegatorFactoryName; return $this; } public function addInitializer($initializer, $topOfStack = true) { if (!($initializer instanceof InitializerInterface || is_callable($initializer))) { if (is_string($initializer)) { $initializer = new $initializer; } if (!($initializer instanceof InitializerInterface || is_callable($initializer))) { throw new Exception\InvalidArgumentException('$initializer should be callable.'); } } if ($topOfStack) { array_unshift($this->initializers, $initializer); } else { array_push($this->initializers, $initializer); } return $this; } public function setService($name, $service) { $cName = $this->canonicalizeName($name); if ($this->has($cName, false)) { if ($this->allowOverride === false) { throw new Exception\InvalidServiceNameException(sprintf( '%s: A service by the name "%s" or alias already exists and cannot be overridden, please use an alternate name.', get_class($this) . '::' . __FUNCTION__, $name )); } $this->unregisterService($cName); } $this->instances[$cName] = $service; return $this; } public function setShared($name, $isShared) { $cName = $this->canonicalizeName($name); if ( !isset($this->invokableClasses[$cName]) && !isset($this->factories[$cName]) && !$this->canCreateFromAbstractFactory($cName, $name) ) { throw new Exception\ServiceNotFoundException(sprintf( '%s: A service by the name "%s" was not found and could not be marked as shared', get_class($this) . '::' . __FUNCTION__, $name )); } $this->shared[$cName] = (bool) $isShared; return $this; } protected function resolveAlias($cName) { $stack = array(); while ($this->hasAlias($cName)) { if (isset($stack[$cName])) { throw new Exception\CircularReferenceException(sprintf( 'Circular alias reference: %s -> %s', implode(' -> ', $stack), $cName )); } $stack[$cName] = $cName; $cName = $this->aliases[$cName]; } return $cName; } public function get($name, $usePeeringServiceManagers = true) { if (isset($this->canonicalNames[$name])) { $cName = $this->canonicalNames[$name]; } else { $cName = $this->canonicalizeName($name); } $isAlias = false; if ($this->hasAlias($cName)) { $isAlias = true; $cName = $this->resolveAlias($cName); } $instance = null; if ($usePeeringServiceManagers && $this->retrieveFromPeeringManagerFirst) { $instance = $this->retrieveFromPeeringManager($name); if (null !== $instance) { return $instance; } } if (isset($this->instances[$cName])) { return $this->instances[$cName]; } if (!$instance) { if ( isset($this->invokableClasses[$cName]) || isset($this->factories[$cName]) || isset($this->aliases[$cName]) || $this->canCreateFromAbstractFactory($cName, $name) ) { $instance = $this->create(array($cName, $name)); } elseif ($usePeeringServiceManagers && !$this->retrieveFromPeeringManagerFirst) { $instance = $this->retrieveFromPeeringManager($name); } } if ($instance === null) { if ($isAlias) { throw new Exception\ServiceNotFoundException(sprintf( 'An alias "%s" was requested but no service could be found.', $name )); } throw new Exception\ServiceNotFoundException(sprintf( '%s was unable to fetch or create an instance for %s', get_class($this) . '::' . __FUNCTION__, $name )); } if ( ($this->shareByDefault && !isset($this->shared[$cName])) || (isset($this->shared[$cName]) && $this->shared[$cName] === true) ) { $this->instances[$cName] = $instance; } return $instance; } public function create($name) { if (is_array($name)) { list($cName, $rName) = $name; } else { $rName = $name; if (isset($this->canonicalNames[$rName])) { $cName = $this->canonicalNames[$name]; } else { $cName = $this->canonicalizeName($name); } } if (isset($this->delegators[$cName])) { return $this->createDelegatorFromFactory($cName, $rName); } return $this->doCreate($rName, $cName); } private function createDelegatorCallback($delegatorFactory, $rName, $cName, $creationCallback) { $serviceManager = $this; return function () use ($serviceManager, $delegatorFactory, $rName, $cName, $creationCallback) { return $delegatorFactory instanceof DelegatorFactoryInterface ? $delegatorFactory->createDelegatorWithName($serviceManager, $cName, $rName, $creationCallback) : $delegatorFactory($serviceManager, $cName, $rName, $creationCallback); }; } public function doCreate($rName, $cName) { $instance = null; if (isset($this->factories[$cName])) { $instance = $this->createFromFactory($cName, $rName); } if ($instance === null && isset($this->invokableClasses[$cName])) { $instance = $this->createFromInvokable($cName, $rName); } if ($instance === null && $this->canCreateFromAbstractFactory($cName, $rName)) { $instance = $this->createFromAbstractFactory($cName, $rName); } if ($instance === null && $this->throwExceptionInCreate) { throw new Exception\ServiceNotFoundException(sprintf( 'No valid instance was found for %s%s', $cName, ($rName ? '(alias: ' . $rName . ')' : '') )); } if ($instance === null) { return $instance; } foreach ($this->initializers as $initializer) { if ($initializer instanceof InitializerInterface) { $initializer->initialize($instance, $this); } else { call_user_func($initializer, $instance, $this); } } return $instance; } public function canCreate($name, $checkAbstractFactories = true) { if (is_array($name)) { list($cName, $rName) = $name; } else { $rName = $name; $cName = $this->canonicalizeName($rName); } return ( isset($this->invokableClasses[$cName]) || isset($this->factories[$cName]) || isset($this->aliases[$cName]) || isset($this->instances[$cName]) || ($checkAbstractFactories && $this->canCreateFromAbstractFactory($cName, $rName)) ); } public function has($name, $checkAbstractFactories = true, $usePeeringServiceManagers = true) { if (is_array($name)) { list($cName, $rName) = $name; } else { $rName = $name; if (isset($this->canonicalNames[$rName])) { $cName = $this->canonicalNames[$name]; } else { $cName = $this->canonicalizeName($name); } } if ( isset($this->invokableClasses[$cName]) || isset($this->factories[$cName]) || isset($this->aliases[$cName]) || isset($this->instances[$cName]) || ($checkAbstractFactories && $this->canCreateFromAbstractFactory($cName, $name)) ) { return true; } if ($usePeeringServiceManagers) { foreach ($this->peeringServiceManagers as $peeringServiceManager) { if ($peeringServiceManager->has($rName)) { return true; } } } return false; } public function canCreateFromAbstractFactory($cName, $rName) { foreach ($this->abstractFactories as $abstractFactory) { $factoryClass = get_class($abstractFactory); if ( isset($this->pendingAbstractFactoryRequests[$factoryClass]) && $this->pendingAbstractFactoryRequests[$factoryClass] == $rName ) { return false; } $objectHash = spl_object_hash($abstractFactory); if ($this->lastAbstractFactoryUsed === $objectHash && $this->lastCanonicalNameUsed === $cName) { $this->lastAbstractFactoryUsed = $this->lastCanonicalNameUsed = null; return false; } $this->lastAbstractFactoryUsed = $objectHash; $this->lastCanonicalNameUsed = $cName; if ($abstractFactory->canCreateServiceWithName($this, $cName, $rName)) { $this->lastAbstractFactoryUsed = $this->lastCanonicalNameUsed = null; return true; } } return false; } protected function checkForCircularAliasReference($alias, $nameOrAlias) { $aliases = $this->aliases; $aliases[$alias] = $nameOrAlias; $stack = array(); while (isset($aliases[$alias])) { if (isset($stack[$alias])) { throw new Exception\CircularReferenceException(sprintf( 'The alias definition "%s" : "%s" results in a circular reference: "%s" -> "%s"', $alias, $nameOrAlias, implode('" -> "', $stack), $alias )); } $stack[$alias] = $alias; $alias = $aliases[$alias]; } return $this; } public function setAlias($alias, $nameOrAlias) { if (!is_string($alias) || !is_string($nameOrAlias)) { throw new Exception\InvalidServiceNameException('Service or alias names must be strings.'); } $cAlias = $this->canonicalizeName($alias); $nameOrAlias = $this->canonicalizeName($nameOrAlias); if ($alias == '' || $nameOrAlias == '') { throw new Exception\InvalidServiceNameException('Invalid service name alias'); } if ($this->allowOverride === false && $this->has(array($cAlias, $alias), false)) { throw new Exception\InvalidServiceNameException(sprintf( 'An alias by the name "%s" or "%s" already exists', $cAlias, $alias )); } if ($this->hasAlias($alias)) { $this->checkForCircularAliasReference($cAlias, $nameOrAlias); } $this->aliases[$cAlias] = $nameOrAlias; return $this; } public function hasAlias($alias) { return isset($this->aliases[$this->canonicalizeName($alias)]); } public function createScopedServiceManager($peering = self::SCOPE_PARENT) { $scopedServiceManager = new ServiceManager(); if ($peering == self::SCOPE_PARENT) { $scopedServiceManager->peeringServiceManagers[] = $this; } if ($peering == self::SCOPE_CHILD) { $this->peeringServiceManagers[] = $scopedServiceManager; } return $scopedServiceManager; } public function addPeeringServiceManager(ServiceManager $manager, $peering = self::SCOPE_PARENT) { if ($peering == self::SCOPE_PARENT) { $this->peeringServiceManagers[] = $manager; } if ($peering == self::SCOPE_CHILD) { $manager->peeringServiceManagers[] = $this; } return $this; } protected function canonicalizeName($name) { if (isset($this->canonicalNames[$name])) { return $this->canonicalNames[$name]; } return $this->canonicalNames[$name] = strtolower(strtr($name, $this->canonicalNamesReplacements)); } protected function createServiceViaCallback($callable, $cName, $rName) { static $circularDependencyResolver = array(); $depKey = spl_object_hash($this) . '-' . $cName; if (isset($circularDependencyResolver[$depKey])) { $circularDependencyResolver = array(); throw new Exception\CircularDependencyFoundException('Circular dependency for LazyServiceLoader was found for instance ' . $rName); } try { $circularDependencyResolver[$depKey] = true; $instance = call_user_func($callable, $this, $cName, $rName); unset($circularDependencyResolver[$depKey]); } catch (Exception\ServiceNotFoundException $e) { unset($circularDependencyResolver[$depKey]); throw $e; } catch (\Exception $e) { unset($circularDependencyResolver[$depKey]); throw new Exception\ServiceNotCreatedException( sprintf('An exception was raised while creating "%s"; no instance returned', $rName), $e->getCode(), $e ); } if ($instance === null) { throw new Exception\ServiceNotCreatedException('The factory was called but did not return an instance.'); } return $instance; } public function getRegisteredServices() { return array( 'invokableClasses' => array_keys($this->invokableClasses), 'factories' => array_keys($this->factories), 'aliases' => array_keys($this->aliases), 'instances' => array_keys($this->instances), ); } public function getCanonicalNames() { return $this->canonicalNames; } public function setCanonicalNames($canonicalNames) { $this->canonicalNames = $canonicalNames; return $this; } protected function retrieveFromPeeringManager($name) { foreach ($this->peeringServiceManagers as $peeringServiceManager) { if ($peeringServiceManager->has($name)) { return $peeringServiceManager->get($name); } } $name = $this->canonicalizeName($name); if ($this->hasAlias($name)) { do { $name = $this->aliases[$name]; } while ($this->hasAlias($name)); } foreach ($this->peeringServiceManagers as $peeringServiceManager) { if ($peeringServiceManager->has($name)) { return $peeringServiceManager->get($name); } } return null; } protected function createFromInvokable($canonicalName, $requestedName) { $invokable = $this->invokableClasses[$canonicalName]; if (!class_exists($invokable)) { throw new Exception\ServiceNotFoundException(sprintf( '%s: failed retrieving "%s%s" via invokable class "%s"; class does not exist', get_class($this) . '::' . __FUNCTION__, $canonicalName, ($requestedName ? '(alias: ' . $requestedName . ')' : ''), $invokable )); } $instance = new $invokable; return $instance; } protected function createFromFactory($canonicalName, $requestedName) { $factory = $this->factories[$canonicalName]; if (is_string($factory) && class_exists($factory, true)) { $factory = new $factory; $this->factories[$canonicalName] = $factory; } if ($factory instanceof FactoryInterface) { $instance = $this->createServiceViaCallback(array($factory, 'createService'), $canonicalName, $requestedName); } elseif (is_callable($factory)) { $instance = $this->createServiceViaCallback($factory, $canonicalName, $requestedName); } else { throw new Exception\ServiceNotCreatedException(sprintf( 'While attempting to create %s%s an invalid factory was registered for this instance type.', $canonicalName, ($requestedName ? '(alias: ' . $requestedName . ')' : '') )); } return $instance; } protected function createFromAbstractFactory($canonicalName, $requestedName) { foreach ($this->abstractFactories as $index => $abstractFactory) { if (is_string($abstractFactory) && class_exists($abstractFactory, true)) { $this->abstractFactories[$index] = $abstractFactory = new $abstractFactory; } elseif (!$abstractFactory instanceof AbstractFactoryInterface) { throw new Exception\ServiceNotCreatedException(sprintf( 'While attempting to create %s%s an abstract factory could not produce a valid instance.', $canonicalName, ($requestedName ? '(alias: ' . $requestedName . ')' : '') )); } try { if ($abstractFactory->canCreateServiceWithName($this, $canonicalName, $requestedName)) { $this->pendingAbstractFactoryRequests[get_class($abstractFactory)] = $requestedName; $instance = $this->createServiceViaCallback( array($abstractFactory, 'createServiceWithName'), $canonicalName, $requestedName ); unset($this->pendingAbstractFactoryRequests[get_class($abstractFactory)]); } else { $instance = null; } } catch (\Exception $e) { unset($this->pendingAbstractFactoryRequests[get_class($abstractFactory)]); throw new Exception\ServiceNotCreatedException( sprintf( 'An abstract factory could not create an instance of %s%s.', $canonicalName, ($requestedName ? '(alias: ' . $requestedName . ')' : '') ), $e->getCode(), $e ); } if ($instance !== null) { return $instance; } } } protected function createDelegatorFromFactory($canonicalName, $requestedName) { $serviceManager = $this; $delegatorsCount = count($this->delegators[$canonicalName]); $creationCallback = function () use ($serviceManager, $requestedName, $canonicalName) { return $serviceManager->doCreate($requestedName, $canonicalName); }; for ($i = 0; $i < $delegatorsCount; $i += 1) { $delegatorFactory = $this->delegators[$canonicalName][$i]; if (is_string($delegatorFactory)) { $delegatorFactory = !$this->has($delegatorFactory) && class_exists($delegatorFactory, true) ? new $delegatorFactory : $this->get($delegatorFactory); $this->delegators[$canonicalName][$i] = $delegatorFactory; } if (!$delegatorFactory instanceof DelegatorFactoryInterface && !is_callable($delegatorFactory)) { throw new Exception\ServiceNotCreatedException(sprintf( 'While attempting to create %s%s an invalid factory was registered for this instance type.', $canonicalName, ($requestedName ? '(alias: ' . $requestedName . ')' : '') )); } $creationCallback = $this->createDelegatorCallback( $delegatorFactory, $requestedName, $canonicalName, $creationCallback ); } return $creationCallback($serviceManager, $canonicalName, $requestedName, $creationCallback); } protected static function isSubclassOf($className, $type) { if (is_subclass_of($className, $type)) { return true; } if (version_compare(PHP_VERSION, '5.3.7', '>=')) { return false; } if (!interface_exists($type)) { return false; } $r = new ReflectionClass($className); return $r->implementsInterface($type); } protected function unregisterService($canonical) { $types = array('invokableClasses', 'factories', 'aliases'); foreach ($types as $type) { if (isset($this->{$type}[$canonical])) { unset($this->{$type}[$canonical]); break; } } if (isset($this->instances[$canonical])) { unset($this->instances[$canonical]); } if (isset($this->shared[$canonical])) { unset($this->shared[$canonical]); } } } 
namespace Zend\ServiceManager; interface ConfigInterface { public function configureServiceManager(ServiceManager $serviceManager); } 
namespace Zend\Mvc\Service; use Zend\EventManager\EventManagerAwareInterface; use Zend\EventManager\EventManagerInterface; use Zend\ServiceManager\ConfigInterface; use Zend\ServiceManager\ServiceLocatorAwareInterface; use Zend\ServiceManager\ServiceManager; use Zend\ServiceManager\ServiceManagerAwareInterface; class ServiceManagerConfig implements ConfigInterface { protected $invokables = array( 'SharedEventManager' => 'Zend\EventManager\SharedEventManager', ); protected $factories = array( 'EventManager' => 'Zend\Mvc\Service\EventManagerFactory', 'ModuleManager' => 'Zend\Mvc\Service\ModuleManagerFactory', ); protected $abstractFactories = array(); protected $aliases = array( 'Zend\EventManager\EventManagerInterface' => 'EventManager', ); protected $shared = array( 'EventManager' => false, ); public function __construct(array $configuration = array()) { if (isset($configuration['invokables'])) { $this->invokables = array_merge($this->invokables, $configuration['invokables']); } if (isset($configuration['factories'])) { $this->factories = array_merge($this->factories, $configuration['factories']); } if (isset($configuration['abstract_factories'])) { $this->abstractFactories = array_merge($this->abstractFactories, $configuration['abstract_factories']); } if (isset($configuration['aliases'])) { $this->aliases = array_merge($this->aliases, $configuration['aliases']); } if (isset($configuration['shared'])) { $this->shared = array_merge($this->shared, $configuration['shared']); } } public function configureServiceManager(ServiceManager $serviceManager) { foreach ($this->invokables as $name => $class) { $serviceManager->setInvokableClass($name, $class); } foreach ($this->factories as $name => $factoryClass) { $serviceManager->setFactory($name, $factoryClass); } foreach ($this->abstractFactories as $factoryClass) { $serviceManager->addAbstractFactory($factoryClass); } foreach ($this->aliases as $name => $service) { $serviceManager->setAlias($name, $service); } foreach ($this->shared as $name => $value) { $serviceManager->setShared($name, $value); } $serviceManager->addInitializer(function ($instance) use ($serviceManager) { if ($instance instanceof EventManagerAwareInterface) { if ($instance->getEventManager() instanceof EventManagerInterface) { $instance->getEventManager()->setSharedManager( $serviceManager->get('SharedEventManager') ); } else { $instance->setEventManager($serviceManager->get('EventManager')); } } }); $serviceManager->addInitializer(function ($instance) use ($serviceManager) { if ($instance instanceof ServiceManagerAwareInterface) { $instance->setServiceManager($serviceManager); } }); $serviceManager->addInitializer(function ($instance) use ($serviceManager) { if ($instance instanceof ServiceLocatorAwareInterface) { $instance->setServiceLocator($serviceManager); } }); $serviceManager->setService('ServiceManager', $serviceManager); $serviceManager->setAlias('Zend\ServiceManager\ServiceLocatorInterface', 'ServiceManager'); $serviceManager->setAlias('Zend\ServiceManager\ServiceManager', 'ServiceManager'); } } 
namespace Zend\ServiceManager; interface FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator); } 
namespace Zend\Mvc\Service; use Zend\ModuleManager\Listener\DefaultListenerAggregate; use Zend\ModuleManager\Listener\ListenerOptions; use Zend\ModuleManager\ModuleEvent; use Zend\ModuleManager\ModuleManager; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class ModuleManagerFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { if (!$serviceLocator->has('ServiceListener')) { $serviceLocator->setFactory('ServiceListener', 'Zend\Mvc\Service\ServiceListenerFactory'); } $configuration = $serviceLocator->get('ApplicationConfig'); $listenerOptions = new ListenerOptions($configuration['module_listener_options']); $defaultListeners = new DefaultListenerAggregate($listenerOptions); $serviceListener = $serviceLocator->get('ServiceListener'); $serviceListener->addServiceManager( $serviceLocator, 'service_manager', 'Zend\ModuleManager\Feature\ServiceProviderInterface', 'getServiceConfig' ); $serviceListener->addServiceManager( 'ControllerLoader', 'controllers', 'Zend\ModuleManager\Feature\ControllerProviderInterface', 'getControllerConfig' ); $serviceListener->addServiceManager( 'ControllerPluginManager', 'controller_plugins', 'Zend\ModuleManager\Feature\ControllerPluginProviderInterface', 'getControllerPluginConfig' ); $serviceListener->addServiceManager( 'ViewHelperManager', 'view_helpers', 'Zend\ModuleManager\Feature\ViewHelperProviderInterface', 'getViewHelperConfig' ); $serviceListener->addServiceManager( 'ValidatorManager', 'validators', 'Zend\ModuleManager\Feature\ValidatorProviderInterface', 'getValidatorConfig' ); $serviceListener->addServiceManager( 'FilterManager', 'filters', 'Zend\ModuleManager\Feature\FilterProviderInterface', 'getFilterConfig' ); $serviceListener->addServiceManager( 'FormElementManager', 'form_elements', 'Zend\ModuleManager\Feature\FormElementProviderInterface', 'getFormElementConfig' ); $serviceListener->addServiceManager( 'RoutePluginManager', 'route_manager', 'Zend\ModuleManager\Feature\RouteProviderInterface', 'getRouteConfig' ); $serviceListener->addServiceManager( 'SerializerAdapterManager', 'serializers', 'Zend\ModuleManager\Feature\SerializerProviderInterface', 'getSerializerConfig' ); $serviceListener->addServiceManager( 'HydratorManager', 'hydrators', 'Zend\ModuleManager\Feature\HydratorProviderInterface', 'getHydratorConfig' ); $serviceListener->addServiceManager( 'InputFilterManager', 'input_filters', 'Zend\ModuleManager\Feature\InputFilterProviderInterface', 'getInputFilterConfig' ); $events = $serviceLocator->get('EventManager'); $events->attach($defaultListeners); $events->attach($serviceListener); $moduleEvent = new ModuleEvent; $moduleEvent->setParam('ServiceManager', $serviceLocator); $moduleManager = new ModuleManager($configuration['modules'], $events); $moduleManager->setEvent($moduleEvent); return $moduleManager; } } 
namespace Zend\Stdlib; interface ParameterObjectInterface { public function __set($key, $value); public function __get($key); public function __isset($key); public function __unset($key); } 
namespace Zend\Stdlib; use Traversable; abstract class AbstractOptions implements ParameterObjectInterface { protected $__strictMode__ = true; public function __construct($options = null) { if (null !== $options) { $this->setFromArray($options); } } public function setFromArray($options) { if ($options instanceof self) { $options = $options->toArray(); } if (!is_array($options) && !$options instanceof Traversable) { throw new Exception\InvalidArgumentException(sprintf( 'Parameter provided to %s must be an %s, %s or %s', __METHOD__, 'array', 'Traversable', 'Zend\Stdlib\AbstractOptions' )); } foreach ($options as $key => $value) { $this->__set($key, $value); } return $this; } public function toArray() { $array = array(); $transform = function ($letters) { $letter = array_shift($letters); return '_' . strtolower($letter); }; foreach ($this as $key => $value) { if ($key === '__strictMode__') continue; $normalizedKey = preg_replace_callback('/([A-Z])/', $transform, $key); $array[$normalizedKey] = $value; } return $array; } public function __set($key, $value) { $setter = 'set' . str_replace(' ', '', ucwords(str_replace('_', ' ', $key))); if ($this->__strictMode__ && !method_exists($this, $setter)) { throw new Exception\BadMethodCallException( 'The option "' . $key . '" does not ' . 'have a matching ' . $setter . ' setter method ' . 'which must be defined' ); } elseif (!$this->__strictMode__ && !method_exists($this, $setter)) { return; } $this->{$setter}($value); } public function __get($key) { $getter = 'get' . str_replace(' ', '', ucwords(str_replace('_', ' ', $key))); if (!method_exists($this, $getter)) { throw new Exception\BadMethodCallException( 'The option "' . $key . '" does not ' . 'have a matching ' . $getter . ' getter method ' . 'which must be defined' ); } return $this->{$getter}(); } public function __isset($key) { return null !== $this->__get($key); } public function __unset($key) { try { $this->__set($key, null); } catch (Exception\BadMethodCallException $e) { throw new Exception\InvalidArgumentException( 'The class property $' . $key . ' cannot be unset as' . ' NULL is an invalid value for it', 0, $e ); } } } 
namespace Zend\ModuleManager\Listener; use Traversable; use Zend\Stdlib\AbstractOptions; class ListenerOptions extends AbstractOptions { protected $modulePaths = array(); protected $configGlobPaths = array(); protected $configStaticPaths = array(); protected $extraConfig = array(); protected $configCacheEnabled = false; protected $configCacheKey; protected $cacheDir; protected $checkDependencies = true; protected $moduleMapCacheEnabled = false; protected $moduleMapCacheKey; public function getModulePaths() { return $this->modulePaths; } public function setModulePaths($modulePaths) { if (!is_array($modulePaths) && !$modulePaths instanceof Traversable) { throw new Exception\InvalidArgumentException( sprintf('Argument passed to %s::%s() must be an array, ' . 'implement the Traversable interface, or be an ' . 'instance of Zend\Config\Config. %s given.', __CLASS__, __METHOD__, gettype($modulePaths)) ); } $this->modulePaths = $modulePaths; return $this; } public function getConfigGlobPaths() { return $this->configGlobPaths; } public function getConfigStaticPaths() { return $this->configStaticPaths; } public function setConfigGlobPaths($configGlobPaths) { if (!is_array($configGlobPaths) && !$configGlobPaths instanceof Traversable) { throw new Exception\InvalidArgumentException( sprintf('Argument passed to %s::%s() must be an array, ' . 'implement the Traversable interface, or be an ' . 'instance of Zend\Config\Config. %s given.', __CLASS__, __METHOD__, gettype($configGlobPaths)) ); } $this->configGlobPaths = $configGlobPaths; return $this; } public function setConfigStaticPaths($configStaticPaths) { if (!is_array($configStaticPaths) && !$configStaticPaths instanceof Traversable) { throw new Exception\InvalidArgumentException( sprintf('Argument passed to %s::%s() must be an array, ' . 'implement the Traversable interface, or be an ' . 'instance of Zend\Config\Config. %s given.', __CLASS__, __METHOD__, gettype($configStaticPaths)) ); } $this->configStaticPaths = $configStaticPaths; return $this; } public function getExtraConfig() { return $this->extraConfig; } public function setExtraConfig($extraConfig) { if (!is_array($extraConfig) && !$extraConfig instanceof Traversable) { throw new Exception\InvalidArgumentException( sprintf('Argument passed to %s::%s() must be an array, ' . 'implement the Traversable interface, or be an ' . 'instance of Zend\Config\Config. %s given.', __CLASS__, __METHOD__, gettype($extraConfig)) ); } $this->extraConfig = $extraConfig; return $this; } public function getConfigCacheEnabled() { return $this->configCacheEnabled; } public function setConfigCacheEnabled($enabled) { $this->configCacheEnabled = (bool) $enabled; return $this; } public function getConfigCacheKey() { return (string) $this->configCacheKey; } public function setConfigCacheKey($configCacheKey) { $this->configCacheKey = $configCacheKey; return $this; } public function getConfigCacheFile() { return $this->getCacheDir() . '/module-config-cache.' . $this->getConfigCacheKey().'.php'; } public function getCacheDir() { return $this->cacheDir; } public function setCacheDir($cacheDir) { if (null === $cacheDir) { $this->cacheDir = $cacheDir; } else { $this->cacheDir = static::normalizePath($cacheDir); } return $this; } public function getModuleMapCacheEnabled() { return $this->moduleMapCacheEnabled; } public function setModuleMapCacheEnabled($enabled) { $this->moduleMapCacheEnabled = (bool) $enabled; return $this; } public function getModuleMapCacheKey() { return (string) $this->moduleMapCacheKey; } public function setModuleMapCacheKey($moduleMapCacheKey) { $this->moduleMapCacheKey = $moduleMapCacheKey; return $this; } public function getModuleMapCacheFile() { return $this->getCacheDir() . '/module-classmap-cache.'.$this->getModuleMapCacheKey().'.php'; } public function getCheckDependencies() { return $this->checkDependencies; } public function setCheckDependencies($checkDependencies) { $this->checkDependencies = (bool) $checkDependencies; return $this; } public static function normalizePath($path) { $path = rtrim($path, '/'); $path = rtrim($path, '\\'); return $path; } } 
namespace Zend\EventManager; interface ListenerAggregateInterface { public function attach(EventManagerInterface $events); public function detach(EventManagerInterface $events); } 
namespace Zend\ModuleManager\Listener; abstract class AbstractListener { protected $options; public function __construct(ListenerOptions $options = null) { if (null === $options) { $this->setOptions(new ListenerOptions); } else { $this->setOptions($options); } } public function getOptions() { return $this->options; } public function setOptions(ListenerOptions $options) { $this->options = $options; return $this; } protected function writeArrayToFile($filePath, $array) { $content = "<?php\nreturn " . var_export($array, 1) . ';'; file_put_contents($filePath, $content); return $this; } } 
namespace Zend\ModuleManager\Listener; use Zend\EventManager\EventManagerInterface; use Zend\EventManager\ListenerAggregateInterface; use Zend\ModuleManager\ModuleEvent; use Zend\Stdlib\CallbackHandler; class DefaultListenerAggregate extends AbstractListener implements ListenerAggregateInterface { protected $listeners = array(); protected $configListener; public function attach(EventManagerInterface $events) { $options = $this->getOptions(); $configListener = $this->getConfigListener(); $locatorRegistrationListener = new LocatorRegistrationListener($options); $this->listeners[] = $events->attach(new ModuleLoaderListener($options)); $this->listeners[] = $events->attach(ModuleEvent::EVENT_LOAD_MODULE_RESOLVE, new ModuleResolverListener); $this->listeners[] = $events->attach(ModuleEvent::EVENT_LOAD_MODULE, new AutoloaderListener($options), 9000); if ($options->getCheckDependencies()) { $this->listeners[] = $events->attach(ModuleEvent::EVENT_LOAD_MODULE, new ModuleDependencyCheckerListener, 8000); } $this->listeners[] = $events->attach(ModuleEvent::EVENT_LOAD_MODULE, new InitTrigger($options)); $this->listeners[] = $events->attach(ModuleEvent::EVENT_LOAD_MODULE, new OnBootstrapListener($options)); $this->listeners[] = $events->attach($locatorRegistrationListener); $this->listeners[] = $events->attach($configListener); return $this; } public function detach(EventManagerInterface $events) { foreach ($this->listeners as $key => $listener) { $detached = false; if ($listener === $this) { continue; } if ($listener instanceof ListenerAggregateInterface) { $detached = $listener->detach($events); } elseif ($listener instanceof CallbackHandler) { $detached = $events->detach($listener); } if ($detached) { unset($this->listeners[$key]); } } } public function getConfigListener() { if (!$this->configListener instanceof ConfigMergerInterface) { $this->setConfigListener(new ConfigListener($this->getOptions())); } return $this->configListener; } public function setConfigListener(ConfigMergerInterface $configListener) { $this->configListener = $configListener; return $this; } } 
namespace Zend\Mvc\Service; use Zend\ModuleManager\Listener\ServiceListener; use Zend\ModuleManager\Listener\ServiceListenerInterface; use Zend\Mvc\Exception\InvalidArgumentException; use Zend\Mvc\Exception\RuntimeException; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class ServiceListenerFactory implements FactoryInterface { const MISSING_KEY_ERROR = 'Invalid service listener options detected, %s array must contain %s key.'; const VALUE_TYPE_ERROR = 'Invalid service listener options detected, %s must be a string, %s given.'; protected $defaultServiceConfig = array( 'invokables' => array( 'DispatchListener' => 'Zend\Mvc\DispatchListener', 'RouteListener' => 'Zend\Mvc\RouteListener', 'SendResponseListener' => 'Zend\Mvc\SendResponseListener' ), 'factories' => array( 'Application' => 'Zend\Mvc\Service\ApplicationFactory', 'Config' => 'Zend\Mvc\Service\ConfigFactory', 'ControllerLoader' => 'Zend\Mvc\Service\ControllerLoaderFactory', 'ControllerPluginManager' => 'Zend\Mvc\Service\ControllerPluginManagerFactory', 'ConsoleAdapter' => 'Zend\Mvc\Service\ConsoleAdapterFactory', 'ConsoleRouter' => 'Zend\Mvc\Service\RouterFactory', 'ConsoleViewManager' => 'Zend\Mvc\Service\ConsoleViewManagerFactory', 'DependencyInjector' => 'Zend\Mvc\Service\DiFactory', 'DiAbstractServiceFactory' => 'Zend\Mvc\Service\DiAbstractServiceFactoryFactory', 'DiServiceInitializer' => 'Zend\Mvc\Service\DiServiceInitializerFactory', 'DiStrictAbstractServiceFactory' => 'Zend\Mvc\Service\DiStrictAbstractServiceFactoryFactory', 'FilterManager' => 'Zend\Mvc\Service\FilterManagerFactory', 'FormElementManager' => 'Zend\Mvc\Service\FormElementManagerFactory', 'HttpRouter' => 'Zend\Mvc\Service\RouterFactory', 'HttpViewManager' => 'Zend\Mvc\Service\HttpViewManagerFactory', 'HydratorManager' => 'Zend\Mvc\Service\HydratorManagerFactory', 'InputFilterManager' => 'Zend\Mvc\Service\InputFilterManagerFactory', 'MvcTranslator' => 'Zend\Mvc\Service\TranslatorServiceFactory', 'PaginatorPluginManager' => 'Zend\Mvc\Service\PaginatorPluginManagerFactory', 'Request' => 'Zend\Mvc\Service\RequestFactory', 'Response' => 'Zend\Mvc\Service\ResponseFactory', 'Router' => 'Zend\Mvc\Service\RouterFactory', 'RoutePluginManager' => 'Zend\Mvc\Service\RoutePluginManagerFactory', 'SerializerAdapterManager' => 'Zend\Mvc\Service\SerializerAdapterPluginManagerFactory', 'ValidatorManager' => 'Zend\Mvc\Service\ValidatorManagerFactory', 'ViewHelperManager' => 'Zend\Mvc\Service\ViewHelperManagerFactory', 'ViewFeedRenderer' => 'Zend\Mvc\Service\ViewFeedRendererFactory', 'ViewFeedStrategy' => 'Zend\Mvc\Service\ViewFeedStrategyFactory', 'ViewJsonRenderer' => 'Zend\Mvc\Service\ViewJsonRendererFactory', 'ViewJsonStrategy' => 'Zend\Mvc\Service\ViewJsonStrategyFactory', 'ViewManager' => 'Zend\Mvc\Service\ViewManagerFactory', 'ViewResolver' => 'Zend\Mvc\Service\ViewResolverFactory', 'ViewTemplateMapResolver' => 'Zend\Mvc\Service\ViewTemplateMapResolverFactory', 'ViewTemplatePathStack' => 'Zend\Mvc\Service\ViewTemplatePathStackFactory', ), 'aliases' => array( 'Configuration' => 'Config', 'Console' => 'ConsoleAdapter', 'Di' => 'DependencyInjector', 'Zend\Di\LocatorInterface' => 'DependencyInjector', 'Zend\Mvc\Controller\PluginManager' => 'ControllerPluginManager', 'Zend\View\Resolver\TemplateMapResolver' => 'ViewTemplateMapResolver', 'Zend\View\Resolver\TemplatePathStack' => 'ViewTemplatePathStack', 'Zend\View\Resolver\AggregateResolver' => 'ViewResolver', 'Zend\View\Resolver\ResolverInterface' => 'ViewResolver', ), 'abstract_factories' => array( 'Zend\Form\FormAbstractServiceFactory', ), ); public function createService(ServiceLocatorInterface $serviceLocator) { $configuration = $serviceLocator->get('ApplicationConfig'); if ($serviceLocator->has('ServiceListenerInterface')) { $serviceListener = $serviceLocator->get('ServiceListenerInterface'); if (!$serviceListener instanceof ServiceListenerInterface) { throw new RuntimeException( 'The service named ServiceListenerInterface must implement ' . 'Zend\ModuleManager\Listener\ServiceListenerInterface' ); } $serviceListener->setDefaultServiceConfig($this->defaultServiceConfig); } else { $serviceListener = new ServiceListener($serviceLocator, $this->defaultServiceConfig); } if (isset($configuration['service_listener_options'])) { if (!is_array($configuration['service_listener_options'])) { throw new InvalidArgumentException(sprintf( 'The value of service_listener_options must be an array, %s given.', gettype($configuration['service_listener_options']) )); } foreach ($configuration['service_listener_options'] as $key => $newServiceManager) { if (!isset($newServiceManager['service_manager'])) { throw new InvalidArgumentException(sprintf(self::MISSING_KEY_ERROR, $key, 'service_manager')); } elseif (!is_string($newServiceManager['service_manager'])) { throw new InvalidArgumentException(sprintf( self::VALUE_TYPE_ERROR, 'service_manager', gettype($newServiceManager['service_manager']) )); } if (!isset($newServiceManager['config_key'])) { throw new InvalidArgumentException(sprintf(self::MISSING_KEY_ERROR, $key, 'config_key')); } elseif (!is_string($newServiceManager['config_key'])) { throw new InvalidArgumentException(sprintf( self::VALUE_TYPE_ERROR, 'config_key', gettype($newServiceManager['config_key']) )); } if (!isset($newServiceManager['interface'])) { throw new InvalidArgumentException(sprintf(self::MISSING_KEY_ERROR, $key, 'interface')); } elseif (!is_string($newServiceManager['interface'])) { throw new InvalidArgumentException(sprintf( self::VALUE_TYPE_ERROR, 'interface', gettype($newServiceManager['interface']) )); } if (!isset($newServiceManager['method'])) { throw new InvalidArgumentException(sprintf(self::MISSING_KEY_ERROR, $key, 'method')); } elseif (!is_string($newServiceManager['method'])) { throw new InvalidArgumentException(sprintf( self::VALUE_TYPE_ERROR, 'method', gettype($newServiceManager['method']) )); } $serviceListener->addServiceManager( $newServiceManager['service_manager'], $newServiceManager['config_key'], $newServiceManager['interface'], $newServiceManager['method'] ); } } return $serviceListener; } } 
namespace Zend\ModuleManager\Listener; use Zend\EventManager\ListenerAggregateInterface; use Zend\ServiceManager\ServiceManager; interface ServiceListenerInterface extends ListenerAggregateInterface { public function addServiceManager($serviceManager, $key, $moduleInterface, $method); public function setDefaultServiceConfig($configuration); } 
namespace Zend\ModuleManager\Listener; use Traversable; use Zend\EventManager\EventManagerInterface; use Zend\ModuleManager\ModuleEvent; use Zend\ServiceManager\Config as ServiceConfig; use Zend\ServiceManager\ServiceManager; use Zend\Stdlib\ArrayUtils; class ServiceListener implements ServiceListenerInterface { protected $listeners = array(); protected $defaultServiceManager; protected $defaultServiceConfig; protected $serviceManagers = array(); public function __construct(ServiceManager $serviceManager, $configuration = null) { $this->defaultServiceManager = $serviceManager; if ($configuration !== null) { $this->setDefaultServiceConfig($configuration); } } public function setDefaultServiceConfig($configuration) { $this->defaultServiceConfig = $configuration; return $this; } public function addServiceManager($serviceManager, $key, $moduleInterface, $method) { if (is_string($serviceManager)) { $smKey = $serviceManager; } elseif ($serviceManager instanceof ServiceManager) { $smKey = spl_object_hash($serviceManager); } else { throw new Exception\RuntimeException(sprintf( 'Invalid service manager provided, expected ServiceManager or string, %s provided', (string) $serviceManager )); } $this->serviceManagers[$smKey] = array( 'service_manager' => $serviceManager, 'config_key' => $key, 'module_class_interface' => $moduleInterface, 'module_class_method' => $method, 'configuration' => array(), ); if ($key === 'service_manager' && $this->defaultServiceConfig) { $this->serviceManagers[$smKey]['configuration']['default_config'] = $this->defaultServiceConfig; } return $this; } public function attach(EventManagerInterface $events) { $this->listeners[] = $events->attach(ModuleEvent::EVENT_LOAD_MODULE, array($this, 'onLoadModule')); $this->listeners[] = $events->attach(ModuleEvent::EVENT_LOAD_MODULES_POST, array($this, 'onLoadModulesPost')); return $this; } public function detach(EventManagerInterface $events) { foreach ($this->listeners as $key => $listener) { if ($events->detach($listener)) { unset($this->listeners[$key]); } } } public function onLoadModule(ModuleEvent $e) { $module = $e->getModule(); foreach ($this->serviceManagers as $key => $sm) { if (!$module instanceof $sm['module_class_interface'] && !method_exists($module, $sm['module_class_method']) ) { continue; } $config = $module->{$sm['module_class_method']}(); if ($config instanceof ServiceConfig) { $config = $this->serviceConfigToArray($config); } if ($config instanceof Traversable) { $config = ArrayUtils::iteratorToArray($config); } if (!is_array($config)) { continue; } $fullname = $e->getModuleName() . '::' . $sm['module_class_method'] . '()'; $this->serviceManagers[$key]['configuration'][$fullname] = $config; } } public function onLoadModulesPost(ModuleEvent $e) { $configListener = $e->getConfigListener(); $config = $configListener->getMergedConfig(false); foreach ($this->serviceManagers as $key => $sm) { if (isset($config[$sm['config_key']]) && is_array($config[$sm['config_key']]) && !empty($config[$sm['config_key']]) ) { $this->serviceManagers[$key]['configuration']['merged_config'] = $config[$sm['config_key']]; } $smConfig = array(); foreach ($this->serviceManagers[$key]['configuration'] as $configs) { if (isset($configs['configuration_classes'])) { foreach ($configs['configuration_classes'] as $class) { $configs = ArrayUtils::merge($configs, $this->serviceConfigToArray($class)); } } $smConfig = ArrayUtils::merge($smConfig, $configs); } if (!$sm['service_manager'] instanceof ServiceManager) { $instance = $this->defaultServiceManager->get($sm['service_manager']); if (!$instance instanceof ServiceManager) { throw new Exception\RuntimeException(sprintf( 'Could not find a valid ServiceManager for %s', $sm['service_manager'] )); } $sm['service_manager'] = $instance; } $serviceConfig = new ServiceConfig($smConfig); $serviceConfig->configureServiceManager($sm['service_manager']); } } protected function serviceConfigToArray($config) { if (is_string($config) && class_exists($config)) { $class = $config; $config = new $class; } if (!$config instanceof ServiceConfig) { throw new Exception\RuntimeException(sprintf( 'Invalid service manager configuration class provided; received "%s", expected an instance of Zend\ServiceManager\Config', (is_object($config) ? get_class($config) : (is_scalar($config) ? $config : gettype($config))) )); } return array( 'abstract_factories' => $config->getAbstractFactories(), 'aliases' => $config->getAliases(), 'initializers' => $config->getInitializers(), 'factories' => $config->getFactories(), 'invokables' => $config->getInvokables(), 'services' => $config->getServices(), 'shared' => $config->getShared(), ); } } 
namespace Zend\Mvc\Service; use Zend\EventManager\EventManager; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class EventManagerFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { $em = new EventManager(); $em->setSharedManager($serviceLocator->get('SharedEventManager')); return $em; } } 
namespace Zend\EventManager; use Traversable; use Zend\Stdlib\CallbackHandler; interface EventManagerInterface extends SharedEventManagerAwareInterface { public function trigger($event, $target = null, $argv = array(), $callback = null); public function triggerUntil($event, $target, $argv = null, $callback = null); public function attach($event, $callback = null, $priority = 1); public function detach($listener); public function getEvents(); public function getListeners($event); public function clearListeners($event); public function setEventClass($class); public function getIdentifiers(); public function setIdentifiers($identifiers); public function addIdentifiers($identifiers); public function attachAggregate(ListenerAggregateInterface $aggregate, $priority = 1); public function detachAggregate(ListenerAggregateInterface $aggregate); } 
namespace Zend\EventManager; interface SharedEventManagerAwareInterface { public function setSharedManager(SharedEventManagerInterface $sharedEventManager); public function getSharedManager(); public function unsetSharedManager(); } 
namespace Zend\EventManager; use ArrayAccess; use ArrayObject; use Traversable; use Zend\Stdlib\CallbackHandler; use Zend\Stdlib\PriorityQueue; class EventManager implements EventManagerInterface { protected $events = array(); protected $eventClass = 'Zend\EventManager\Event'; protected $identifiers = array(); protected $sharedManager = null; public function __construct($identifiers = null) { $this->setIdentifiers($identifiers); } public function setEventClass($class) { $this->eventClass = $class; return $this; } public function setSharedManager(SharedEventManagerInterface $sharedEventManager) { $this->sharedManager = $sharedEventManager; StaticEventManager::setInstance($sharedEventManager); return $this; } public function unsetSharedManager() { $this->sharedManager = false; } public function getSharedManager() { if (false === $this->sharedManager || $this->sharedManager instanceof SharedEventManagerInterface ) { return $this->sharedManager; } if (!StaticEventManager::hasInstance()) { return false; } $this->sharedManager = StaticEventManager::getInstance(); return $this->sharedManager; } public function getIdentifiers() { return $this->identifiers; } public function setIdentifiers($identifiers) { if (is_array($identifiers) || $identifiers instanceof Traversable) { $this->identifiers = array_unique((array) $identifiers); } elseif ($identifiers !== null) { $this->identifiers = array($identifiers); } return $this; } public function addIdentifiers($identifiers) { if (is_array($identifiers) || $identifiers instanceof Traversable) { $this->identifiers = array_unique(array_merge($this->identifiers, (array) $identifiers)); } elseif ($identifiers !== null) { $this->identifiers = array_unique(array_merge($this->identifiers, array($identifiers))); } return $this; } public function trigger($event, $target = null, $argv = array(), $callback = null) { if ($event instanceof EventInterface) { $e = $event; $event = $e->getName(); $callback = $target; } elseif ($target instanceof EventInterface) { $e = $target; $e->setName($event); $callback = $argv; } elseif ($argv instanceof EventInterface) { $e = $argv; $e->setName($event); $e->setTarget($target); } else { $e = new $this->eventClass(); $e->setName($event); $e->setTarget($target); $e->setParams($argv); } if ($callback && !is_callable($callback)) { throw new Exception\InvalidCallbackException('Invalid callback provided'); } $e->stopPropagation(false); return $this->triggerListeners($event, $e, $callback); } public function triggerUntil($event, $target, $argv = null, $callback = null) { if ($event instanceof EventInterface) { $e = $event; $event = $e->getName(); $callback = $target; } elseif ($target instanceof EventInterface) { $e = $target; $e->setName($event); $callback = $argv; } elseif ($argv instanceof EventInterface) { $e = $argv; $e->setName($event); $e->setTarget($target); } else { $e = new $this->eventClass(); $e->setName($event); $e->setTarget($target); $e->setParams($argv); } if (!is_callable($callback)) { throw new Exception\InvalidCallbackException('Invalid callback provided'); } $e->stopPropagation(false); return $this->triggerListeners($event, $e, $callback); } public function attach($event, $callback = null, $priority = 1) { if ($event instanceof ListenerAggregateInterface) { return $this->attachAggregate($event, $callback); } if (null === $callback) { throw new Exception\InvalidArgumentException(sprintf( '%s: expects a callback; none provided', __METHOD__ )); } if (is_array($event)) { $listeners = array(); foreach ($event as $name) { $listeners[] = $this->attach($name, $callback, $priority); } return $listeners; } if (empty($this->events[$event])) { $this->events[$event] = new PriorityQueue(); } $listener = new CallbackHandler($callback, array('event' => $event, 'priority' => $priority)); $this->events[$event]->insert($listener, $priority); return $listener; } public function attachAggregate(ListenerAggregateInterface $aggregate, $priority = 1) { return $aggregate->attach($this, $priority); } public function detach($listener) { if ($listener instanceof ListenerAggregateInterface) { return $this->detachAggregate($listener); } if (!$listener instanceof CallbackHandler) { throw new Exception\InvalidArgumentException(sprintf( '%s: expected a ListenerAggregateInterface or CallbackHandler; received "%s"', __METHOD__, (is_object($listener) ? get_class($listener) : gettype($listener)) )); } $event = $listener->getMetadatum('event'); if (!$event || empty($this->events[$event])) { return false; } $return = $this->events[$event]->remove($listener); if (!$return) { return false; } if (!count($this->events[$event])) { unset($this->events[$event]); } return true; } public function detachAggregate(ListenerAggregateInterface $aggregate) { return $aggregate->detach($this); } public function getEvents() { return array_keys($this->events); } public function getListeners($event) { if (!array_key_exists($event, $this->events)) { return new PriorityQueue(); } return $this->events[$event]; } public function clearListeners($event) { if (!empty($this->events[$event])) { unset($this->events[$event]); } } public function prepareArgs(array $args) { return new ArrayObject($args); } protected function triggerListeners($event, EventInterface $e, $callback = null) { $responses = new ResponseCollection; $listeners = $this->getListeners($event); $sharedListeners = $this->getSharedListeners($event); $sharedWildcardListeners = $this->getSharedListeners('*'); $wildcardListeners = $this->getListeners('*'); if (count($sharedListeners) || count($sharedWildcardListeners) || count($wildcardListeners)) { $listeners = clone $listeners; $this->insertListeners($listeners, $sharedListeners); $this->insertListeners($listeners, $sharedWildcardListeners); $this->insertListeners($listeners, $wildcardListeners); } foreach ($listeners as $listener) { $listenerCallback = $listener->getCallback(); $responses->push(call_user_func($listenerCallback, $e)); if ($e->propagationIsStopped()) { $responses->setStopped(true); break; } if ($callback && call_user_func($callback, $responses->last())) { $responses->setStopped(true); break; } } return $responses; } protected function getSharedListeners($event) { if (!$sharedManager = $this->getSharedManager()) { return array(); } $identifiers = $this->getIdentifiers(); if (!in_array('*', $identifiers)) { $identifiers[] = '*'; } $sharedListeners = array(); foreach ($identifiers as $id) { if (!$listeners = $sharedManager->getListeners($id, $event)) { continue; } if (!is_array($listeners) && !($listeners instanceof Traversable)) { continue; } foreach ($listeners as $listener) { if (!$listener instanceof CallbackHandler) { continue; } $sharedListeners[] = $listener; } } return $sharedListeners; } protected function insertListeners($masterListeners, $listeners) { foreach ($listeners as $listener) { $priority = $listener->getMetadatum('priority'); if (null === $priority) { $priority = 1; } elseif (is_array($priority)) { $priority = array_shift($priority); } $masterListeners->insert($listener, $priority); } } } 
namespace Zend\EventManager; interface SharedEventAggregateAwareInterface { public function attachAggregate(SharedListenerAggregateInterface $aggregate, $priority = 1); public function detachAggregate(SharedListenerAggregateInterface $aggregate); } 
namespace Zend\EventManager; use Zend\Stdlib\CallbackHandler; use Zend\Stdlib\PriorityQueue; interface SharedEventManagerInterface { public function getListeners($id, $event); public function attach($id, $event, $callback, $priority = 1); public function detach($id, CallbackHandler $listener); public function getEvents($id); public function clearListeners($id, $event = null); } 
namespace Zend\EventManager; use Zend\Stdlib\CallbackHandler; use Zend\Stdlib\PriorityQueue; class SharedEventManager implements SharedEventAggregateAwareInterface, SharedEventManagerInterface { protected $identifiers = array(); public function attach($id, $event, $callback, $priority = 1) { $ids = (array) $id; $listeners = array(); foreach ($ids as $id) { if (!array_key_exists($id, $this->identifiers)) { $this->identifiers[$id] = new EventManager($id); } $listeners[] = $this->identifiers[$id]->attach($event, $callback, $priority); } if (count($listeners) > 1) { return $listeners; } return $listeners[0]; } public function attachAggregate(SharedListenerAggregateInterface $aggregate, $priority = 1) { return $aggregate->attachShared($this, $priority); } public function detach($id, CallbackHandler $listener) { if (!array_key_exists($id, $this->identifiers)) { return false; } return $this->identifiers[$id]->detach($listener); } public function detachAggregate(SharedListenerAggregateInterface $aggregate) { return $aggregate->detachShared($this); } public function getEvents($id) { if (!array_key_exists($id, $this->identifiers)) { if ('*' != $id && array_key_exists('*', $this->identifiers)) { return $this->identifiers['*']->getEvents(); } return false; } return $this->identifiers[$id]->getEvents(); } public function getListeners($id, $event) { if (!array_key_exists($id, $this->identifiers)) { return false; } return $this->identifiers[$id]->getListeners($event); } public function clearListeners($id, $event = null) { if (!array_key_exists($id, $this->identifiers)) { return false; } if (null === $event) { unset($this->identifiers[$id]); return true; } return $this->identifiers[$id]->clearListeners($event); } } 
namespace Zend\EventManager; class StaticEventManager extends SharedEventManager { protected static $instance; protected function __construct() { } private function __clone() { } public static function getInstance() { if (null === static::$instance) { static::setInstance(new static()); } return static::$instance; } public static function setInstance(SharedEventManagerInterface $instance) { static::$instance = $instance; } public static function hasInstance() { return (static::$instance instanceof SharedEventManagerInterface); } public static function resetInstance() { static::$instance = null; } } 
namespace Zend\ModuleManager\Listener; interface ConfigMergerInterface { public function getMergedConfig($returnConfigAsObject = true); public function setMergedConfig(array $config); } 
namespace Zend\ModuleManager\Listener; use Traversable; use Zend\Config\Config; use Zend\Config\Factory as ConfigFactory; use Zend\EventManager\EventManagerInterface; use Zend\EventManager\ListenerAggregateInterface; use Zend\ModuleManager\Feature\ConfigProviderInterface; use Zend\ModuleManager\ModuleEvent; use Zend\Stdlib\ArrayUtils; use Zend\Stdlib\Glob; class ConfigListener extends AbstractListener implements ConfigMergerInterface, ListenerAggregateInterface { const STATIC_PATH = 'static_path'; const GLOB_PATH = 'glob_path'; protected $callbacks = array(); protected $configs = array(); protected $mergedConfig = array(); protected $mergedConfigObject; protected $skipConfig = false; protected $paths = array(); public function __construct(ListenerOptions $options = null) { parent::__construct($options); if ($this->hasCachedConfig()) { $this->skipConfig = true; $this->setMergedConfig($this->getCachedConfig()); } else { $this->addConfigGlobPaths($this->getOptions()->getConfigGlobPaths()); $this->addConfigStaticPaths($this->getOptions()->getConfigStaticPaths()); } } public function attach(EventManagerInterface $events) { $this->callbacks[] = $events->attach(ModuleEvent::EVENT_LOAD_MODULES, array($this, 'onloadModulesPre'), 1000); if ($this->skipConfig) { return $this; } $this->callbacks[] = $events->attach(ModuleEvent::EVENT_LOAD_MODULE, array($this, 'onLoadModule')); $this->callbacks[] = $events->attach(ModuleEvent::EVENT_LOAD_MODULES, array($this, 'onLoadModulesPost'), -1000); return $this; } public function onloadModulesPre(ModuleEvent $e) { $e->setConfigListener($this); return $this; } public function onLoadModule(ModuleEvent $e) { $module = $e->getModule(); if (!$module instanceof ConfigProviderInterface && !is_callable(array($module, 'getConfig')) ) { return $this; } $config = $module->getConfig(); $this->addConfig($e->getModuleName(), $config); return $this; } public function onLoadModulesPost(ModuleEvent $e) { foreach ($this->paths as $path) { $this->addConfigByPath($path['path'], $path['type']); } $this->mergedConfig = $this->getOptions()->getExtraConfig() ?: array(); foreach ($this->configs as $config) { $this->mergedConfig = ArrayUtils::merge($this->mergedConfig, $config); } if ( $this->getOptions()->getConfigCacheEnabled() && false === $this->skipConfig ) { $configFile = $this->getOptions()->getConfigCacheFile(); $this->writeArrayToFile($configFile, $this->getMergedConfig(false)); } return $this; } public function detach(EventManagerInterface $events) { foreach ($this->callbacks as $index => $callback) { if ($events->detach($callback)) { unset($this->callbacks[$index]); } } } public function getMergedConfig($returnConfigAsObject = true) { if ($returnConfigAsObject === true) { if ($this->mergedConfigObject === null) { $this->mergedConfigObject = new Config($this->mergedConfig); } return $this->mergedConfigObject; } return $this->mergedConfig; } public function setMergedConfig(array $config) { $this->mergedConfig = $config; $this->mergedConfigObject = null; return $this; } public function addConfigGlobPaths($globPaths) { $this->addConfigPaths($globPaths, self::GLOB_PATH); return $this; } public function addConfigGlobPath($globPath) { $this->addConfigPath($globPath, self::GLOB_PATH); return $this; } public function addConfigStaticPaths($staticPaths) { $this->addConfigPaths($staticPaths, self::STATIC_PATH); return $this; } public function addConfigStaticPath($staticPath) { $this->addConfigPath($staticPath, self::STATIC_PATH); return $this; } protected function addConfigPaths($paths, $type) { if ($paths instanceof Traversable) { $paths = ArrayUtils::iteratorToArray($paths); } if (!is_array($paths)) { throw new Exception\InvalidArgumentException( sprintf('Argument passed to %::%s() must be an array, ' . 'implement the Traversable interface, or be an ' . 'instance of Zend\Config\Config. %s given.', __CLASS__, __METHOD__, gettype($paths)) ); } foreach ($paths as $path) { $this->addConfigPath($path, $type); } } protected function addConfigPath($path, $type) { if (!is_string($path)) { throw new Exception\InvalidArgumentException( sprintf('Parameter to %s::%s() must be a string; %s given.', __CLASS__, __METHOD__, gettype($path)) ); } $this->paths[] = array('type' => $type, 'path' => $path); return $this; } protected function addConfig($key, $config) { if ($config instanceof Traversable) { $config = ArrayUtils::iteratorToArray($config); } if (!is_array($config)) { throw new Exception\InvalidArgumentException( sprintf('Config being merged must be an array, ' . 'implement the Traversable interface, or be an ' . 'instance of Zend\Config\Config. %s given.', gettype($config)) ); } $this->configs[$key] = $config; return $this; } protected function addConfigByPath($path, $type) { switch ($type) { case self::STATIC_PATH: $this->addConfig($path, ConfigFactory::fromFile($path)); break; case self::GLOB_PATH: foreach (Glob::glob($path, Glob::GLOB_BRACE) as $file) { $this->addConfig($file, ConfigFactory::fromFile($file)); } break; } return $this; } protected function hasCachedConfig() { if (($this->getOptions()->getConfigCacheEnabled()) && (file_exists($this->getOptions()->getConfigCacheFile())) ) { return true; } return false; } protected function getCachedConfig() { return include $this->getOptions()->getConfigCacheFile(); } } 
namespace Zend\ModuleManager\Listener; use Zend\EventManager\Event; use Zend\EventManager\EventManagerInterface; use Zend\EventManager\ListenerAggregateInterface; use Zend\ModuleManager\Feature\LocatorRegisteredInterface; use Zend\ModuleManager\ModuleEvent; use Zend\Mvc\MvcEvent; class LocatorRegistrationListener extends AbstractListener implements ListenerAggregateInterface { protected $modules = array(); protected $callbacks = array(); public function onLoadModule(ModuleEvent $e) { if (!$e->getModule() instanceof LocatorRegisteredInterface) { return; } $this->modules[] = $e->getModule(); } public function onLoadModules(Event $e) { $moduleManager = $e->getTarget(); $events = $moduleManager->getEventManager()->getSharedManager(); if (!$events) { return; } $events->attach('Zend\Mvc\Application', MvcEvent::EVENT_BOOTSTRAP, function ($e) use ($moduleManager) { $moduleClassName = get_class($moduleManager); $moduleClassNameArray = explode('\\', $moduleClassName); $moduleClassNameAlias = end($moduleClassNameArray); $application = $e->getApplication(); $services = $application->getServiceManager(); if (!$services->has($moduleClassName)) { $services->setAlias($moduleClassName, $moduleClassNameAlias); } }, 1000); if (0 === count($this->modules)) { return; } $events->attach('Zend\Mvc\Application', MvcEvent::EVENT_BOOTSTRAP, array($this, 'onBootstrap'), 1000); } public function onBootstrap(Event $e) { $application = $e->getApplication(); $services = $application->getServiceManager(); foreach ($this->modules as $module) { $moduleClassName = get_class($module); if (!$services->has($moduleClassName)) { $services->setService($moduleClassName, $module); } } } public function attach(EventManagerInterface $events) { $this->callbacks[] = $events->attach(ModuleEvent::EVENT_LOAD_MODULE, array($this, 'onLoadModule')); $this->callbacks[] = $events->attach(ModuleEvent::EVENT_LOAD_MODULES, array($this, 'onLoadModules'), -1000); return $this; } public function detach(EventManagerInterface $events) { foreach ($this->callbacks as $index => $callback) { if ($events->detach($callback)) { unset($this->callbacks[$index]); } } } } 
namespace Zend\ModuleManager\Listener; use Zend\EventManager\EventManagerInterface; use Zend\EventManager\ListenerAggregateInterface; use Zend\Loader\ModuleAutoloader; use Zend\ModuleManager\ModuleEvent; class ModuleLoaderListener extends AbstractListener implements ListenerAggregateInterface { protected $moduleLoader; protected $generateCache; protected $callbacks = array(); public function __construct(ListenerOptions $options = null) { parent::__construct($options); $this->generateCache = $this->options->getModuleMapCacheEnabled(); $this->moduleLoader = new ModuleAutoloader($this->options->getModulePaths()); if ($this->hasCachedClassMap()) { $this->generateCache = false; $this->moduleLoader->setModuleClassMap($this->getCachedConfig()); } } public function attach(EventManagerInterface $events) { $this->callbacks[] = $events->attach( ModuleEvent::EVENT_LOAD_MODULES, array($this->moduleLoader, 'register'), 9000 ); if ($this->generateCache) { $this->callbacks[] = $events->attach( ModuleEvent::EVENT_LOAD_MODULES_POST, array($this, 'onLoadModulesPost') ); } } public function detach(EventManagerInterface $events) { foreach ($this->callbacks as $index => $callback) { if ($events->detach($callback)) { unset($this->callbacks[$index]); } } } protected function hasCachedClassMap() { if ( $this->options->getModuleMapCacheEnabled() && file_exists($this->options->getModuleMapCacheFile()) ) { return true; } return false; } protected function getCachedConfig() { return include $this->options->getModuleMapCacheFile(); } public function onLoadModulesPost(ModuleEvent $event) { $this->moduleLoader->unregister(); $this->writeArrayToFile( $this->options->getModuleMapCacheFile(), $this->moduleLoader->getModuleClassMap() ); } } 
namespace Zend\Loader; require_once 'D:/EtahWebServer/htdocs/FastZF2-master/vendor/ZF2/library/Zend/Loader' . '/SplAutoloader.php'; use GlobIterator; use SplFileInfo; use Traversable; class ModuleAutoloader implements SplAutoloader { protected $paths = array(); protected $explicitPaths = array(); protected $namespacedPaths = array(); protected $pharExtensions = array(); protected $moduleClassMap = array(); public function __construct($options = null) { if (extension_loaded('phar')) { $this->pharExtensions = array( 'phar', 'phar.tar', 'tar', ); if (extension_loaded('zlib')) { $this->pharExtensions[] = 'phar.gz'; $this->pharExtensions[] = 'phar.tar.gz'; $this->pharExtensions[] = 'tar.gz'; $this->pharExtensions[] = 'phar.zip'; $this->pharExtensions[] = 'zip'; } if (extension_loaded('bzip2')) { $this->pharExtensions[] = 'phar.bz2'; $this->pharExtensions[] = 'phar.tar.bz2'; $this->pharExtensions[] = 'tar.bz2'; } } if (null !== $options) { $this->setOptions($options); } } public function setOptions($options) { $this->registerPaths($options); return $this; } public function getModuleClassMap() { return $this->moduleClassMap; } public function setModuleClassMap(array $classmap) { $this->moduleClassMap = $classmap; return $this; } public function autoload($class) { if (substr($class, -7) !== '\Module') { return false; } if (isset($this->moduleClassMap[$class])) { require_once $this->moduleClassMap[$class]; return $class; } $moduleName = substr($class, 0, -7); if (isset($this->explicitPaths[$moduleName])) { $classLoaded = $this->loadModuleFromDir($this->explicitPaths[$moduleName], $class); if ($classLoaded) { return $classLoaded; } $classLoaded = $this->loadModuleFromPhar($this->explicitPaths[$moduleName], $class); if ($classLoaded) { return $classLoaded; } } if (count($this->namespacedPaths) >= 1) { foreach ($this->namespacedPaths as $namespace => $path) { if (false === strpos($moduleName, $namespace)) { continue; } $moduleNameBuffer = str_replace($namespace . "\\", "", $moduleName ); $path .= DIRECTORY_SEPARATOR . $moduleNameBuffer . DIRECTORY_SEPARATOR; $classLoaded = $this->loadModuleFromDir($path, $class); if ($classLoaded) { return $classLoaded; } $classLoaded = $this->loadModuleFromPhar($path, $class); if ($classLoaded) { return $classLoaded; } } } $moduleClassPath = str_replace('\\', DIRECTORY_SEPARATOR, $moduleName); $pharSuffixPattern = null; if ($this->pharExtensions) { $pharSuffixPattern = '(' . implode('|', array_map('preg_quote', $this->pharExtensions)) . ')'; } foreach ($this->paths as $path) { $path = $path . $moduleClassPath; $classLoaded = $this->loadModuleFromDir($path, $class); if ($classLoaded) { return $classLoaded; } if ($pharSuffixPattern) { foreach (new GlobIterator($path . '.*') as $entry) { if ($entry->isDir()) { continue; } if (!preg_match('#.+\.' . $pharSuffixPattern . '$#', $entry->getPathname())) { continue; } $classLoaded = $this->loadModuleFromPhar($entry->getPathname(), $class); if ($classLoaded) { return $classLoaded; } } } } return false; } protected function loadModuleFromDir($dirPath, $class) { $file = new SplFileInfo($dirPath . '/Module.php'); if ($file->isReadable() && $file->isFile()) { require_once $file->getRealPath(); if (class_exists($class)) { $this->moduleClassMap[$class] = $file->getRealPath(); return $class; } } return false; } protected function loadModuleFromPhar($pharPath, $class) { $pharPath = static::normalizePath($pharPath, false); $file = new SplFileInfo($pharPath); if (!$file->isReadable() || !$file->isFile()) { return false; } $fileRealPath = $file->getRealPath(); if (strpos($fileRealPath, '.phar') !== false) { require_once $fileRealPath; if (class_exists($class)) { $this->moduleClassMap[$class] = $fileRealPath; return $class; } } $moduleClassFile = 'phar://' . $fileRealPath . '/Module.php'; $moduleFile = new SplFileInfo($moduleClassFile); if ($moduleFile->isReadable() && $moduleFile->isFile()) { require_once $moduleClassFile; if (class_exists($class)) { $this->moduleClassMap[$class] = $moduleClassFile; return $class; } } $pharBaseName = $this->pharFileToModuleName($fileRealPath); $moduleClassFile = 'phar://' . $fileRealPath . '/' . $pharBaseName . '/Module.php'; $moduleFile = new SplFileInfo($moduleClassFile); if ($moduleFile->isReadable() && $moduleFile->isFile()) { require_once $moduleClassFile; if (class_exists($class)) { $this->moduleClassMap[$class] = $moduleClassFile; return $class; } } return false; } public function register() { spl_autoload_register(array($this, 'autoload')); } public function unregister() { spl_autoload_unregister(array($this, 'autoload')); } public function registerPaths($paths) { if (!is_array($paths) && !$paths instanceof Traversable) { require_once 'D:/EtahWebServer/htdocs/FastZF2-master/vendor/ZF2/library/Zend/Loader' . '/Exception/InvalidArgumentException.php'; throw new Exception\InvalidArgumentException( 'Parameter to \\Zend\\Loader\\ModuleAutoloader\'s ' . 'registerPaths method must be an array or ' . 'implement the Traversable interface' ); } foreach ($paths as $module => $path) { if (is_string($module)) { $this->registerPath($path, $module); } else { $this->registerPath($path); } } return $this; } public function registerPath($path, $moduleName = false) { if (!is_string($path)) { require_once 'D:/EtahWebServer/htdocs/FastZF2-master/vendor/ZF2/library/Zend/Loader' . '/Exception/InvalidArgumentException.php'; throw new Exception\InvalidArgumentException(sprintf( 'Invalid path provided; must be a string, received %s', gettype($path) )); } if ($moduleName) { if (in_array( substr($moduleName, -2), array('\\*', '\\%'))) { $this->namespacedPaths[substr($moduleName, 0, -2)] = static::normalizePath($path); } else { $this->explicitPaths[$moduleName] = static::normalizePath($path); } } else { $this->paths[] = static::normalizePath($path); } return $this; } public function getPaths() { return $this->paths; } protected function pharFileToModuleName($pharPath) { do { $pathinfo = pathinfo($pharPath); $pharPath = $pathinfo['filename']; } while (isset($pathinfo['extension'])); return $pathinfo['filename']; } public static function normalizePath($path, $trailingSlash = true) { $path = rtrim($path, '/'); $path = rtrim($path, '\\'); if ($trailingSlash) { $path .= DIRECTORY_SEPARATOR; } return $path; } } 
namespace Zend\EventManager; use ArrayAccess; interface EventInterface { public function getName(); public function getTarget(); public function getParams(); public function getParam($name, $default = null); public function setName($name); public function setTarget($target); public function setParams($params); public function setParam($name, $value); public function stopPropagation($flag = true); public function propagationIsStopped(); } 
namespace Zend\EventManager; use ArrayAccess; class Event implements EventInterface { protected $name; protected $target; protected $params = array(); protected $stopPropagation = false; public function __construct($name = null, $target = null, $params = null) { if (null !== $name) { $this->setName($name); } if (null !== $target) { $this->setTarget($target); } if (null !== $params) { $this->setParams($params); } } public function getName() { return $this->name; } public function getTarget() { return $this->target; } public function setParams($params) { if (!is_array($params) && !is_object($params)) { throw new Exception\InvalidArgumentException(sprintf( 'Event parameters must be an array or object; received "%s"', gettype($params) )); } $this->params = $params; return $this; } public function getParams() { return $this->params; } public function getParam($name, $default = null) { if (is_array($this->params) || $this->params instanceof ArrayAccess) { if (!isset($this->params[$name])) { return $default; } return $this->params[$name]; } if (!isset($this->params->{$name})) { return $default; } return $this->params->{$name}; } public function setName($name) { $this->name = (string) $name; return $this; } public function setTarget($target) { $this->target = $target; return $this; } public function setParam($name, $value) { if (is_array($this->params) || $this->params instanceof ArrayAccess) { $this->params[$name] = $value; } else { $this->params->{$name} = $value; } return $this; } public function stopPropagation($flag = true) { $this->stopPropagation = (bool) $flag; } public function propagationIsStopped() { return $this->stopPropagation; } } 
namespace Zend\ModuleManager; use Zend\EventManager\Event; class ModuleEvent extends Event { CONST EVENT_MERGE_CONFIG = 'mergeConfig'; CONST EVENT_LOAD_MODULES = 'loadModules'; CONST EVENT_LOAD_MODULE_RESOLVE = 'loadModule.resolve'; CONST EVENT_LOAD_MODULE = 'loadModule'; CONST EVENT_LOAD_MODULES_POST = 'loadModules.post'; protected $module; protected $moduleName; protected $configListener; public function getModuleName() { return $this->moduleName; } public function setModuleName($moduleName) { if (!is_string($moduleName)) { throw new Exception\InvalidArgumentException(sprintf( '%s expects a string as an argument; %s provided' ,__METHOD__, gettype($moduleName) )); } $this->moduleName = $moduleName; return $this; } public function getModule() { return $this->module; } public function setModule($module) { if (!is_object($module)) { throw new Exception\InvalidArgumentException(sprintf( '%s expects a module object as an argument; %s provided' ,__METHOD__, gettype($module) )); } $this->module = $module; return $this; } public function getConfigListener() { return $this->configListener; } public function setConfigListener(Listener\ConfigMergerInterface $configListener) { $this->setParam('configListener', $configListener); $this->configListener = $configListener; return $this; } } 
namespace Zend\Stdlib; use Countable; use IteratorAggregate; use Serializable; class PriorityQueue implements Countable, IteratorAggregate, Serializable { const EXTR_DATA = 0x00000001; const EXTR_PRIORITY = 0x00000002; const EXTR_BOTH = 0x00000003; protected $queueClass = 'Zend\Stdlib\SplPriorityQueue'; protected $items = array(); protected $queue; public function insert($data, $priority = 1) { $priority = (int) $priority; $this->items[] = array( 'data' => $data, 'priority' => $priority, ); $this->getQueue()->insert($data, $priority); return $this; } public function remove($datum) { $found = false; foreach ($this->items as $key => $item) { if ($item['data'] === $datum) { $found = true; break; } } if ($found) { unset($this->items[$key]); $this->queue = null; if (!$this->isEmpty()) { $queue = $this->getQueue(); foreach ($this->items as $item) { $queue->insert($item['data'], $item['priority']); } } return true; } return false; } public function isEmpty() { return (0 === $this->count()); } public function count() { return count($this->items); } public function top() { return $this->getIterator()->top(); } public function extract() { return $this->getQueue()->extract(); } public function getIterator() { $queue = $this->getQueue(); return clone $queue; } public function serialize() { return serialize($this->items); } public function unserialize($data) { foreach (unserialize($data) as $item) { $this->insert($item['data'], $item['priority']); } } public function toArray($flag = self::EXTR_DATA) { switch ($flag) { case self::EXTR_BOTH: return $this->items; break; case self::EXTR_PRIORITY: return array_map(function ($item) { return $item['priority']; }, $this->items); case self::EXTR_DATA: default: return array_map(function ($item) { return $item['data']; }, $this->items); } } public function setInternalQueueClass($class) { $this->queueClass = (string) $class; return $this; } public function contains($datum) { foreach ($this->items as $item) { if ($item['data'] === $datum) { return true; } } return false; } public function hasPriority($priority) { foreach ($this->items as $item) { if ($item['priority'] === $priority) { return true; } } return false; } protected function getQueue() { if (null === $this->queue) { $this->queue = new $this->queueClass(); if (!$this->queue instanceof \SplPriorityQueue) { throw new Exception\DomainException(sprintf( 'PriorityQueue expects an internal queue of type SplPriorityQueue; received "%s"', get_class($this->queue) )); } } return $this->queue; } public function __clone() { if (null !== $this->queue) { $this->queue = clone $this->queue; } } } 
namespace Zend\Stdlib; use Closure; use ReflectionClass; class CallbackHandler { protected $callback; protected $metadata; protected static $isPhp54; public function __construct($callback, array $metadata = array()) { $this->metadata = $metadata; $this->registerCallback($callback); } protected function registerCallback($callback) { if (!is_callable($callback)) { throw new Exception\InvalidCallbackException('Invalid callback provided; not callable'); } $this->callback = $callback; } public function getCallback() { return $this->callback; } public function call(array $args = array()) { $callback = $this->getCallback(); if (!isset(static::$isPhp54)) { static::$isPhp54 = version_compare(PHP_VERSION, '5.4.0rc1', '>='); } $argCount = count($args); if (static::$isPhp54 && is_string($callback)) { $result = $this->validateStringCallbackFor54($callback); if ($result !== true && $argCount <= 3) { $callback = $result; $this->callback = $result; } } switch ($argCount) { case 0: if (static::$isPhp54) { return $callback(); } return call_user_func($callback); case 1: if (static::$isPhp54) { return $callback(array_shift($args)); } return call_user_func($callback, array_shift($args)); case 2: $arg1 = array_shift($args); $arg2 = array_shift($args); if (static::$isPhp54) { return $callback($arg1, $arg2); } return call_user_func($callback, $arg1, $arg2); case 3: $arg1 = array_shift($args); $arg2 = array_shift($args); $arg3 = array_shift($args); if (static::$isPhp54) { return $callback($arg1, $arg2, $arg3); } return call_user_func($callback, $arg1, $arg2, $arg3); default: return call_user_func_array($callback, $args); } } public function __invoke() { return $this->call(func_get_args()); } public function getMetadata() { return $this->metadata; } public function getMetadatum($name) { if (array_key_exists($name, $this->metadata)) { return $this->metadata[$name]; } return null; } protected function validateStringCallbackFor54($callback) { if (!strstr($callback, '::')) { return true; } list($class, $method) = explode('::', $callback, 2); if (!class_exists($class)) { throw new Exception\InvalidCallbackException(sprintf( 'Static method call "%s" refers to a class that does not exist', $callback )); } $r = new ReflectionClass($class); if (!$r->hasMethod($method)) { throw new Exception\InvalidCallbackException(sprintf( 'Static method call "%s" refers to a method that does not exist', $callback )); } $m = $r->getMethod($method); if (!$m->isStatic()) { throw new Exception\InvalidCallbackException(sprintf( 'Static method call "%s" refers to a method that is not static', $callback )); } return array($class, $method); } } 
namespace Zend\Stdlib; use Serializable; class SplPriorityQueue extends \SplPriorityQueue implements Serializable { protected $serial = PHP_INT_MAX; public function insert($datum, $priority) { if (!is_array($priority)) { $priority = array($priority, $this->serial--); } parent::insert($datum, $priority); } public function toArray() { $array = array(); foreach (clone $this as $item) { $array[] = $item; } return $array; } public function serialize() { $clone = clone $this; $clone->setExtractFlags(self::EXTR_BOTH); $data = array(); foreach ($clone as $item) { $data[] = $item; } return serialize($data); } public function unserialize($data) { foreach (unserialize($data) as $item) { $this->insert($item['data'], $item['priority']); } } } 
namespace Zend\ModuleManager\Listener; use Zend\ModuleManager\ModuleEvent; class ModuleResolverListener extends AbstractListener { public function __invoke(ModuleEvent $e) { $moduleName = $e->getModuleName(); $class = $moduleName . '\Module'; if (!class_exists($class)) { return false; } $module = new $class; return $module; } } 
namespace Zend\ModuleManager\Listener; use Zend\Loader\AutoloaderFactory; use Zend\ModuleManager\Feature\AutoloaderProviderInterface; use Zend\ModuleManager\ModuleEvent; class AutoloaderListener extends AbstractListener { public function __invoke(ModuleEvent $e) { $module = $e->getModule(); if (!$module instanceof AutoloaderProviderInterface && !method_exists($module, 'getAutoloaderConfig') ) { return; } $autoloaderConfig = $module->getAutoloaderConfig(); AutoloaderFactory::factory($autoloaderConfig); } } 
namespace Zend\ModuleManager\Listener; use Zend\ModuleManager\Exception; use Zend\ModuleManager\Feature\DependencyIndicatorInterface; use Zend\ModuleManager\ModuleEvent; class ModuleDependencyCheckerListener { protected $loaded = array(); public function __invoke(ModuleEvent $e) { $module = $e->getModule(); if ($module instanceof DependencyIndicatorInterface || method_exists($module, 'getModuleDependencies')) { $dependencies = $module->getModuleDependencies(); foreach ($dependencies as $dependencyModule) { if (!isset($this->loaded[$dependencyModule])) { throw new Exception\MissingDependencyModuleException( sprintf( 'Module "%s" depends on module "%s", which was not initialized before it', $e->getModuleName(), $dependencyModule ) ); } } } $this->loaded[$e->getModuleName()] = true; } } 
namespace Zend\ModuleManager\Listener; use Zend\ModuleManager\Feature\InitProviderInterface; use Zend\ModuleManager\ModuleEvent; class InitTrigger extends AbstractListener { public function __invoke(ModuleEvent $e) { $module = $e->getModule(); if (!$module instanceof InitProviderInterface && !method_exists($module, 'init') ) { return; } $module->init($e->getTarget()); } } 
namespace Zend\ModuleManager\Listener; use Zend\ModuleManager\Feature\BootstrapListenerInterface; use Zend\ModuleManager\ModuleEvent; use Zend\Mvc\MvcEvent; class OnBootstrapListener extends AbstractListener { public function __invoke(ModuleEvent $e) { $module = $e->getModule(); if (!$module instanceof BootstrapListenerInterface && !method_exists($module, 'onBootstrap') ) { return; } $moduleManager = $e->getTarget(); $events = $moduleManager->getEventManager(); $sharedEvents = $events->getSharedManager(); $sharedEvents->attach('Zend\Mvc\Application', MvcEvent::EVENT_BOOTSTRAP, array($module, 'onBootstrap')); } } 
namespace Zend\ModuleManager; use Zend\EventManager\EventManagerAwareInterface; interface ModuleManagerInterface extends EventManagerAwareInterface { public function loadModules(); public function loadModule($moduleName); public function getLoadedModules($loadModules); public function getModules(); public function setModules($modules); } 
namespace Zend\ModuleManager; use Traversable; use Zend\EventManager\EventManager; use Zend\EventManager\EventManagerInterface; class ModuleManager implements ModuleManagerInterface { protected $loadedModules = array(); protected $events; protected $event; protected $loadFinished; protected $modules = array(); protected $modulesAreLoaded = false; public function __construct($modules, EventManagerInterface $eventManager = null) { $this->setModules($modules); if ($eventManager instanceof EventManagerInterface) { $this->setEventManager($eventManager); } } public function onLoadModules() { if (true === $this->modulesAreLoaded) { return $this; } foreach ($this->getModules() as $moduleName => $module) { if (is_object($module)) { if (!is_string($moduleName)) { throw new Exception\RuntimeException(sprintf( 'Module (%s) must have a key identifier.', get_class($module) )); } $module = array($moduleName => $module); } $this->loadModule($module); } $this->modulesAreLoaded = true; } public function loadModules() { if (true === $this->modulesAreLoaded) { return $this; } $this->getEventManager()->trigger(ModuleEvent::EVENT_LOAD_MODULES, $this, $this->getEvent()); $this->getEventManager()->trigger(ModuleEvent::EVENT_LOAD_MODULES_POST, $this, $this->getEvent()); return $this; } public function loadModule($module) { $moduleName = $module; if (is_array($module)) { $moduleName = key($module); $module = current($module); } if (isset($this->loadedModules[$moduleName])) { return $this->loadedModules[$moduleName]; } $event = ($this->loadFinished === false) ? clone $this->getEvent() : $this->getEvent(); $event->setModuleName($moduleName); $this->loadFinished = false; if (!is_object($module)) { $module = $this->loadModuleByName($event); } $event->setModule($module); $this->loadedModules[$moduleName] = $module; $this->getEventManager()->trigger(ModuleEvent::EVENT_LOAD_MODULE, $this, $event); $this->loadFinished = true; return $module; } protected function loadModuleByName($event) { $result = $this->getEventManager()->trigger(ModuleEvent::EVENT_LOAD_MODULE_RESOLVE, $this, $event, function ($r) { return (is_object($r)); }); $module = $result->last(); if (!is_object($module)) { throw new Exception\RuntimeException(sprintf( 'Module (%s) could not be initialized.', $event->getModuleName() )); } return $module; } public function getLoadedModules($loadModules = false) { if (true === $loadModules) { $this->loadModules(); } return $this->loadedModules; } public function getModule($moduleName) { if (!isset($this->loadedModules[$moduleName])) { return null; } return $this->loadedModules[$moduleName]; } public function getModules() { return $this->modules; } public function setModules($modules) { if (is_array($modules) || $modules instanceof Traversable) { $this->modules = $modules; } else { throw new Exception\InvalidArgumentException(sprintf( 'Parameter to %s\'s %s method must be an array or implement the Traversable interface', __CLASS__, __METHOD__ )); } return $this; } public function getEvent() { if (!$this->event instanceof ModuleEvent) { $this->setEvent(new ModuleEvent); } return $this->event; } public function setEvent(ModuleEvent $event) { $this->event = $event; return $this; } public function setEventManager(EventManagerInterface $events) { $events->setIdentifiers(array( __CLASS__, get_class($this), 'module_manager', )); $this->events = $events; $this->attachDefaultListeners(); return $this; } public function getEventManager() { if (!$this->events instanceof EventManagerInterface) { $this->setEventManager(new EventManager()); } return $this->events; } protected function attachDefaultListeners() { $events = $this->getEventManager(); $events->attach(ModuleEvent::EVENT_LOAD_MODULES, array($this, 'onLoadModules')); } } 
namespace Zend\EventManager; use SplStack; class ResponseCollection extends SplStack { protected $stopped = false; public function stopped() { return $this->stopped; } public function setStopped($flag) { $this->stopped = (bool) $flag; return $this; } public function first() { return parent::bottom(); } public function last() { if (count($this) === 0) { return null; } return parent::top(); } public function contains($value) { foreach ($this as $response) { if ($response === $value) { return true; } } return false; } } 
namespace Zend\Mvc; use Zend\EventManager\Event; use Zend\Stdlib\RequestInterface as Request; use Zend\Stdlib\ResponseInterface as Response; use Zend\View\Model\ModelInterface as Model; use Zend\View\Model\ViewModel; class MvcEvent extends Event { const EVENT_BOOTSTRAP = 'bootstrap'; const EVENT_DISPATCH = 'dispatch'; const EVENT_DISPATCH_ERROR = 'dispatch.error'; const EVENT_FINISH = 'finish'; const EVENT_RENDER = 'render'; const EVENT_RENDER_ERROR = 'render.error'; const EVENT_ROUTE = 'route'; protected $application; protected $request; protected $response; protected $result; protected $router; protected $routeMatch; protected $viewModel; public function setApplication(ApplicationInterface $application) { $this->setParam('application', $application); $this->application = $application; return $this; } public function getApplication() { return $this->application; } public function getRouter() { return $this->router; } public function setRouter(Router\RouteStackInterface $router) { $this->setParam('router', $router); $this->router = $router; return $this; } public function getRouteMatch() { return $this->routeMatch; } public function setRouteMatch(Router\RouteMatch $matches) { $this->setParam('route-match', $matches); $this->routeMatch = $matches; return $this; } public function getRequest() { return $this->request; } public function setRequest(Request $request) { $this->setParam('request', $request); $this->request = $request; return $this; } public function getResponse() { return $this->response; } public function setResponse(Response $response) { $this->setParam('response', $response); $this->response = $response; return $this; } public function setViewModel(Model $viewModel) { $this->viewModel = $viewModel; return $this; } public function getViewModel() { if (null === $this->viewModel) { $this->setViewModel(new ViewModel()); } return $this->viewModel; } public function getResult() { return $this->result; } public function setResult($result) { $this->setParam('__RESULT__', $result); $this->result = $result; return $this; } public function isError() { return (bool) $this->getParam('error', false); } public function setError($message) { $this->setParam('error', $message); return $this; } public function getError() { return $this->getParam('error', ''); } public function getController() { return $this->getParam('controller'); } public function setController($name) { $this->setParam('controller', $name); return $this; } public function getControllerClass() { return $this->getParam('controller-class'); } public function setControllerClass($class) { $this->setParam('controller-class', $class); return $this; } } 
namespace Zend\Stdlib; use Zend\Stdlib\Exception; use Zend\Stdlib\ErrorHandler; abstract class Glob { const GLOB_MARK = 0x01; const GLOB_NOSORT = 0x02; const GLOB_NOCHECK = 0x04; const GLOB_NOESCAPE = 0x08; const GLOB_BRACE = 0x10; const GLOB_ONLYDIR = 0x20; const GLOB_ERR = 0x40; public static function glob($pattern, $flags = 0, $forceFallback = false) { if (!defined('GLOB_BRACE') || $forceFallback) { return static::fallbackGlob($pattern, $flags); } return static::systemGlob($pattern, $flags); } protected static function systemGlob($pattern, $flags) { if ($flags) { $flagMap = array( self::GLOB_MARK => GLOB_MARK, self::GLOB_NOSORT => GLOB_NOSORT, self::GLOB_NOCHECK => GLOB_NOCHECK, self::GLOB_NOESCAPE => GLOB_NOESCAPE, self::GLOB_BRACE => GLOB_BRACE, self::GLOB_ONLYDIR => GLOB_ONLYDIR, self::GLOB_ERR => GLOB_ERR, ); $globFlags = 0; foreach ($flagMap as $internalFlag => $globFlag) { if ($flags & $internalFlag) { $globFlags |= $globFlag; } } } else { $globFlags = 0; } ErrorHandler::start(); $res = glob($pattern, $globFlags); $err = ErrorHandler::stop(); if ($res === false) { throw new Exception\RuntimeException("glob('{$pattern}', {$globFlags}) failed", 0, $err); } return $res; } protected static function fallbackGlob($pattern, $flags) { if (!$flags & self::GLOB_BRACE) { return static::systemGlob($pattern, $flags); } $flags &= ~self::GLOB_BRACE; $length = strlen($pattern); $paths = array(); if ($flags & self::GLOB_NOESCAPE) { $begin = strpos($pattern, '{'); } else { $begin = 0; while (true) { if ($begin === $length) { $begin = false; break; } elseif ($pattern[$begin] === '\\' && ($begin + 1) < $length) { $begin++; } elseif ($pattern[$begin] === '{') { break; } $begin++; } } if ($begin === false) { return static::systemGlob($pattern, $flags); } $next = static::nextBraceSub($pattern, $begin + 1, $flags); if ($next === null) { return static::systemGlob($pattern, $flags); } $rest = $next; while ($pattern[$rest] !== '}') { $rest = static::nextBraceSub($pattern, $rest + 1, $flags); if ($rest === null) { return static::systemGlob($pattern, $flags); } } $p = $begin + 1; while (true) { $subPattern = substr($pattern, 0, $begin) . substr($pattern, $p, $next - $p) . substr($pattern, $rest + 1); $result = static::fallbackGlob($subPattern, $flags | self::GLOB_BRACE); if ($result) { $paths = array_merge($paths, $result); } if ($pattern[$next] === '}') { break; } $p = $next + 1; $next = static::nextBraceSub($pattern, $p, $flags); } return array_unique($paths); } protected static function nextBraceSub($pattern, $begin, $flags) { $length = strlen($pattern); $depth = 0; $current = $begin; while ($current < $length) { if (!$flags & self::GLOB_NOESCAPE && $pattern[$current] === '\\') { if (++$current === $length) { break; } $current++; } else { if (($pattern[$current] === '}' && $depth-- === 0) || ($pattern[$current] === ',' && $depth === 0)) { break; } elseif ($pattern[$current++] === '{') { $depth++; } } } return ($current < $length ? $current : null); } } 
namespace Zend\Stdlib; use ErrorException; abstract class ErrorHandler { protected static $stack = array(); public static function started() { return (bool) static::getNestedLevel(); } public static function getNestedLevel() { return count(static::$stack); } public static function start($errorLevel = \E_WARNING) { if (!static::$stack) { set_error_handler(array(get_called_class(), 'addError'), $errorLevel); } static::$stack[] = null; } public static function stop($throw = false) { $errorException = null; if (static::$stack) { $errorException = array_pop(static::$stack); if (!static::$stack) { restore_error_handler(); } if ($errorException && $throw) { throw $errorException; } } return $errorException; } public static function clean() { if (static::$stack) { restore_error_handler(); } static::$stack = array(); } public static function addError($errno, $errstr = '', $errfile = '', $errline = 0) { $stack = & static::$stack[count(static::$stack) - 1]; $stack = new ErrorException($errstr, 0, $errno, $errfile, $errline, $stack); } } 
namespace Zend\Config; use Zend\Stdlib\ArrayUtils; class Factory { public static $readers = null; public static $writers = null; protected static $extensions = array( 'ini' => 'ini', 'json' => 'json', 'xml' => 'xml', 'yaml' => 'yaml', ); protected static $writerExtensions = array( 'php' => 'php', 'ini' => 'ini', 'json' => 'json', 'xml' => 'xml', 'yaml' => 'yaml', ); public static function fromFile($filename, $returnConfigObject = false) { $pathinfo = pathinfo($filename); if (!isset($pathinfo['extension'])) { throw new Exception\RuntimeException(sprintf( 'Filename "%s" is missing an extension and cannot be auto-detected', $filename )); } $extension = strtolower($pathinfo['extension']); if ($extension === 'php') { if (!is_file($filename) || !is_readable($filename)) { throw new Exception\RuntimeException(sprintf( "File '%s' doesn't exist or not readable", $filename )); } $config = include $filename; } elseif (isset(static::$extensions[$extension])) { $reader = static::$extensions[$extension]; if (!$reader instanceof Reader\ReaderInterface) { $reader = static::getReaderPluginManager()->get($reader); static::$extensions[$extension] = $reader; } $config = $reader->fromFile($filename); } else { throw new Exception\RuntimeException(sprintf( 'Unsupported config file extension: .%s', $pathinfo['extension'] )); } return ($returnConfigObject) ? new Config($config) : $config; } public static function fromFiles(array $files, $returnConfigObject = false) { $config = array(); foreach ($files as $file) { $config = ArrayUtils::merge($config, static::fromFile($file)); } return ($returnConfigObject) ? new Config($config) : $config; } public static function toFile($filename, $config) { if ( (is_object($config) && !($config instanceOf Config)) || (!is_object($config) && !is_array($config)) ) { throw new Exception\InvalidArgumentException( __METHOD__." \$config should be an array or instance of Zend\\Config\\Config" ); } $extension = substr(strrchr($filename, '.'), 1); $directory = dirname($filename); if (!is_dir($directory)) { throw new Exception\RuntimeException( "Directory '{$directory}' does not exists!" ); } if (!is_writable($directory)) { throw new Exception\RuntimeException( "Cannot write in directory '{$directory}'" ); } if (!isset(static::$writerExtensions[$extension])) { throw new Exception\RuntimeException( "Unsupported config file extension: '.{$extension}' for writing." ); } $writer = static::$writerExtensions[$extension]; if (($writer instanceOf Writer\AbstractWriter) === false) { $writer = self::getWriterPluginManager()->get($writer); static::$writerExtensions[$extension] = $writer; } if (is_object($config)) { $config = $config->toArray(); } $content = $writer->processConfig($config); return (bool) (file_put_contents($filename, $content) !== false); } public static function setReaderPluginManager(ReaderPluginManager $readers) { static::$readers = $readers; } public static function getReaderPluginManager() { if (static::$readers === null) { static::$readers = new ReaderPluginManager(); } return static::$readers; } public static function setWriterPluginManager(WriterPluginManager $writers) { static::$writers = $writers; } public static function getWriterPluginManager() { if (static::$writers === null) { static::$writers = new WriterPluginManager(); } return static::$writers; } public static function registerReader($extension, $reader) { $extension = strtolower($extension); if (!is_string($reader) && !$reader instanceof Reader\ReaderInterface) { throw new Exception\InvalidArgumentException(sprintf( 'Reader should be plugin name, class name or ' . 'instance of %s\Reader\ReaderInterface; received "%s"', __NAMESPACE__, (is_object($reader) ? get_class($reader) : gettype($reader)) )); } static::$extensions[$extension] = $reader; } public static function registerWriter($extension, $writer) { $extension = strtolower($extension); if (!is_string($writer) && !$writer instanceof Writer\AbstractWriter) { throw new Exception\InvalidArgumentException(sprintf( 'Writer should be plugin name, class name or ' . 'instance of %s\Writer\AbstractWriter; received "%s"', __NAMESPACE__, (is_object($writer) ? get_class($writer) : gettype($writer)) )); } static::$writerExtensions[$extension] = $writer; } } 
namespace Zend\Stdlib; use Traversable; abstract class ArrayUtils { public static function hasStringKeys($value, $allowEmpty = false) { if (!is_array($value)) { return false; } if (!$value) { return $allowEmpty; } return count(array_filter(array_keys($value), 'is_string')) > 0; } public static function hasIntegerKeys($value, $allowEmpty = false) { if (!is_array($value)) { return false; } if (!$value) { return $allowEmpty; } return count(array_filter(array_keys($value), 'is_int')) > 0; } public static function hasNumericKeys($value, $allowEmpty = false) { if (!is_array($value)) { return false; } if (!$value) { return $allowEmpty; } return count(array_filter(array_keys($value), 'is_numeric')) > 0; } public static function isList($value, $allowEmpty = false) { if (!is_array($value)) { return false; } if (!$value) { return $allowEmpty; } return (array_values($value) === $value); } public static function isHashTable($value, $allowEmpty = false) { if (!is_array($value)) { return false; } if (!$value) { return $allowEmpty; } return (array_values($value) !== $value); } public static function inArray($needle, array $haystack, $strict = false) { if (!$strict) { if (is_int($needle) || is_float($needle)) { $needle = (string) $needle; } if (is_string($needle)) { foreach ($haystack as &$h) { if (is_int($h) || is_float($h)) { $h = (string) $h; } } } } return in_array($needle, $haystack, $strict); } public static function iteratorToArray($iterator, $recursive = true) { if (!is_array($iterator) && !$iterator instanceof Traversable) { throw new Exception\InvalidArgumentException(__METHOD__ . ' expects an array or Traversable object'); } if (!$recursive) { if (is_array($iterator)) { return $iterator; } return iterator_to_array($iterator); } if (method_exists($iterator, 'toArray')) { return $iterator->toArray(); } $array = array(); foreach ($iterator as $key => $value) { if (is_scalar($value)) { $array[$key] = $value; continue; } if ($value instanceof Traversable) { $array[$key] = static::iteratorToArray($value, $recursive); continue; } if (is_array($value)) { $array[$key] = static::iteratorToArray($value, $recursive); continue; } $array[$key] = $value; } return $array; } public static function merge(array $a, array $b) { foreach ($b as $key => $value) { if (array_key_exists($key, $a)) { if (is_int($key)) { $a[] = $value; } elseif (is_array($value) && is_array($a[$key])) { $a[$key] = static::merge($a[$key], $value); } else { $a[$key] = $value; } } else { $a[$key] = $value; } } return $a; } } 
namespace Zend\ServiceManager; class Config implements ConfigInterface { protected $config = array(); public function __construct($config = array()) { $this->config = $config; } public function getAllowOverride() { return (isset($this->config['allow_override'])) ? $this->config['allow_override'] : null; } public function getFactories() { return (isset($this->config['factories'])) ? $this->config['factories'] : array(); } public function getAbstractFactories() { return (isset($this->config['abstract_factories'])) ? $this->config['abstract_factories'] : array(); } public function getInvokables() { return (isset($this->config['invokables'])) ? $this->config['invokables'] : array(); } public function getServices() { return (isset($this->config['services'])) ? $this->config['services'] : array(); } public function getAliases() { return (isset($this->config['aliases'])) ? $this->config['aliases'] : array(); } public function getInitializers() { return (isset($this->config['initializers'])) ? $this->config['initializers'] : array(); } public function getShared() { return (isset($this->config['shared'])) ? $this->config['shared'] : array(); } public function getDelegators() { return (isset($this->config['delegators'])) ? $this->config['delegators'] : array(); } public function configureServiceManager(ServiceManager $serviceManager) { if (($allowOverride = $this->getAllowOverride()) !== null) { $serviceManager->setAllowOverride($allowOverride); } foreach ($this->getFactories() as $name => $factory) { $serviceManager->setFactory($name, $factory); } foreach ($this->getAbstractFactories() as $factory) { $serviceManager->addAbstractFactory($factory); } foreach ($this->getInvokables() as $name => $invokable) { $serviceManager->setInvokableClass($name, $invokable); } foreach ($this->getServices() as $name => $service) { $serviceManager->setService($name, $service); } foreach ($this->getAliases() as $alias => $nameOrAlias) { $serviceManager->setAlias($alias, $nameOrAlias); } foreach ($this->getInitializers() as $initializer) { $serviceManager->addInitializer($initializer); } foreach ($this->getShared() as $name => $isShared) { $serviceManager->setShared($name, $isShared); } foreach ($this->getDelegators() as $originalServiceName => $delegators) { foreach ($delegators as $delegator) { $serviceManager->addDelegator($originalServiceName, $delegator); } } } } 
namespace Zend\ServiceManager; interface AbstractFactoryInterface { public function canCreateServiceWithName(ServiceLocatorInterface $serviceLocator, $name, $requestedName); public function createServiceWithName(ServiceLocatorInterface $serviceLocator, $name, $requestedName); } 
namespace Zend\Form; use Zend\InputFilter\InputFilterInterface; use Zend\ServiceManager\AbstractFactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class FormAbstractServiceFactory implements AbstractFactoryInterface { protected $config; protected $configKey = 'forms'; protected $factory; public function canCreateServiceWithName(ServiceLocatorInterface $services, $name, $rName) { $config = $this->getConfig($services); if (empty($config)) { return false; } return (isset($config[$rName]) && is_array($config[$rName]) && !empty($config[$rName])); } public function createServiceWithName(ServiceLocatorInterface $services, $name, $rName) { $config = $this->getConfig($services); $config = $config[$rName]; $factory = $this->getFormFactory($services); $this->marshalInputFilter($config, $services, $factory); return $factory->createForm($config); } protected function getConfig(ServiceLocatorInterface $services) { if ($this->config !== null) { return $this->config; } if (!$services->has('Config')) { $this->config = array(); return $this->config; } $config = $services->get('Config'); if (!isset($config[$this->configKey]) || !is_array($config[$this->configKey]) ) { $this->config = array(); return $this->config; } $this->config = $config[$this->configKey]; return $this->config; } protected function getFormFactory(ServiceLocatorInterface $services) { if ($this->factory instanceof Factory) { return $this->factory; } $elements = null; if ($services->has('FormElementManager')) { $elements = $services->get('FormElementManager'); } $this->factory = new Factory($elements); return $this->factory; } protected function marshalInputFilter(array &$config, ServiceLocatorInterface $services, Factory $formFactory) { if (!isset($config['input_filter'])) { return; } if ($config['input_filter'] instanceof InputFilterInterface) { return; } if (is_string($config['input_filter']) && $services->has('InputFilterManager') ) { $inputFilters = $services->get('InputFilterManager'); if ($inputFilters->has($config['input_filter'])) { $config['input_filter'] = $inputFilters->get($config['input_filter']); return; } } $inputFilterFactory = $formFactory->getInputFilterFactory(); $inputFilterFactory->getDefaultFilterChain()->setPluginManager($services->get('FilterManager')); $inputFilterFactory->getDefaultValidatorChain()->setPluginManager($services->get('ValidatorManager')); } } 
namespace Zend\Cache\Service; use Zend\Cache\StorageFactory; use Zend\ServiceManager\AbstractFactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class StorageCacheAbstractServiceFactory implements AbstractFactoryInterface { protected $config; protected $configKey = 'caches'; public function canCreateServiceWithName(ServiceLocatorInterface $services, $name, $requestedName) { $config = $this->getConfig($services); if (empty($config)) { return false; } return (isset($config[$requestedName]) && is_array($config[$requestedName])); } public function createServiceWithName(ServiceLocatorInterface $services, $name, $requestedName) { $config = $this->getConfig($services); $config = $config[$requestedName]; return StorageFactory::factory($config); } protected function getConfig(ServiceLocatorInterface $services) { if ($this->config !== null) { return $this->config; } if (!$services->has('Config')) { $this->config = array(); return $this->config; } $config = $services->get('Config'); if (!isset($config[$this->configKey])) { $this->config = array(); return $this->config; } $this->config = $config[$this->configKey]; return $this->config; } } 
namespace Zend\Log; use Zend\ServiceManager\AbstractFactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class LoggerAbstractServiceFactory implements AbstractFactoryInterface { protected $config; protected $configKey = 'log'; public function canCreateServiceWithName(ServiceLocatorInterface $services, $name, $requestedName) { $config = $this->getConfig($services); if (empty($config)) { return false; } return isset($config[$requestedName]); } public function createServiceWithName(ServiceLocatorInterface $services, $name, $requestedName) { $config = $this->getConfig($services); $config = $config[$requestedName]; $this->processConfig($config, $services); return new Logger($config); } protected function getConfig(ServiceLocatorInterface $services) { if ($this->config !== null) { return $this->config; } if (!$services->has('Config')) { $this->config = array(); return $this->config; } $config = $services->get('Config'); if (!isset($config[$this->configKey])) { $this->config = array(); return $this->config; } $this->config = $config[$this->configKey]; return $this->config; } protected function processConfig(&$config, ServiceLocatorInterface $services) { if (!isset($config['writers'])) { return; } foreach ($config['writers'] as $index => $writerConfig) { if (!isset($writerConfig['name']) || strtolower($writerConfig['name']) != 'db' ) { continue; } if (!isset($writerConfig['options']) || !isset($writerConfig['options']['db']) ) { continue; } if (!is_string($writerConfig['options']['db'])) { continue; } if (!$services->has($writerConfig['options']['db'])) { continue; } $db = $services->get($writerConfig['options']['db']); $config['writers'][$index]['options']['db'] = $db; } } } 
namespace Zend\Mvc\Service; use Zend\Mvc\Controller\ControllerManager; use Zend\Mvc\Service\DiStrictAbstractServiceFactory; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class ControllerLoaderFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { $controllerLoader = new ControllerManager(); $controllerLoader->setServiceLocator($serviceLocator); $controllerLoader->addPeeringServiceManager($serviceLocator); $config = $serviceLocator->get('Config'); if (isset($config['di']) && isset($config['di']['allowed_controllers']) && $serviceLocator->has('Di')) { $controllerLoader->addAbstractFactory($serviceLocator->get('DiStrictAbstractServiceFactory')); } return $controllerLoader; } } 
namespace Zend\ServiceManager; interface ServiceLocatorAwareInterface { public function setServiceLocator(ServiceLocatorInterface $serviceLocator); public function getServiceLocator(); } 
namespace Zend\ServiceManager; abstract class AbstractPluginManager extends ServiceManager implements ServiceLocatorAwareInterface { protected $allowOverride = true; protected $autoAddInvokableClass = true; protected $creationOptions = null; protected $serviceLocator; public function __construct(ConfigInterface $configuration = null) { parent::__construct($configuration); $self = $this; $this->addInitializer(function ($instance) use ($self) { if ($instance instanceof ServiceLocatorAwareInterface) { $instance->setServiceLocator($self); } }); } abstract public function validatePlugin($plugin); public function get($name, $options = array(), $usePeeringServiceManagers = true) { if (!$this->has($name) && $this->autoAddInvokableClass && class_exists($name)) { $this->setInvokableClass($name, $name); } $this->creationOptions = $options; $instance = parent::get($name, $usePeeringServiceManagers); $this->creationOptions = null; $this->validatePlugin($instance); return $instance; } public function setService($name, $service, $shared = true) { if ($service) { $this->validatePlugin($service); } parent::setService($name, $service, $shared); return $this; } public function setServiceLocator(ServiceLocatorInterface $serviceLocator) { $this->serviceLocator = $serviceLocator; return $this; } public function getServiceLocator() { return $this->serviceLocator; } protected function createFromInvokable($canonicalName, $requestedName) { $invokable = $this->invokableClasses[$canonicalName]; if (null === $this->creationOptions || (is_array($this->creationOptions) && empty($this->creationOptions)) ) { $instance = new $invokable(); } else { $instance = new $invokable($this->creationOptions); } return $instance; } protected function createFromFactory($canonicalName, $requestedName) { $factory = $this->factories[$canonicalName]; $hasCreationOptions = !(null === $this->creationOptions || (is_array($this->creationOptions) && empty($this->creationOptions))); if (is_string($factory) && class_exists($factory, true)) { if (!$hasCreationOptions) { $factory = new $factory(); } else { $factory = new $factory($this->creationOptions); } $this->factories[$canonicalName] = $factory; } if ($factory instanceof FactoryInterface) { $instance = $this->createServiceViaCallback(array($factory, 'createService'), $canonicalName, $requestedName); } elseif (is_callable($factory)) { $instance = $this->createServiceViaCallback($factory, $canonicalName, $requestedName); } else { throw new Exception\ServiceNotCreatedException(sprintf( 'While attempting to create %s%s an invalid factory was registered for this instance type.', $canonicalName, ($requestedName ? '(alias: ' . $requestedName . ')' : '') )); } return $instance; } protected function createServiceViaCallback($callable, $cName, $rName) { if (is_object($callable)) { $factory = $callable; } elseif (is_array($callable)) { $factory = reset($callable); } if (isset($factory) && ($factory instanceof MutableCreationOptionsInterface) && is_array($this->creationOptions) && !empty($this->creationOptions) ) { $factory->setCreationOptions($this->creationOptions); } return parent::createServiceViaCallback($callable, $cName, $rName); } } 
namespace Zend\Mvc\Controller; use Zend\EventManager\EventManagerAwareInterface; use Zend\EventManager\EventManagerInterface; use Zend\Mvc\Exception; use Zend\ServiceManager\AbstractPluginManager; use Zend\ServiceManager\ConfigInterface; use Zend\ServiceManager\ServiceLocatorAwareInterface; use Zend\ServiceManager\ServiceLocatorInterface; use Zend\Stdlib\DispatchableInterface; class ControllerManager extends AbstractPluginManager { protected $autoAddInvokableClass = false; public function __construct(ConfigInterface $configuration = null) { parent::__construct($configuration); $this->addInitializer(array($this, 'injectControllerDependencies'), false); } public function injectControllerDependencies($controller, ServiceLocatorInterface $serviceLocator) { if (!$controller instanceof DispatchableInterface) { return; } $parentLocator = $serviceLocator->getServiceLocator(); if ($controller instanceof ServiceLocatorAwareInterface) { $controller->setServiceLocator($parentLocator->get('Zend\ServiceManager\ServiceLocatorInterface')); } if ($controller instanceof EventManagerAwareInterface) { $events = $controller->getEventManager(); if (!$events instanceof EventManagerInterface) { $controller->setEventManager($parentLocator->get('EventManager')); } else { $events->setSharedManager($parentLocator->get('SharedEventManager')); } } if (method_exists($controller, 'setPluginManager')) { $controller->setPluginManager($parentLocator->get('ControllerPluginManager')); } } public function validatePlugin($plugin) { if ($plugin instanceof DispatchableInterface) { return; } throw new Exception\InvalidControllerException(sprintf( 'Controller of type %s is invalid; must implement Zend\Stdlib\DispatchableInterface', (is_object($plugin) ? get_class($plugin) : gettype($plugin)) )); } public function has($name, $checkAbstractFactories = true, $usePeeringServiceManagers = false) { return parent::has($name, $checkAbstractFactories, $usePeeringServiceManagers); } public function get($name, $options = array(), $usePeeringServiceManagers = false) { return parent::get($name, $options, $usePeeringServiceManagers); } } 
namespace Zend\Mvc\Service; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class ConfigFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { $mm = $serviceLocator->get('ModuleManager'); $mm->loadModules(); $moduleParams = $mm->getEvent()->getParams(); $config = $moduleParams['configListener']->getMergedConfig(false); return $config; } } 
namespace Zend\Mvc\Service; use Zend\ServiceManager\AbstractPluginManager; use Zend\ServiceManager\Di\DiAbstractServiceFactory; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; abstract class AbstractPluginManagerFactory implements FactoryInterface { const PLUGIN_MANAGER_CLASS = 'AbstractPluginManager'; public function createService(ServiceLocatorInterface $serviceLocator) { $pluginManagerClass = static::PLUGIN_MANAGER_CLASS; $plugins = new $pluginManagerClass; $plugins->setServiceLocator($serviceLocator); $configuration = $serviceLocator->get('Config'); if (isset($configuration['di']) && $serviceLocator->has('Di')) { $plugins->addAbstractFactory($serviceLocator->get('DiAbstractServiceFactory')); } return $plugins; } } 
namespace Zend\Mvc\Service; use Zend\Mvc\Controller\PluginManager; use Zend\ServiceManager\ServiceLocatorInterface; class ControllerPluginManagerFactory extends AbstractPluginManagerFactory { const PLUGIN_MANAGER_CLASS = 'Zend\Mvc\Controller\PluginManager'; public function createService(ServiceLocatorInterface $serviceLocator) { $plugins = parent::createService($serviceLocator); return $plugins; } } 
namespace Zend\Mvc\Controller; use Zend\Mvc\Exception; use Zend\ServiceManager\AbstractPluginManager; use Zend\Stdlib\DispatchableInterface; class PluginManager extends AbstractPluginManager { protected $factories = array( 'forward' => 'Zend\Mvc\Controller\Plugin\Service\ForwardFactory', 'identity' => 'Zend\Mvc\Controller\Plugin\Service\IdentityFactory', ); protected $invokableClasses = array( 'acceptableviewmodelselector' => 'Zend\Mvc\Controller\Plugin\AcceptableViewModelSelector', 'filepostredirectget' => 'Zend\Mvc\Controller\Plugin\FilePostRedirectGet', 'flashmessenger' => 'Zend\Mvc\Controller\Plugin\FlashMessenger', 'layout' => 'Zend\Mvc\Controller\Plugin\Layout', 'params' => 'Zend\Mvc\Controller\Plugin\Params', 'postredirectget' => 'Zend\Mvc\Controller\Plugin\PostRedirectGet', 'redirect' => 'Zend\Mvc\Controller\Plugin\Redirect', 'url' => 'Zend\Mvc\Controller\Plugin\Url', ); protected $aliases = array( 'prg' => 'postredirectget', 'fileprg' => 'filepostredirectget', ); protected $controller; public function get($name, $options = array(), $usePeeringServiceManagers = true) { $plugin = parent::get($name, $options, $usePeeringServiceManagers); $this->injectController($plugin); return $plugin; } public function setController(DispatchableInterface $controller) { $this->controller = $controller; return $this; } public function getController() { return $this->controller; } public function injectController($plugin) { if (!is_object($plugin)) { return; } if (!method_exists($plugin, 'setController')) { return; } $controller = $this->getController(); if (!$controller instanceof DispatchableInterface) { return; } $plugin->setController($controller); } public function validatePlugin($plugin) { if ($plugin instanceof Plugin\PluginInterface) { return; } throw new Exception\InvalidPluginException(sprintf( 'Plugin of type %s is invalid; must implement %s\Plugin\PluginInterface', (is_object($plugin) ? get_class($plugin) : gettype($plugin)), __NAMESPACE__ )); } } 
namespace Zend\Mvc\Service; use Zend\Console\Console; use Zend\Mvc\Exception; use Zend\Mvc\Router\RouteMatch; use Zend\ServiceManager\ConfigInterface; use Zend\ServiceManager\ServiceLocatorInterface; use Zend\View\Helper as ViewHelper; use Zend\View\Helper\HelperInterface as ViewHelperInterface; class ViewHelperManagerFactory extends AbstractPluginManagerFactory { const PLUGIN_MANAGER_CLASS = 'Zend\View\HelperPluginManager'; protected $defaultHelperMapClasses = array( 'Zend\Form\View\HelperConfig', 'Zend\I18n\View\HelperConfig', 'Zend\Navigation\View\HelperConfig' ); public function createService(ServiceLocatorInterface $serviceLocator) { $plugins = parent::createService($serviceLocator); foreach ($this->defaultHelperMapClasses as $configClass) { if (is_string($configClass) && class_exists($configClass)) { $config = new $configClass; if (!$config instanceof ConfigInterface) { throw new Exception\RuntimeException(sprintf( 'Invalid service manager configuration class provided; received "%s", expected class implementing %s', $configClass, 'Zend\ServiceManager\ConfigInterface' )); } $config->configureServiceManager($plugins); } } $plugins->setFactory('url', function ($sm) use ($serviceLocator) { $helper = new ViewHelper\Url; $router = Console::isConsole() ? 'HttpRouter' : 'Router'; $helper->setRouter($serviceLocator->get($router)); $match = $serviceLocator->get('application') ->getMvcEvent() ->getRouteMatch() ; if ($match instanceof RouteMatch) { $helper->setRouteMatch($match); } return $helper; }); $plugins->setFactory('basepath', function ($sm) use ($serviceLocator) { $config = $serviceLocator->has('Config') ? $serviceLocator->get('Config') : array(); $basePathHelper = new ViewHelper\BasePath; if (isset($config['view_manager']) && isset($config['view_manager']['base_path'])) { $basePathHelper->setBasePath($config['view_manager']['base_path']); } else { $request = $serviceLocator->get('Request'); if (is_callable(array($request, 'getBasePath'))) { $basePathHelper->setBasePath($request->getBasePath()); } } return $basePathHelper; }); $plugins->setFactory('doctype', function ($sm) use ($serviceLocator) { $config = $serviceLocator->has('Config') ? $serviceLocator->get('Config') : array(); $config = isset($config['view_manager']) ? $config['view_manager'] : array(); $doctypeHelper = new ViewHelper\Doctype; if (isset($config['doctype']) && $config['doctype']) { $doctypeHelper->setDoctype($config['doctype']); } return $doctypeHelper; }); return $plugins; } } 
namespace Zend\View; use Zend\I18n\Translator\TranslatorAwareInterface; use Zend\ServiceManager\AbstractPluginManager; use Zend\ServiceManager\ConfigInterface; class HelperPluginManager extends AbstractPluginManager { protected $factories = array( 'flashmessenger' => 'Zend\View\Helper\Service\FlashMessengerFactory', 'identity' => 'Zend\View\Helper\Service\IdentityFactory', ); protected $invokableClasses = array( 'basepath' => 'Zend\View\Helper\BasePath', 'cycle' => 'Zend\View\Helper\Cycle', 'declarevars' => 'Zend\View\Helper\DeclareVars', 'doctype' => 'Zend\View\Helper\Doctype', 'escapehtml' => 'Zend\View\Helper\EscapeHtml', 'escapehtmlattr' => 'Zend\View\Helper\EscapeHtmlAttr', 'escapejs' => 'Zend\View\Helper\EscapeJs', 'escapecss' => 'Zend\View\Helper\EscapeCss', 'escapeurl' => 'Zend\View\Helper\EscapeUrl', 'gravatar' => 'Zend\View\Helper\Gravatar', 'headlink' => 'Zend\View\Helper\HeadLink', 'headmeta' => 'Zend\View\Helper\HeadMeta', 'headscript' => 'Zend\View\Helper\HeadScript', 'headstyle' => 'Zend\View\Helper\HeadStyle', 'headtitle' => 'Zend\View\Helper\HeadTitle', 'htmlflash' => 'Zend\View\Helper\HtmlFlash', 'htmllist' => 'Zend\View\Helper\HtmlList', 'htmlobject' => 'Zend\View\Helper\HtmlObject', 'htmlpage' => 'Zend\View\Helper\HtmlPage', 'htmlquicktime' => 'Zend\View\Helper\HtmlQuicktime', 'inlinescript' => 'Zend\View\Helper\InlineScript', 'json' => 'Zend\View\Helper\Json', 'layout' => 'Zend\View\Helper\Layout', 'paginationcontrol' => 'Zend\View\Helper\PaginationControl', 'partialloop' => 'Zend\View\Helper\PartialLoop', 'partial' => 'Zend\View\Helper\Partial', 'placeholder' => 'Zend\View\Helper\Placeholder', 'renderchildmodel' => 'Zend\View\Helper\RenderChildModel', 'rendertoplaceholder' => 'Zend\View\Helper\RenderToPlaceholder', 'serverurl' => 'Zend\View\Helper\ServerUrl', 'url' => 'Zend\View\Helper\Url', 'viewmodel' => 'Zend\View\Helper\ViewModel', ); protected $renderer; public function __construct(ConfigInterface $configuration = null) { parent::__construct($configuration); $this->addInitializer(array($this, 'injectRenderer')) ->addInitializer(array($this, 'injectTranslator')); } public function setRenderer(Renderer\RendererInterface $renderer) { $this->renderer = $renderer; return $this; } public function getRenderer() { return $this->renderer; } public function injectRenderer($helper) { $renderer = $this->getRenderer(); if (null === $renderer) { return; } $helper->setView($renderer); } public function injectTranslator($helper) { if ($helper instanceof TranslatorAwareInterface) { $locator = $this->getServiceLocator(); if ($locator && $locator->has('MvcTranslator')) { $helper->setTranslator($locator->get('MvcTranslator')); } elseif ($locator && $locator->has('translator')) { $helper->setTranslator($locator->get('translator')); } } } public function validatePlugin($plugin) { if ($plugin instanceof Helper\HelperInterface) { return; } throw new Exception\InvalidHelperException(sprintf( 'Plugin of type %s is invalid; must implement %s\Helper\HelperInterface', (is_object($plugin) ? get_class($plugin) : gettype($plugin)), __NAMESPACE__ )); } } 
namespace Zend\Form\View; use Zend\ServiceManager\ConfigInterface; use Zend\ServiceManager\ServiceManager; class HelperConfig implements ConfigInterface { protected $invokables = array( 'form' => 'Zend\Form\View\Helper\Form', 'formbutton' => 'Zend\Form\View\Helper\FormButton', 'formcaptcha' => 'Zend\Form\View\Helper\FormCaptcha', 'captchadumb' => 'Zend\Form\View\Helper\Captcha\Dumb', 'formcaptchadumb' => 'Zend\Form\View\Helper\Captcha\Dumb', 'captchafiglet' => 'Zend\Form\View\Helper\Captcha\Figlet', 'formcaptchafiglet' => 'Zend\Form\View\Helper\Captcha\Figlet', 'captchaimage' => 'Zend\Form\View\Helper\Captcha\Image', 'formcaptchaimage' => 'Zend\Form\View\Helper\Captcha\Image', 'captcharecaptcha' => 'Zend\Form\View\Helper\Captcha\ReCaptcha', 'formcaptcharecaptcha' => 'Zend\Form\View\Helper\Captcha\ReCaptcha', 'formcheckbox' => 'Zend\Form\View\Helper\FormCheckbox', 'formcollection' => 'Zend\Form\View\Helper\FormCollection', 'formcolor' => 'Zend\Form\View\Helper\FormColor', 'formdate' => 'Zend\Form\View\Helper\FormDate', 'formdatetime' => 'Zend\Form\View\Helper\FormDateTime', 'formdatetimelocal' => 'Zend\Form\View\Helper\FormDateTimeLocal', 'formdatetimeselect' => 'Zend\Form\View\Helper\FormDateTimeSelect', 'formdateselect' => 'Zend\Form\View\Helper\FormDateSelect', 'formelement' => 'Zend\Form\View\Helper\FormElement', 'formelementerrors' => 'Zend\Form\View\Helper\FormElementErrors', 'formemail' => 'Zend\Form\View\Helper\FormEmail', 'formfile' => 'Zend\Form\View\Helper\FormFile', 'formfileapcprogress' => 'Zend\Form\View\Helper\File\FormFileApcProgress', 'formfilesessionprogress' => 'Zend\Form\View\Helper\File\FormFileSessionProgress', 'formfileuploadprogress' => 'Zend\Form\View\Helper\File\FormFileUploadProgress', 'formhidden' => 'Zend\Form\View\Helper\FormHidden', 'formimage' => 'Zend\Form\View\Helper\FormImage', 'forminput' => 'Zend\Form\View\Helper\FormInput', 'formlabel' => 'Zend\Form\View\Helper\FormLabel', 'formmonth' => 'Zend\Form\View\Helper\FormMonth', 'formmonthselect' => 'Zend\Form\View\Helper\FormMonthSelect', 'formmulticheckbox' => 'Zend\Form\View\Helper\FormMultiCheckbox', 'formnumber' => 'Zend\Form\View\Helper\FormNumber', 'formpassword' => 'Zend\Form\View\Helper\FormPassword', 'formradio' => 'Zend\Form\View\Helper\FormRadio', 'formrange' => 'Zend\Form\View\Helper\FormRange', 'formreset' => 'Zend\Form\View\Helper\FormReset', 'form_reset' => 'Zend\Form\View\Helper\FormReset', 'formrow' => 'Zend\Form\View\Helper\FormRow', 'form_row' => 'Zend\Form\View\Helper\FormRow', 'formsearch' => 'Zend\Form\View\Helper\FormSearch', 'formselect' => 'Zend\Form\View\Helper\FormSelect', 'formsubmit' => 'Zend\Form\View\Helper\FormSubmit', 'formtel' => 'Zend\Form\View\Helper\FormTel', 'formtext' => 'Zend\Form\View\Helper\FormText', 'formtextarea' => 'Zend\Form\View\Helper\FormTextarea', 'formtime' => 'Zend\Form\View\Helper\FormTime', 'formurl' => 'Zend\Form\View\Helper\FormUrl', 'formweek' => 'Zend\Form\View\Helper\FormWeek', ); public function configureServiceManager(ServiceManager $serviceManager) { foreach ($this->invokables as $name => $service) { $serviceManager->setInvokableClass($name, $service); } } } 
namespace Zend\I18n\View; use Zend\ServiceManager\ConfigInterface; use Zend\ServiceManager\ServiceManager; class HelperConfig implements ConfigInterface { protected $invokables = array( 'currencyformat' => 'Zend\I18n\View\Helper\CurrencyFormat', 'dateformat' => 'Zend\I18n\View\Helper\DateFormat', 'numberformat' => 'Zend\I18n\View\Helper\NumberFormat', 'plural' => 'Zend\I18n\View\Helper\Plural', 'translate' => 'Zend\I18n\View\Helper\Translate', 'translateplural' => 'Zend\I18n\View\Helper\TranslatePlural', ); public function configureServiceManager(ServiceManager $serviceManager) { foreach ($this->invokables as $name => $service) { $serviceManager->setInvokableClass($name, $service); } } } 
namespace Zend\Navigation\View; use Zend\ServiceManager\ConfigInterface; use Zend\ServiceManager\ServiceManager; use Zend\View\HelperPluginManager; class HelperConfig implements ConfigInterface { public function configureServiceManager(ServiceManager $serviceManager) { $serviceManager->setFactory('navigation', function (HelperPluginManager $pm) { $helper = new \Zend\View\Helper\Navigation; $helper->setServiceLocator($pm->getServiceLocator()); return $helper; }); } } 
namespace Zend\Mvc\Service; use Zend\ServiceManager\ConfigInterface; use Zend\ServiceManager\ServiceLocatorInterface; class ValidatorManagerFactory extends AbstractPluginManagerFactory { const PLUGIN_MANAGER_CLASS = 'Zend\Validator\ValidatorPluginManager'; public function createService(ServiceLocatorInterface $serviceLocator) { $plugins = parent::createService($serviceLocator); return $plugins; } } 
namespace Zend\Validator; use Zend\ServiceManager\AbstractPluginManager; use Zend\ServiceManager\ConfigInterface; class ValidatorPluginManager extends AbstractPluginManager { protected $invokableClasses = array( 'alnum' => 'Zend\I18n\Validator\Alnum', 'alpha' => 'Zend\I18n\Validator\Alpha', 'barcodecode25interleaved' => 'Zend\Validator\Barcode\Code25interleaved', 'barcodecode25' => 'Zend\Validator\Barcode\Code25', 'barcodecode39ext' => 'Zend\Validator\Barcode\Code39ext', 'barcodecode39' => 'Zend\Validator\Barcode\Code39', 'barcodecode93ext' => 'Zend\Validator\Barcode\Code93ext', 'barcodecode93' => 'Zend\Validator\Barcode\Code93', 'barcodeean12' => 'Zend\Validator\Barcode\Ean12', 'barcodeean13' => 'Zend\Validator\Barcode\Ean13', 'barcodeean14' => 'Zend\Validator\Barcode\Ean14', 'barcodeean18' => 'Zend\Validator\Barcode\Ean18', 'barcodeean2' => 'Zend\Validator\Barcode\Ean2', 'barcodeean5' => 'Zend\Validator\Barcode\Ean5', 'barcodeean8' => 'Zend\Validator\Barcode\Ean8', 'barcodegtin12' => 'Zend\Validator\Barcode\Gtin12', 'barcodegtin13' => 'Zend\Validator\Barcode\Gtin13', 'barcodegtin14' => 'Zend\Validator\Barcode\Gtin14', 'barcodeidentcode' => 'Zend\Validator\Barcode\Identcode', 'barcodeintelligentmail' => 'Zend\Validator\Barcode\Intelligentmail', 'barcodeissn' => 'Zend\Validator\Barcode\Issn', 'barcodeitf14' => 'Zend\Validator\Barcode\Itf14', 'barcodeleitcode' => 'Zend\Validator\Barcode\Leitcode', 'barcodeplanet' => 'Zend\Validator\Barcode\Planet', 'barcodepostnet' => 'Zend\Validator\Barcode\Postnet', 'barcoderoyalmail' => 'Zend\Validator\Barcode\Royalmail', 'barcodesscc' => 'Zend\Validator\Barcode\Sscc', 'barcodeupca' => 'Zend\Validator\Barcode\Upca', 'barcodeupce' => 'Zend\Validator\Barcode\Upce', 'barcode' => 'Zend\Validator\Barcode', 'between' => 'Zend\Validator\Between', 'callback' => 'Zend\Validator\Callback', 'creditcard' => 'Zend\Validator\CreditCard', 'csrf' => 'Zend\Validator\Csrf', 'date' => 'Zend\Validator\Date', 'datestep' => 'Zend\Validator\DateStep', 'datetime' => 'Zend\I18n\Validator\DateTime', 'dbnorecordexists' => 'Zend\Validator\Db\NoRecordExists', 'dbrecordexists' => 'Zend\Validator\Db\RecordExists', 'digits' => 'Zend\Validator\Digits', 'emailaddress' => 'Zend\Validator\EmailAddress', 'explode' => 'Zend\Validator\Explode', 'filecount' => 'Zend\Validator\File\Count', 'filecrc32' => 'Zend\Validator\File\Crc32', 'fileexcludeextension' => 'Zend\Validator\File\ExcludeExtension', 'fileexcludemimetype' => 'Zend\Validator\File\ExcludeMimeType', 'fileexists' => 'Zend\Validator\File\Exists', 'fileextension' => 'Zend\Validator\File\Extension', 'filefilessize' => 'Zend\Validator\File\FilesSize', 'filehash' => 'Zend\Validator\File\Hash', 'fileimagesize' => 'Zend\Validator\File\ImageSize', 'fileiscompressed' => 'Zend\Validator\File\IsCompressed', 'fileisimage' => 'Zend\Validator\File\IsImage', 'filemd5' => 'Zend\Validator\File\Md5', 'filemimetype' => 'Zend\Validator\File\MimeType', 'filenotexists' => 'Zend\Validator\File\NotExists', 'filesha1' => 'Zend\Validator\File\Sha1', 'filesize' => 'Zend\Validator\File\Size', 'fileupload' => 'Zend\Validator\File\Upload', 'fileuploadfile' => 'Zend\Validator\File\UploadFile', 'filewordcount' => 'Zend\Validator\File\WordCount', 'float' => 'Zend\I18n\Validator\Float', 'greaterthan' => 'Zend\Validator\GreaterThan', 'hex' => 'Zend\Validator\Hex', 'hostname' => 'Zend\Validator\Hostname', 'iban' => 'Zend\Validator\Iban', 'identical' => 'Zend\Validator\Identical', 'inarray' => 'Zend\Validator\InArray', 'int' => 'Zend\I18n\Validator\Int', 'ip' => 'Zend\Validator\Ip', 'isbn' => 'Zend\Validator\Isbn', 'isinstanceof' => 'Zend\Validator\IsInstanceOf', 'lessthan' => 'Zend\Validator\LessThan', 'notempty' => 'Zend\Validator\NotEmpty', 'phonenumber' => 'Zend\I18n\Validator\PhoneNumber', 'postcode' => 'Zend\I18n\Validator\PostCode', 'regex' => 'Zend\Validator\Regex', 'sitemapchangefreq' => 'Zend\Validator\Sitemap\Changefreq', 'sitemaplastmod' => 'Zend\Validator\Sitemap\Lastmod', 'sitemaploc' => 'Zend\Validator\Sitemap\Loc', 'sitemappriority' => 'Zend\Validator\Sitemap\Priority', 'stringlength' => 'Zend\Validator\StringLength', 'step' => 'Zend\Validator\Step', 'uri' => 'Zend\Validator\Uri', ); protected $shareByDefault = false; public function __construct(ConfigInterface $configuration = null) { parent::__construct($configuration); $this->addInitializer(array($this, 'injectTranslator')); $this->addInitializer(array($this, 'injectValidatorPluginManager')); } public function injectTranslator($validator) { if ($validator instanceof Translator\TranslatorAwareInterface) { $locator = $this->getServiceLocator(); if ($locator && $locator->has('MvcTranslator')) { $validator->setTranslator($locator->get('MvcTranslator')); } } } public function injectValidatorPluginManager($validator) { if ($validator instanceof ValidatorPluginManagerAwareInterface) { $validator->setValidatorPluginManager($this); } } public function validatePlugin($plugin) { if ($plugin instanceof ValidatorInterface) { return; } throw new Exception\RuntimeException(sprintf( 'Plugin of type %s is invalid; must implement %s\ValidatorInterface', (is_object($plugin) ? get_class($plugin) : gettype($plugin)), __NAMESPACE__ )); } } 
namespace Zend\Mvc\Service; use Zend\ServiceManager\ConfigInterface; use Zend\ServiceManager\ServiceLocatorInterface; class FilterManagerFactory extends AbstractPluginManagerFactory { const PLUGIN_MANAGER_CLASS = 'Zend\Filter\FilterPluginManager'; public function createService(ServiceLocatorInterface $serviceLocator) { $plugins = parent::createService($serviceLocator); return $plugins; } } 
namespace Zend\Filter; use Zend\ServiceManager\AbstractPluginManager; class FilterPluginManager extends AbstractPluginManager { protected $invokableClasses = array( 'alnum' => 'Zend\I18n\Filter\Alnum', 'alpha' => 'Zend\I18n\Filter\Alpha', 'basename' => 'Zend\Filter\BaseName', 'boolean' => 'Zend\Filter\Boolean', 'callback' => 'Zend\Filter\Callback', 'compress' => 'Zend\Filter\Compress', 'compressbz2' => 'Zend\Filter\Compress\Bz2', 'compressgz' => 'Zend\Filter\Compress\Gz', 'compresslzf' => 'Zend\Filter\Compress\Lzf', 'compressrar' => 'Zend\Filter\Compress\Rar', 'compresssnappy' => 'Zend\Filter\Compress\Snappy', 'compresstar' => 'Zend\Filter\Compress\Tar', 'compresszip' => 'Zend\Filter\Compress\Zip', 'datetimeformatter' => 'Zend\Filter\DateTimeFormatter', 'decompress' => 'Zend\Filter\Decompress', 'decrypt' => 'Zend\Filter\Decrypt', 'digits' => 'Zend\Filter\Digits', 'dir' => 'Zend\Filter\Dir', 'encrypt' => 'Zend\Filter\Encrypt', 'encryptblockcipher' => 'Zend\Filter\Encrypt\BlockCipher', 'encryptopenssl' => 'Zend\Filter\Encrypt\Openssl', 'filedecrypt' => 'Zend\Filter\File\Decrypt', 'fileencrypt' => 'Zend\Filter\File\Encrypt', 'filelowercase' => 'Zend\Filter\File\LowerCase', 'filerename' => 'Zend\Filter\File\Rename', 'filerenameupload' => 'Zend\Filter\File\RenameUpload', 'fileuppercase' => 'Zend\Filter\File\UpperCase', 'htmlentities' => 'Zend\Filter\HtmlEntities', 'inflector' => 'Zend\Filter\Inflector', 'int' => 'Zend\Filter\Int', 'null' => 'Zend\Filter\Null', 'numberformat' => 'Zend\I18n\Filter\NumberFormat', 'pregreplace' => 'Zend\Filter\PregReplace', 'realpath' => 'Zend\Filter\RealPath', 'stringtolower' => 'Zend\Filter\StringToLower', 'stringtoupper' => 'Zend\Filter\StringToUpper', 'stringtrim' => 'Zend\Filter\StringTrim', 'stripnewlines' => 'Zend\Filter\StripNewlines', 'striptags' => 'Zend\Filter\StripTags', 'urinormalize' => 'Zend\Filter\UriNormalize', 'wordcamelcasetodash' => 'Zend\Filter\Word\CamelCaseToDash', 'wordcamelcasetoseparator' => 'Zend\Filter\Word\CamelCaseToSeparator', 'wordcamelcasetounderscore' => 'Zend\Filter\Word\CamelCaseToUnderscore', 'worddashtocamelcase' => 'Zend\Filter\Word\DashToCamelCase', 'worddashtoseparator' => 'Zend\Filter\Word\DashToSeparator', 'worddashtounderscore' => 'Zend\Filter\Word\DashToUnderscore', 'wordseparatortocamelcase' => 'Zend\Filter\Word\SeparatorToCamelCase', 'wordseparatortodash' => 'Zend\Filter\Word\SeparatorToDash', 'wordseparatortoseparator' => 'Zend\Filter\Word\SeparatorToSeparator', 'wordunderscoretocamelcase' => 'Zend\Filter\Word\UnderscoreToCamelCase', 'wordunderscoretodash' => 'Zend\Filter\Word\UnderscoreToDash', 'wordunderscoretoseparator' => 'Zend\Filter\Word\UnderscoreToSeparator', ); protected $shareByDefault = false; public function validatePlugin($plugin) { if ($plugin instanceof FilterInterface) { return; } if (is_callable($plugin)) { return; } throw new Exception\RuntimeException(sprintf( 'Plugin of type %s is invalid; must implement %s\FilterInterface or be callable', (is_object($plugin) ? get_class($plugin) : gettype($plugin)), __NAMESPACE__ )); } } 
namespace Zend\Mvc\Service; use Zend\Form\FormElementManager; use Zend\ServiceManager\ServiceLocatorInterface; class FormElementManagerFactory extends AbstractPluginManagerFactory { const PLUGIN_MANAGER_CLASS = 'Zend\Form\FormElementManager'; public function createService(ServiceLocatorInterface $serviceLocator) { $plugins = parent::createService($serviceLocator); $plugins->addPeeringServiceManager($serviceLocator); $plugins->setRetrieveFromPeeringManagerFirst(true); return $plugins; } } 
namespace Zend\Form; use Zend\ServiceManager\AbstractPluginManager; use Zend\ServiceManager\ConfigInterface; use Zend\ServiceManager\ServiceLocatorInterface; use Zend\Stdlib\InitializableInterface; class FormElementManager extends AbstractPluginManager { protected $invokableClasses = array( 'button' => 'Zend\Form\Element\Button', 'captcha' => 'Zend\Form\Element\Captcha', 'checkbox' => 'Zend\Form\Element\Checkbox', 'collection' => 'Zend\Form\Element\Collection', 'color' => 'Zend\Form\Element\Color', 'csrf' => 'Zend\Form\Element\Csrf', 'date' => 'Zend\Form\Element\Date', 'dateselect' => 'Zend\Form\Element\DateSelect', 'datetime' => 'Zend\Form\Element\DateTime', 'datetimelocal' => 'Zend\Form\Element\DateTimeLocal', 'datetimeselect' => 'Zend\Form\Element\DateTimeSelect', 'element' => 'Zend\Form\Element', 'email' => 'Zend\Form\Element\Email', 'fieldset' => 'Zend\Form\Fieldset', 'file' => 'Zend\Form\Element\File', 'form' => 'Zend\Form\Form', 'hidden' => 'Zend\Form\Element\Hidden', 'image' => 'Zend\Form\Element\Image', 'month' => 'Zend\Form\Element\Month', 'monthselect' => 'Zend\Form\Element\MonthSelect', 'multicheckbox' => 'Zend\Form\Element\MultiCheckbox', 'number' => 'Zend\Form\Element\Number', 'password' => 'Zend\Form\Element\Password', 'radio' => 'Zend\Form\Element\Radio', 'range' => 'Zend\Form\Element\Range', 'select' => 'Zend\Form\Element\Select', 'submit' => 'Zend\Form\Element\Submit', 'text' => 'Zend\Form\Element\Text', 'textarea' => 'Zend\Form\Element\Textarea', 'time' => 'Zend\Form\Element\Time', 'url' => 'Zend\Form\Element\Url', 'week' => 'Zend\Form\Element\Week', ); protected $shareByDefault = false; public function __construct(ConfigInterface $configuration = null) { parent::__construct($configuration); $this->addInitializer(array($this, 'injectFactory')); } public function injectFactory($element) { if ($element instanceof FormFactoryAwareInterface) { $factory = $element->getFormFactory(); $factory->setFormElementManager($this); if ($this->serviceLocator instanceof ServiceLocatorInterface && $this->serviceLocator->has('InputFilterManager') ) { $inputFilters = $this->serviceLocator->get('InputFilterManager'); $factory->getInputFilterFactory()->setInputFilterManager($inputFilters); } } } public function validatePlugin($plugin) { if ($plugin instanceof InitializableInterface) { $plugin->init(); } if ($plugin instanceof ElementInterface) { return; } throw new Exception\InvalidElementException(sprintf( 'Plugin of type %s is invalid; must implement Zend\Form\ElementInterface', (is_object($plugin) ? get_class($plugin) : gettype($plugin)) )); } public function get($name, $options = array(), $usePeeringServiceManagers = true) { if (is_string($options)) { $options = array('name' => $options); } return parent::get($name, $options, $usePeeringServiceManagers); } protected function createFromInvokable($canonicalName, $requestedName) { $invokable = $this->invokableClasses[$canonicalName]; if (null === $this->creationOptions || (is_array($this->creationOptions) && empty($this->creationOptions)) ) { $instance = new $invokable(); } else { if (isset($this->creationOptions['name'])) { $name = $this->creationOptions['name']; } else { $name = $requestedName; } if (isset($this->creationOptions['options'])) { $options = $this->creationOptions['options']; } else { $options = $this->creationOptions; } $instance = new $invokable($name, $options); } return $instance; } } 
namespace Zend\Mvc\Service; class RoutePluginManagerFactory extends AbstractPluginManagerFactory { const PLUGIN_MANAGER_CLASS = 'Zend\Mvc\Router\RoutePluginManager'; } 
namespace Zend\Mvc\Router; use Zend\ServiceManager\AbstractPluginManager; class RoutePluginManager extends AbstractPluginManager { protected $shareByDefault = false; public function setInvokableClass($name, $invokableClass, $shared = null) { parent::setInvokableClass($name, $invokableClass, $shared); if ($name != $invokableClass) { $this->setAlias($invokableClass, $name); } return $this; } public function validatePlugin($plugin) { if ($plugin instanceof RouteInterface) { return; } throw new Exception\RuntimeException(sprintf( 'Plugin of type %s is invalid; must implement %s\RouteInterface', (is_object($plugin) ? get_class($plugin) : gettype($plugin)), __NAMESPACE__ )); } protected function createFromInvokable($canonicalName, $requestedName) { $invokable = $this->invokableClasses[$canonicalName]; if (!class_exists($invokable)) { throw new Exception\RuntimeException(sprintf( '%s: failed retrieving "%s%s" via invokable class "%s"; class does not exist', __METHOD__, $canonicalName, ($requestedName ? '(alias: ' . $requestedName . ')' : ''), $invokable )); } if (!static::isSubclassOf($invokable, __NAMESPACE__ . '\RouteInterface')) { throw new Exception\RuntimeException(sprintf( '%s: failed retrieving "%s%s" via invokable class "%s"; class does not implement %s\RouteInterface', __METHOD__, $canonicalName, ($requestedName ? '(alias: ' . $requestedName . ')' : ''), $invokable, __NAMESPACE__ )); } return $invokable::factory($this->creationOptions); } } 
namespace Zend\Mvc\Service; class SerializerAdapterPluginManagerFactory extends AbstractPluginManagerFactory { const PLUGIN_MANAGER_CLASS = 'Zend\Serializer\AdapterPluginManager'; } 
namespace Zend\Serializer; use Zend\ServiceManager\AbstractPluginManager; class AdapterPluginManager extends AbstractPluginManager { protected $invokableClasses = array( 'igbinary' => 'Zend\Serializer\Adapter\IgBinary', 'json' => 'Zend\Serializer\Adapter\Json', 'msgpack' => 'Zend\Serializer\Adapter\MsgPack', 'phpcode' => 'Zend\Serializer\Adapter\PhpCode', 'phpserialize' => 'Zend\Serializer\Adapter\PhpSerialize', 'pythonpickle' => 'Zend\Serializer\Adapter\PythonPickle', 'wddx' => 'Zend\Serializer\Adapter\Wddx', ); public function validatePlugin($plugin) { if ($plugin instanceof Adapter\AdapterInterface) { return; } throw new Exception\RuntimeException(sprintf( 'Plugin of type %s is invalid; must implement %s\Adapter\AdapterInterface', (is_object($plugin) ? get_class($plugin) : gettype($plugin)), __NAMESPACE__ )); } } 
namespace Zend\Mvc\Service; use Zend\ServiceManager\ConfigInterface; use Zend\ServiceManager\ServiceLocatorInterface; class HydratorManagerFactory extends AbstractPluginManagerFactory { const PLUGIN_MANAGER_CLASS = 'Zend\Stdlib\Hydrator\HydratorPluginManager'; } 
namespace Zend\Stdlib\Hydrator; use Zend\ServiceManager\AbstractPluginManager; use Zend\Stdlib\Exception; class HydratorPluginManager extends AbstractPluginManager { protected $shareByDefault = false; protected $invokableClasses = array( 'arrayserializable' => 'Zend\Stdlib\Hydrator\ArraySerializable', 'classmethods' => 'Zend\Stdlib\Hydrator\ClassMethods', 'objectproperty' => 'Zend\Stdlib\Hydrator\ObjectProperty', 'reflection' => 'Zend\Stdlib\Hydrator\Reflection' ); public function validatePlugin($plugin) { if ($plugin instanceof HydratorInterface) { return; } throw new Exception\RuntimeException(sprintf( 'Plugin of type %s is invalid; must implement Zend\Stdlib\Hydrator\HydratorInterface', (is_object($plugin) ? get_class($plugin) : gettype($plugin)) )); } } 
namespace Zend\Mvc\Service; use Zend\ServiceManager\ConfigInterface; use Zend\ServiceManager\ServiceLocatorInterface; class InputFilterManagerFactory extends AbstractPluginManagerFactory { const PLUGIN_MANAGER_CLASS = 'Zend\InputFilter\InputFilterPluginManager'; } 
namespace Zend\InputFilter; use Zend\InputFilter\Exception; use Zend\ServiceManager\AbstractPluginManager; use Zend\ServiceManager\ConfigInterface; use Zend\ServiceManager\ServiceLocatorInterface; use Zend\Stdlib\InitializableInterface; class InputFilterPluginManager extends AbstractPluginManager { protected $invokableClasses = array( 'inputfilter' => 'Zend\InputFilter\InputFilter', 'collection' => 'Zend\InputFilter\CollectionInputFilter', ); protected $shareByDefault = false; public function __construct(ConfigInterface $configuration = null) { parent::__construct($configuration); $this->addInitializer(array($this, 'populateFactory')); } public function populateFactory($inputfilter) { if ($inputfilter instanceof InputFilter) { $factory = $inputfilter->getFactory(); $factory->setInputFilterManager($this); if ($this->serviceLocator instanceof ServiceLocatorInterface) { $factory->getDefaultFilterChain()->setPluginManager($this->serviceLocator->get('FilterManager')); $factory->getDefaultValidatorChain()->setPluginManager($this->serviceLocator->get('ValidatorManager')); } } } public function validatePlugin($plugin) { if ($plugin instanceof InputFilterInterface) { if ($plugin instanceof InitializableInterface) { $plugin->init(); } return; } throw new Exception\RuntimeException(sprintf( 'Plugin of type %s is invalid; must implement Zend\InputFilter\InputFilterInterface', (is_object($plugin) ? get_class($plugin) : gettype($plugin)) )); } } 
namespace Zend\Mvc\Service; use Zend\Mvc\Application; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class ApplicationFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { return new Application($serviceLocator->get('Config'), $serviceLocator); } } 
namespace Zend\Mvc\Service; use Zend\Console\Console; use Zend\Console\Request as ConsoleRequest; use Zend\Http\PhpEnvironment\Request as HttpRequest; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class RequestFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { if (Console::isConsole()) { return new ConsoleRequest(); } return new HttpRequest(); } } 
namespace Zend\Console; abstract class Console { protected static $instance; protected static $isConsole; public static function getInstance($forceAdapter = null, $forceCharset = null) { if (static::$instance instanceof Adapter\AdapterInterface) { return static::$instance; } if ($forceAdapter !== null) { if (substr($forceAdapter, 0, 1) == '\\') { $className = $forceAdapter; } elseif (stristr($forceAdapter, '\\')) { $className = __NAMESPACE__ . '\\' . ltrim($forceAdapter, '\\'); } else { $className = __NAMESPACE__ . '\\Adapter\\' . $forceAdapter; } if (!class_exists($className)) { throw new Exception\InvalidArgumentException(sprintf( 'Cannot find Console adapter class "%s"', $className )); } } else { $className = static::detectBestAdapter(); if (!$className) { throw new Exception\RuntimeException('Cannot create Console adapter - am I running in a console?'); } } static::$instance = new $className(); if ($forceCharset !== null) { if (substr($forceCharset, 0, 1) == '\\') { $className = $forceCharset; } elseif (stristr($forceAdapter, '\\')) { $className = __NAMESPACE__ . '\\' . ltrim($forceCharset, '\\'); } else { $className = __NAMESPACE__ . '\\Charset\\' . $forceCharset; } if (!class_exists($className)) { throw new Exception\InvalidArgumentException(sprintf( 'Cannot find Charset class "%s"', $className )); } static::$instance->setCharset(new $className()); } return static::$instance; } public static function resetInstance() { static::$instance = null; } public static function isWindows() { return (defined('PHP_OS') && (substr_compare(PHP_OS, 'win', 0, 3, true) === 0)) || (getenv('OS') != false && substr_compare(getenv('OS'), 'windows', 0, 7, true)) ; } public static function isAnsicon() { return getenv('ANSICON') !== false; } public static function isConsole() { if (null === static::$isConsole) { static::$isConsole = (PHP_SAPI == 'cli'); } return static::$isConsole; } public static function overrideIsConsole($flag) { if (null != $flag) { $flag = (bool) $flag; } static::$isConsole = $flag; } public static function detectBestAdapter() { if (!static::isConsole()) { return null; } if (static::isWindows()) { if (static::isAnsicon()) { $className = __NAMESPACE__ . '\Adapter\WindowsAnsicon'; } else { $className = __NAMESPACE__ . '\Adapter\Windows'; } return $className; } $className = __NAMESPACE__ . '\Adapter\Posix'; return $className; } public static function __callStatic($funcName, $arguments) { $instance = static::getInstance(); return call_user_func_array(array($instance, $funcName), $arguments); } } 
namespace Zend\Stdlib; interface RequestInterface extends MessageInterface { } 
namespace Zend\Stdlib; interface MessageInterface { public function setMetadata($spec, $value = null); public function getMetadata($key = null); public function setContent($content); public function getContent(); } 
namespace Zend\Http; use Zend\Stdlib\Parameters; use Zend\Stdlib\ParametersInterface; use Zend\Stdlib\RequestInterface; use Zend\Uri\Exception as UriException; use Zend\Uri\Http as HttpUri; class Request extends AbstractMessage implements RequestInterface { const METHOD_OPTIONS = 'OPTIONS'; const METHOD_GET = 'GET'; const METHOD_HEAD = 'HEAD'; const METHOD_POST = 'POST'; const METHOD_PUT = 'PUT'; const METHOD_DELETE = 'DELETE'; const METHOD_TRACE = 'TRACE'; const METHOD_CONNECT = 'CONNECT'; const METHOD_PATCH = 'PATCH'; const METHOD_PROPFIND= 'PROPFIND'; protected $method = self::METHOD_GET; protected $uri = null; protected $queryParams = null; protected $postParams = null; protected $fileParams = null; public static function fromString($string) { $request = new static(); $lines = explode("\r\n", $string); $matches = null; $methods = implode('|', array( self::METHOD_OPTIONS, self::METHOD_GET, self::METHOD_HEAD, self::METHOD_POST, self::METHOD_PUT, self::METHOD_DELETE, self::METHOD_TRACE, self::METHOD_CONNECT, self::METHOD_PATCH )); $regex = '#^(?P<method>' . $methods . ')\s(?P<uri>[^ ]*)(?:\sHTTP\/(?P<version>\d+\.\d+)){0,1}#'; $firstLine = array_shift($lines); if (!preg_match($regex, $firstLine, $matches)) { throw new Exception\InvalidArgumentException( 'A valid request line was not found in the provided string' ); } $request->setMethod($matches['method']); $request->setUri($matches['uri']); if (isset($matches['version'])) { $request->setVersion($matches['version']); } if (count($lines) == 0) { return $request; } $isHeader = true; $headers = $rawBody = array(); while ($lines) { $nextLine = array_shift($lines); if ($nextLine == '') { $isHeader = false; continue; } if ($isHeader) { $headers[] = $nextLine; } else { $rawBody[] = $nextLine; } } if ($headers) { $request->headers = implode("\r\n", $headers); } if ($rawBody) { $request->setContent(implode("\r\n", $rawBody)); } return $request; } public function setMethod($method) { $method = strtoupper($method); if (!defined('static::METHOD_' . $method)) { throw new Exception\InvalidArgumentException('Invalid HTTP method passed'); } $this->method = $method; return $this; } public function getMethod() { return $this->method; } public function setUri($uri) { if (is_string($uri)) { try { $uri = new HttpUri($uri); } catch (UriException\InvalidUriPartException $e) { throw new Exception\InvalidArgumentException( sprintf('Invalid URI passed as string (%s)', (string) $uri), $e->getCode(), $e ); } } elseif (!($uri instanceof HttpUri)) { throw new Exception\InvalidArgumentException( 'URI must be an instance of Zend\Uri\Http or a string' ); } $this->uri = $uri; return $this; } public function getUri() { if ($this->uri === null || is_string($this->uri)) { $this->uri = new HttpUri($this->uri); } return $this->uri; } public function getUriString() { if ($this->uri instanceof HttpUri) { return $this->uri->toString(); } return $this->uri; } public function setQuery(ParametersInterface $query) { $this->queryParams = $query; return $this; } public function getQuery($name = null, $default = null) { if ($this->queryParams === null) { $this->queryParams = new Parameters(); } if ($name === null) { return $this->queryParams; } return $this->queryParams->get($name, $default); } public function setPost(ParametersInterface $post) { $this->postParams = $post; return $this; } public function getPost($name = null, $default = null) { if ($this->postParams === null) { $this->postParams = new Parameters(); } if ($name === null) { return $this->postParams; } return $this->postParams->get($name, $default); } public function getCookie() { return $this->getHeaders()->get('Cookie'); } public function setFiles(ParametersInterface $files) { $this->fileParams = $files; return $this; } public function getFiles($name = null, $default = null) { if ($this->fileParams === null) { $this->fileParams = new Parameters(); } if ($name === null) { return $this->fileParams; } return $this->fileParams->get($name, $default); } public function getHeaders($name = null, $default = false) { if ($this->headers === null || is_string($this->headers)) { $this->headers = (is_string($this->headers)) ? Headers::fromString($this->headers) : new Headers(); } if ($name === null) { return $this->headers; } if ($this->headers->has($name)) { return $this->headers->get($name); } return $default; } public function getHeader($name, $default = false) { return $this->getHeaders($name, $default); } public function isOptions() { return ($this->method === self::METHOD_OPTIONS); } public function isPropFind() { return ($this->method === self::METHOD_PROPFIND); } public function isGet() { return ($this->method === self::METHOD_GET); } public function isHead() { return ($this->method === self::METHOD_HEAD); } public function isPost() { return ($this->method === self::METHOD_POST); } public function isPut() { return ($this->method === self::METHOD_PUT); } public function isDelete() { return ($this->method === self::METHOD_DELETE); } public function isTrace() { return ($this->method === self::METHOD_TRACE); } public function isConnect() { return ($this->method === self::METHOD_CONNECT); } public function isPatch() { return ($this->method === self::METHOD_PATCH); } public function isXmlHttpRequest() { $header = $this->getHeaders()->get('X_REQUESTED_WITH'); return false !== $header && $header->getFieldValue() == 'XMLHttpRequest'; } public function isFlashRequest() { $header = $this->getHeaders()->get('USER_AGENT'); return false !== $header && stristr($header->getFieldValue(), ' flash'); } public function renderRequestLine() { return $this->method . ' ' . (string) $this->uri . ' HTTP/' . $this->version; } public function toString() { $str = $this->renderRequestLine() . "\r\n"; $str .= $this->getHeaders()->toString(); $str .= "\r\n"; $str .= $this->getContent(); return $str; } } 
namespace Zend\Http\PhpEnvironment; use Zend\Http\Header\Cookie; use Zend\Http\Request as HttpRequest; use Zend\Stdlib\Parameters; use Zend\Stdlib\ParametersInterface; use Zend\Uri\Http as HttpUri; use Zend\Validator\Hostname as HostnameValidator; class Request extends HttpRequest { protected $baseUrl; protected $basePath; protected $requestUri; protected $serverParams = null; protected $envParams = null; public function __construct() { $this->setEnv(new Parameters($_ENV)); if ($_GET) { $this->setQuery(new Parameters($_GET)); } if ($_POST) { $this->setPost(new Parameters($_POST)); } if ($_COOKIE) { $this->setCookies(new Parameters($_COOKIE)); } if ($_FILES) { $files = $this->mapPhpFiles(); $this->setFiles(new Parameters($files)); } $this->setServer(new Parameters($_SERVER)); } public function getContent() { if (empty($this->content)) { $requestBody = file_get_contents('php://input'); if (strlen($requestBody) > 0) { $this->content = $requestBody; } } return $this->content; } public function setCookies($cookie) { $this->getHeaders()->addHeader(new Cookie((array) $cookie)); return $this; } public function setRequestUri($requestUri) { $this->requestUri = $requestUri; return $this; } public function getRequestUri() { if ($this->requestUri === null) { $this->requestUri = $this->detectRequestUri(); } return $this->requestUri; } public function setBaseUrl($baseUrl) { $this->baseUrl = rtrim($baseUrl, '/'); return $this; } public function getBaseUrl() { if ($this->baseUrl === null) { $this->setBaseUrl($this->detectBaseUrl()); } return $this->baseUrl; } public function setBasePath($basePath) { $this->basePath = rtrim($basePath, '/'); return $this; } public function getBasePath() { if ($this->basePath === null) { $this->setBasePath($this->detectBasePath()); } return $this->basePath; } public function setServer(ParametersInterface $server) { $this->serverParams = $server; if (function_exists('apache_request_headers')) { $apacheRequestHeaders = apache_request_headers(); if (!isset($this->serverParams['HTTP_AUTHORIZATION'])) { if (isset($apacheRequestHeaders['Authorization'])) { $this->serverParams->set('HTTP_AUTHORIZATION', $apacheRequestHeaders['Authorization']); } elseif (isset($apacheRequestHeaders['authorization'])) { $this->serverParams->set('HTTP_AUTHORIZATION', $apacheRequestHeaders['authorization']); } } } $headers = array(); foreach ($server as $key => $value) { if ($value && strpos($key, 'HTTP_') === 0) { if (strpos($key, 'HTTP_COOKIE') === 0) { continue; } $name = strtr(substr($key, 5), '_', ' '); $name = strtr(ucwords(strtolower($name)), ' ', '-'); } elseif ($value && strpos($key, 'CONTENT_') === 0) { $name = substr($key, 8); $name = 'Content-' . (($name == 'MD5') ? $name : ucfirst(strtolower($name))); } else { continue; } $headers[$name] = $value; } $this->getHeaders()->addHeaders($headers); if (isset($this->serverParams['REQUEST_METHOD'])) { $this->setMethod($this->serverParams['REQUEST_METHOD']); } if (isset($this->serverParams['SERVER_PROTOCOL']) && strpos($this->serverParams['SERVER_PROTOCOL'], self::VERSION_10) !== false ) { $this->setVersion(self::VERSION_10); } $uri = new HttpUri(); $scheme = (!empty($this->serverParams['HTTPS']) && $this->serverParams['HTTPS'] !== 'off') ? 'https' : 'http'; $uri->setScheme($scheme); $host = null; $port = null; if ($this->getHeaders()->get('host')) { $host = $this->getHeaders()->get('host')->getFieldValue(); if (preg_match('|\:(\d+)$|', $host, $matches)) { $host = substr($host, 0, -1 * (strlen($matches[1]) + 1)); $port = (int) $matches[1]; } $hostnameValidator = new HostnameValidator(array( 'allow' => HostnameValidator::ALLOW_ALL, 'useIdnCheck' => false, 'useTldCheck' => false, )); if (!$hostnameValidator->isValid($host)) { $host = null; $port = null; } } if (!$host && isset($this->serverParams['SERVER_NAME'])) { $host = $this->serverParams['SERVER_NAME']; if (isset($this->serverParams['SERVER_PORT'])) { $port = (int) $this->serverParams['SERVER_PORT']; } if (isset($this->serverParams['SERVER_ADDR']) && preg_match('/^\[[0-9a-fA-F\:]+\]$/', $host)) { $host = '[' . $this->serverParams['SERVER_ADDR'] . ']'; if ($port . ']' == substr($host, strrpos($host, ':')+1)) { $port = null; } } } $uri->setHost($host); $uri->setPort($port); $requestUri = $this->getRequestUri(); if (($qpos = strpos($requestUri, '?')) !== false) { $requestUri = substr($requestUri, 0, $qpos); } $uri->setPath($requestUri); if (isset($this->serverParams['QUERY_STRING'])) { $uri->setQuery($this->serverParams['QUERY_STRING']); } $this->setUri($uri); return $this; } public function getServer($name = null, $default = null) { if ($this->serverParams === null) { $this->serverParams = new Parameters(); } if ($name === null) { return $this->serverParams; } return $this->serverParams->get($name, $default); } public function setEnv(ParametersInterface $env) { $this->envParams = $env; return $this; } public function getEnv($name = null, $default = null) { if ($this->envParams === null) { $this->envParams = new Parameters(); } if ($name === null) { return $this->envParams; } return $this->envParams->get($name, $default); } protected function mapPhpFiles() { $files = array(); foreach ($_FILES as $fileName => $fileParams) { $files[$fileName] = array(); foreach ($fileParams as $param => $data) { if (!is_array($data)) { $files[$fileName][$param] = $data; } else { foreach ($data as $i => $v) { $this->mapPhpFileParam($files[$fileName], $param, $i, $v); } } } } return $files; } protected function mapPhpFileParam(&$array, $paramName, $index, $value) { if (!is_array($value)) { $array[$index][$paramName] = $value; } else { foreach ($value as $i => $v) { $this->mapPhpFileParam($array[$index], $paramName, $i, $v); } } } protected function detectRequestUri() { $requestUri = null; $server = $this->getServer(); $httpXRewriteUrl = $server->get('HTTP_X_REWRITE_URL'); if ($httpXRewriteUrl !== null) { $requestUri = $httpXRewriteUrl; } $httpXOriginalUrl = $server->get('HTTP_X_ORIGINAL_URL'); if ($httpXOriginalUrl !== null) { $requestUri = $httpXOriginalUrl; } $iisUrlRewritten = $server->get('IIS_WasUrlRewritten'); $unencodedUrl = $server->get('UNENCODED_URL', ''); if ('1' == $iisUrlRewritten && '' !== $unencodedUrl) { return $unencodedUrl; } if (!$httpXRewriteUrl) { $requestUri = $server->get('REQUEST_URI'); } if ($requestUri !== null) { return preg_replace('#^[^/:]+://[^/]+#', '', $requestUri); } $origPathInfo = $server->get('ORIG_PATH_INFO'); if ($origPathInfo !== null) { $queryString = $server->get('QUERY_STRING', ''); if ($queryString !== '') { $origPathInfo .= '?' . $queryString; } return $origPathInfo; } return '/'; } protected function detectBaseUrl() { $baseUrl = ''; $filename = $this->getServer()->get('SCRIPT_FILENAME', ''); $scriptName = $this->getServer()->get('SCRIPT_NAME'); $phpSelf = $this->getServer()->get('PHP_SELF'); $origScriptName = $this->getServer()->get('ORIG_SCRIPT_NAME'); if ($scriptName !== null && basename($scriptName) === $filename) { $baseUrl = $scriptName; } elseif ($phpSelf !== null && basename($phpSelf) === $filename) { $baseUrl = $phpSelf; } elseif ($origScriptName !== null && basename($origScriptName) === $filename) { $baseUrl = $origScriptName; } else { $baseUrl = '/'; $basename = basename($filename); if ($basename) { $path = ($phpSelf ? trim($phpSelf, '/') : ''); $baseUrl .= substr($path, 0, strpos($path, $basename)) . $basename; } } $requestUri = $this->getRequestUri(); if (0 === strpos($requestUri, $baseUrl)) { return $baseUrl; } $baseDir = str_replace('\\', '/', dirname($baseUrl)); if (0 === strpos($requestUri, $baseDir)) { return $baseDir; } $truncatedRequestUri = $requestUri; if (false !== ($pos = strpos($requestUri, '?'))) { $truncatedRequestUri = substr($requestUri, 0, $pos); } $basename = basename($baseUrl); if (empty($basename) || false === strpos($truncatedRequestUri, $basename)) { return ''; } if (strlen($requestUri) >= strlen($baseUrl) && (false !== ($pos = strpos($requestUri, $baseUrl)) && $pos !== 0) ) { $baseUrl = substr($requestUri, 0, $pos + strlen($baseUrl)); } return $baseUrl; } protected function detectBasePath() { $filename = basename($this->getServer()->get('SCRIPT_FILENAME', '')); $baseUrl = $this->getBaseUrl(); if ($baseUrl === '') { return ''; } if (basename($baseUrl) === $filename) { return str_replace('\\', '/', dirname($baseUrl)); } return $baseUrl; } } 
namespace Zend\Stdlib; use ArrayAccess; use Countable; use Serializable; use Traversable; interface ParametersInterface extends ArrayAccess, Countable, Serializable, Traversable { public function __construct(array $values = null); public function fromArray(array $values); public function fromString($string); public function toArray(); public function toString(); public function get($name, $default = null); public function set($name, $value); } 
namespace Zend\Stdlib; use ArrayObject as PhpArrayObject; class Parameters extends PhpArrayObject implements ParametersInterface { public function __construct(array $values = null) { if (null === $values) { $values = array(); } parent::__construct($values, ArrayObject::ARRAY_AS_PROPS); } public function fromArray(array $values) { $this->exchangeArray($values); } public function fromString($string) { $array = array(); parse_str($string, $array); $this->fromArray($array); } public function toArray() { return $this->getArrayCopy(); } public function toString() { return http_build_query($this); } public function offsetGet($name) { if (isset($this[$name])) { return parent::offsetGet($name); } return null; } public function get($name, $default = null) { if (isset($this[$name])) { return parent::offsetGet($name); } return $default; } public function set($name, $value) { $this[$name] = $value; return $this; } } 
namespace Zend\Stdlib\ArrayObject; use ArrayAccess; use Countable; use IteratorAggregate; use Serializable; use Zend\Stdlib\Exception; abstract class PhpReferenceCompatibility implements IteratorAggregate, ArrayAccess, Serializable, Countable { const STD_PROP_LIST = 1; const ARRAY_AS_PROPS = 2; protected $storage; protected $flag; protected $iteratorClass; protected $protectedProperties; public function __construct($input = array(), $flags = self::STD_PROP_LIST, $iteratorClass = 'ArrayIterator') { $this->setFlags($flags); $this->storage = $input; $this->setIteratorClass($iteratorClass); $this->protectedProperties = array_keys(get_object_vars($this)); } public function __isset($key) { if ($this->flag == self::ARRAY_AS_PROPS) { return $this->offsetExists($key); } if (in_array($key, $this->protectedProperties)) { throw new Exception\InvalidArgumentException('$key is a protected property, use a different key'); } return isset($this->$key); } public function __set($key, $value) { if ($this->flag == self::ARRAY_AS_PROPS) { return $this->offsetSet($key, $value); } if (in_array($key, $this->protectedProperties)) { throw new Exception\InvalidArgumentException('$key is a protected property, use a different key'); } $this->$key = $value; } public function __unset($key) { if ($this->flag == self::ARRAY_AS_PROPS) { return $this->offsetUnset($key); } if (in_array($key, $this->protectedProperties)) { throw new Exception\InvalidArgumentException('$key is a protected property, use a different key'); } unset($this->$key); } public function &__get($key) { $ret = null; if ($this->flag == self::ARRAY_AS_PROPS) { $ret =& $this->offsetGet($key); return $ret; } if (in_array($key, $this->protectedProperties)) { throw new Exception\InvalidArgumentException('$key is a protected property, use a different key'); } return $this->$key; } public function append($value) { $this->storage[] = $value; } public function asort() { asort($this->storage); } public function count() { return count($this->storage); } public function exchangeArray($data) { if (!is_array($data) && !is_object($data)) { throw new Exception\InvalidArgumentException('Passed variable is not an array or object, using empty array instead'); } if (is_object($data) && ($data instanceof self || $data instanceof \ArrayObject)) { $data = $data->getArrayCopy(); } if (!is_array($data)) { $data = (array) $data; } $storage = $this->storage; $this->storage = $data; return $storage; } public function getArrayCopy() { return $this->storage; } public function getFlags() { return $this->flag; } public function getIterator() { $class = $this->iteratorClass; return new $class($this->storage); } public function getIteratorClass() { return $this->iteratorClass; } public function ksort() { ksort($this->storage); } public function natcasesort() { natcasesort($this->storage); } public function natsort() { natsort($this->storage); } public function offsetExists($key) { return isset($this->storage[$key]); } public function &offsetGet($key) { $ret = null; if (!$this->offsetExists($key)) { return $ret; } $ret =& $this->storage[$key]; return $ret; } public function offsetSet($key, $value) { $this->storage[$key] = $value; } public function offsetUnset($key) { if ($this->offsetExists($key)) { unset($this->storage[$key]); } } public function serialize() { return serialize(get_object_vars($this)); } public function setFlags($flags) { $this->flag = $flags; } public function setIteratorClass($class) { if (class_exists($class)) { $this->iteratorClass = $class; return ; } if (strpos($class, '\\') === 0) { $class = '\\' . $class; if (class_exists($class)) { $this->iteratorClass = $class; return ; } } throw new Exception\InvalidArgumentException('The iterator class does not exist'); } public function uasort($function) { if (is_callable($function)) { uasort($this->storage, $function); } } public function uksort($function) { if (is_callable($function)) { uksort($this->storage, $function); } } public function unserialize($data) { $ar = unserialize($data); $this->setFlags($ar['flag']); $this->exchangeArray($ar['storage']); $this->setIteratorClass($ar['iteratorClass']); foreach ($ar as $k => $v) { switch ($k) { case 'flag': $this->setFlags($v); break; case 'storage': $this->exchangeArray($v); break; case 'iteratorClass': $this->setIteratorClass($v); break; case 'protectedProperties': continue; default: $this->__set($k, $v); } } } } 
namespace Zend\Stdlib; if (version_compare(PHP_VERSION, '5.3.4', 'lt')) { class_alias('Zend\Stdlib\ArrayObject\PhpLegacyCompatibility', 'Zend\Stdlib\AbstractArrayObject'); } else { class_alias('Zend\Stdlib\ArrayObject\PhpReferenceCompatibility', 'Zend\Stdlib\AbstractArrayObject'); } class ArrayObject extends AbstractArrayObject { } 
namespace Zend\Http; use ArrayIterator; use Countable; use Iterator; use Traversable; use Zend\Http\HeaderLoader; use Zend\Loader\PluginClassLocator; class Headers implements Countable, Iterator { protected $pluginClassLoader = null; protected $headersKeys = array(); protected $headers = array(); public static function fromString($string) { $headers = new static(); $current = array(); foreach (explode("\r\n", $string) as $line) { if (preg_match('/^(?P<name>[^()><@,;:\"\\/\[\]?=}{ \t]+):.*$/', $line, $matches)) { if ($current) { $headers->headersKeys[] = static::createKey($current['name']); $headers->headers[] = $current; } $current = array( 'name' => $matches['name'], 'line' => trim($line) ); } elseif (preg_match('/^\s+.*$/', $line, $matches)) { $current['line'] .= trim($line); } elseif (preg_match('/^\s*$/', $line)) { break; } else { throw new Exception\RuntimeException(sprintf( 'Line "%s"does not match header format!', $line )); } } if ($current) { $headers->headersKeys[] = static::createKey($current['name']); $headers->headers[] = $current; } return $headers; } public function setPluginClassLoader(PluginClassLocator $pluginClassLoader) { $this->pluginClassLoader = $pluginClassLoader; return $this; } public function getPluginClassLoader() { if ($this->pluginClassLoader === null) { $this->pluginClassLoader = new HeaderLoader(); } return $this->pluginClassLoader; } public function addHeaders($headers) { if (!is_array($headers) && !$headers instanceof Traversable) { throw new Exception\InvalidArgumentException(sprintf( 'Expected array or Traversable; received "%s"', (is_object($headers) ? get_class($headers) : gettype($headers)) )); } foreach ($headers as $name => $value) { if (is_int($name)) { if (is_string($value)) { $this->addHeaderLine($value); } elseif (is_array($value) && count($value) == 1) { $this->addHeaderLine(key($value), current($value)); } elseif (is_array($value) && count($value) == 2) { $this->addHeaderLine($value[0], $value[1]); } elseif ($value instanceof Header\HeaderInterface) { $this->addHeader($value); } } elseif (is_string($name)) { $this->addHeaderLine($name, $value); } } return $this; } public function addHeaderLine($headerFieldNameOrLine, $fieldValue = null) { $matches = null; if (preg_match('/^(?P<name>[^()><@,;:\"\\/\[\]?=}{ \t]+):.*$/', $headerFieldNameOrLine, $matches) && $fieldValue === null) { $headerName = $matches['name']; $headerKey = static::createKey($matches['name']); $line = $headerFieldNameOrLine; } elseif ($fieldValue === null) { throw new Exception\InvalidArgumentException('A field name was provided without a field value'); } else { $headerName = $headerFieldNameOrLine; $headerKey = static::createKey($headerFieldNameOrLine); if (is_array($fieldValue)) { $fieldValue = implode(', ', $fieldValue); } $line = $headerFieldNameOrLine . ': ' . $fieldValue; } $this->headersKeys[] = $headerKey; $this->headers[] = array('name' => $headerName, 'line' => $line); return $this; } public function addHeader(Header\HeaderInterface $header) { $this->headersKeys[] = static::createKey($header->getFieldName()); $this->headers[] = $header; return $this; } public function removeHeader(Header\HeaderInterface $header) { $index = array_search($header, $this->headers, true); if ($index !== false) { unset($this->headersKeys[$index]); unset($this->headers[$index]); return true; } return false; } public function clearHeaders() { $this->headers = $this->headersKeys = array(); return $this; } public function get($name) { $key = static::createKey($name); if (!in_array($key, $this->headersKeys)) { return false; } $class = ($this->getPluginClassLoader()->load($key)) ?: 'Zend\Http\Header\GenericHeader'; if (in_array('Zend\Http\Header\MultipleHeaderInterface', class_implements($class, true))) { $headers = array(); foreach (array_keys($this->headersKeys, $key) as $index) { if (is_array($this->headers[$index])) { $this->lazyLoadHeader($index); } } foreach (array_keys($this->headersKeys, $key) as $index) { $headers[] = $this->headers[$index]; } return new ArrayIterator($headers); } $index = array_search($key, $this->headersKeys); if ($index === false) { return false; } if (is_array($this->headers[$index])) { return $this->lazyLoadHeader($index); } return $this->headers[$index]; } public function has($name) { return (in_array(static::createKey($name), $this->headersKeys)); } public function next() { next($this->headers); } public function key() { return (key($this->headers)); } public function valid() { return (current($this->headers) !== false); } public function rewind() { reset($this->headers); } public function current() { $current = current($this->headers); if (is_array($current)) { $current = $this->lazyLoadHeader(key($this->headers)); } return $current; } public function count() { return count($this->headers); } public function toString() { $headers = ''; foreach ($this->toArray() as $fieldName => $fieldValue) { if (is_array($fieldValue)) { foreach ($fieldValue as $value) { $headers .= $fieldName . ': ' . $value . "\r\n"; } continue; } $headers .= $fieldName . ': ' . $fieldValue . "\r\n"; } return $headers; } public function toArray() { $headers = array(); foreach ($this->headers as $header) { if ($header instanceof Header\MultipleHeaderInterface) { $name = $header->getFieldName(); if (!isset($headers[$name])) { $headers[$name] = array(); } $headers[$name][] = $header->getFieldValue(); } elseif ($header instanceof Header\HeaderInterface) { $headers[$header->getFieldName()] = $header->getFieldValue(); } else { $matches = null; preg_match('/^(?P<name>[^()><@,;:\"\\/\[\]?=}{ \t]+):\s*(?P<value>.*)$/', $header['line'], $matches); if ($matches) { $headers[$matches['name']] = $matches['value']; } } } return $headers; } public function forceLoading() { foreach ($this as $item) { } return true; } protected function lazyLoadHeader($index) { $current = $this->headers[$index]; $key = $this->headersKeys[$index]; $class = ($this->getPluginClassLoader()->load($key)) ?: 'Zend\Http\Header\GenericHeader'; $headers = $class::fromString($current['line']); if (is_array($headers)) { $this->headers[$index] = $current = array_shift($headers); foreach ($headers as $header) { $this->headersKeys[] = $key; $this->headers[] = $header; } return $current; } $this->headers[$index] = $current = $headers; return $current; } protected static function createKey($name) { return str_replace(array('-', '_', ' ', '.'), '', strtolower($name)); } } 
namespace Zend\Http\Header; interface HeaderInterface { public static function fromString($headerLine); public function getFieldName(); public function getFieldValue(); public function toString(); } 
namespace Zend\Http\Header; use ArrayObject; class Cookie extends ArrayObject implements HeaderInterface { protected $encodeValue = true; public static function fromSetCookieArray(array $setCookies) { $nvPairs = array(); foreach ($setCookies as $setCookie) { if (!$setCookie instanceof SetCookie) { throw new Exception\InvalidArgumentException(__CLASS__ . '::' . __METHOD__ . ' requires an array of SetCookie objects'); } if (array_key_exists($setCookie->getName(), $nvPairs)) { throw new Exception\InvalidArgumentException('Two cookies with the same name were provided to ' . __CLASS__ . '::' . __METHOD__); } $nvPairs[$setCookie->getName()] = $setCookie->getValue(); } return new static($nvPairs); } public static function fromString($headerLine) { $header = new static(); list($name, $value) = GenericHeader::splitHeaderLine($headerLine); if (strtolower($name) !== 'cookie') { throw new Exception\InvalidArgumentException('Invalid header line for Server string: "' . $name . '"'); } $nvPairs = preg_split('#;\s*#', $value); $arrayInfo = array(); foreach ($nvPairs as $nvPair) { $parts = explode('=', $nvPair, 2); if (count($parts) != 2) { throw new Exception\RuntimeException('Malformed Cookie header found'); } list($name, $value) = $parts; $arrayInfo[$name] = urldecode($value); } $header->exchangeArray($arrayInfo); return $header; } public function __construct(array $array = array()) { parent::__construct($array, ArrayObject::ARRAY_AS_PROPS); } public function setEncodeValue($encodeValue) { $this->encodeValue = (bool) $encodeValue; return $this; } public function getEncodeValue() { return $this->encodeValue; } public function getFieldName() { return 'Cookie'; } public function getFieldValue() { $nvPairs = array(); foreach ($this as $name => $value) { $nvPairs[] = $name . '=' . (($this->encodeValue) ? urlencode($value) : $value); } return implode('; ', $nvPairs); } public function toString() { return 'Cookie: ' . $this->getFieldValue(); } public function __toString() { return $this->toString(); } } 
namespace Zend\Uri; interface UriInterface { public function __construct($uri = null); public function isValid(); public function isValidRelative(); public function isAbsolute(); public function parse($uri); public function toString(); public function normalize(); public function makeRelative($baseUri); public function getScheme(); public function getUserInfo(); public function getHost(); public function getPort(); public function getPath(); public function getQuery(); public function getQueryAsArray(); public function getFragment(); public function setScheme($scheme); public function setUserInfo($userInfo); public function setHost($host); public function setPort($port); public function setPath($path); public function setQuery($query); public function setFragment($fragment); public function __toString(); } 
namespace Zend\Uri; use Zend\Escaper\Escaper; use Zend\Validator; class Uri implements UriInterface { const CHAR_UNRESERVED = 'a-zA-Z0-9_\-\.~'; const CHAR_GEN_DELIMS = ':\/\?#\[\]@'; const CHAR_SUB_DELIMS = '!\$&\'\(\)\*\+,;='; const CHAR_RESERVED = ':\/\?#\[\]@!\$&\'\(\)\*\+,;='; const HOST_IPV4 = 0x01; const HOST_IPV6 = 0x02; const HOST_IPVFUTURE = 0x04; const HOST_IPVANY = 0x07; const HOST_DNS = 0x08; const HOST_DNS_OR_IPV4 = 0x09; const HOST_DNS_OR_IPV6 = 0x0A; const HOST_DNS_OR_IPV4_OR_IPV6 = 0x0B; const HOST_DNS_OR_IPVANY = 0x0F; const HOST_REGNAME = 0x10; const HOST_DNS_OR_IPV4_OR_IPV6_OR_REGNAME = 0x13; const HOST_ALL = 0x1F; protected $scheme; protected $userInfo; protected $host; protected $port; protected $path; protected $query; protected $fragment; protected $validHostTypes = self::HOST_ALL; protected static $validSchemes = array(); protected static $defaultPorts = array(); protected static $escaper; public function __construct($uri = null) { if (is_string($uri)) { $this->parse($uri); } elseif ($uri instanceof UriInterface) { $this->setScheme($uri->getScheme()); $this->setUserInfo($uri->getUserInfo()); $this->setHost($uri->getHost()); $this->setPort($uri->getPort()); $this->setPath($uri->getPath()); $this->setQuery($uri->getQuery()); $this->setFragment($uri->getFragment()); } elseif ($uri !== null) { throw new Exception\InvalidArgumentException(sprintf( 'Expecting a string or a URI object, received "%s"', (is_object($uri) ? get_class($uri) : gettype($uri)) )); } } public static function setEscaper(Escaper $escaper) { static::$escaper = $escaper; } public static function getEscaper() { if (null === static::$escaper) { static::setEscaper(new Escaper()); } return static::$escaper; } public function isValid() { if ($this->host) { if (strlen($this->path) > 0 && substr($this->path, 0, 1) != '/') { return false; } return true; } if ($this->userInfo || $this->port) { return false; } if ($this->path) { if (substr($this->path, 0, 2) == '//') { return false; } return true; } if (! ($this->query || $this->fragment)) { return false; } return true; } public function isValidRelative() { if ($this->scheme || $this->host || $this->userInfo || $this->port) { return false; } if ($this->path) { if (substr($this->path, 0, 2) == '//') { return false; } return true; } if (! ($this->query || $this->fragment)) { return false; } return true; } public function isAbsolute() { return ($this->scheme !== null); } protected function reset() { $this->setScheme(null); $this->setPort(null); $this->setUserInfo(null); $this->setHost(null); $this->setPath(null); $this->setFragment(null); $this->setQuery(null); } public function parse($uri) { $this->reset(); if (($scheme = self::parseScheme($uri)) !== null) { $this->setScheme($scheme); $uri = substr($uri, strlen($scheme) + 1); } if (preg_match('|^//([^/\?#]*)|', $uri, $match)) { $authority = $match[1]; $uri = substr($uri, strlen($match[0])); if (strpos($authority, '@') !== false) { $segments = explode('@', $authority); $authority = array_pop($segments); $userInfo = implode('@', $segments); unset($segments); $this->setUserInfo($userInfo); } $nMatches = preg_match('/:[\d]{1,5}$/', $authority, $matches); if ($nMatches === 1) { $portLength = strlen($matches[0]); $port = substr($matches[0], 1); $this->setPort((int) $port); $authority = substr($authority, 0, -$portLength); } $this->setHost($authority); } if (!$uri) { return $this; } if (preg_match('|^[^\?#]*|', $uri, $match)) { $this->setPath($match[0]); $uri = substr($uri, strlen($match[0])); } if (!$uri) { return $this; } if (preg_match('|^\?([^#]*)|', $uri, $match)) { $this->setQuery($match[1]); $uri = substr($uri, strlen($match[0])); } if (!$uri) { return $this; } if ($uri && substr($uri, 0, 1) == '#') { $this->setFragment(substr($uri, 1)); } return $this; } public function toString() { if (!$this->isValid()) { if ($this->isAbsolute() || !$this->isValidRelative()) { throw new Exception\InvalidUriException( 'URI is not valid and cannot be converted into a string' ); } } $uri = ''; if ($this->scheme) { $uri .= $this->scheme . ':'; } if ($this->host !== null) { $uri .= '//'; if ($this->userInfo) { $uri .= $this->userInfo . '@'; } $uri .= $this->host; if ($this->port) { $uri .= ':' . $this->port; } } if ($this->path) { $uri .= static::encodePath($this->path); } elseif ($this->host && ($this->query || $this->fragment)) { $uri .= '/'; } if ($this->query) { $uri .= "?" . static::encodeQueryFragment($this->query); } if ($this->fragment) { $uri .= "#" . static::encodeQueryFragment($this->fragment); } return $uri; } public function normalize() { if ($this->scheme) { $this->scheme = static::normalizeScheme($this->scheme); } if ($this->host) { $this->host = static::normalizeHost($this->host); } if ($this->port) { $this->port = static::normalizePort($this->port, $this->scheme); } if ($this->path) { $this->path = static::normalizePath($this->path); } if ($this->query) { $this->query = static::normalizeQuery($this->query); } if ($this->fragment) { $this->fragment = static::normalizeFragment($this->fragment); } if ($this->host && empty($this->path)) { $this->path = '/'; } return $this; } public function resolve($baseUri) { if ($this->isAbsolute()) { return $this; } if (is_string($baseUri)) { $baseUri = new static($baseUri); } elseif (!$baseUri instanceof Uri) { throw new Exception\InvalidArgumentException( 'Provided base URI must be a string or a Uri object' ); } if ($this->getHost()) { $this->setPath(static::removePathDotSegments($this->getPath())); } else { $basePath = $baseUri->getPath(); $relPath = $this->getPath(); if (!$relPath) { $this->setPath($basePath); if (!$this->getQuery()) { $this->setQuery($baseUri->getQuery()); } } else { if (substr($relPath, 0, 1) == '/') { $this->setPath(static::removePathDotSegments($relPath)); } else { if ($baseUri->getHost() && !$basePath) { $mergedPath = '/'; } else { $mergedPath = substr($basePath, 0, strrpos($basePath, '/') + 1); } $this->setPath(static::removePathDotSegments($mergedPath . $relPath)); } } $this->setUserInfo($baseUri->getUserInfo()); $this->setHost($baseUri->getHost()); $this->setPort($baseUri->getPort()); } $this->setScheme($baseUri->getScheme()); return $this; } public function makeRelative($baseUri) { $baseUri = new static($baseUri); $this->normalize(); $baseUri->normalize(); $host = $this->getHost(); $baseHost = $baseUri->getHost(); if ($host && $baseHost && ($host != $baseHost)) { return $this; } $port = $this->getPort(); $basePort = $baseUri->getPort(); if ($port && $basePort && ($port != $basePort)) { return $this; } $scheme = $this->getScheme(); $baseScheme = $baseUri->getScheme(); if ($scheme && $baseScheme && ($scheme != $baseScheme)) { return $this; } $this->setHost(null) ->setPort(null) ->setScheme(null); if ($this->getPath() == $baseUri->getPath()) { $this->setPath(''); return $this; } $pathParts = preg_split('|(/)|', $this->getPath(), null, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY); $baseParts = preg_split('|(/)|', $baseUri->getPath(), null, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY); $matchingParts = array_intersect_assoc($pathParts, $baseParts); foreach ($matchingParts as $index => $segment) { if ($index && !isset($matchingParts[$index - 1])) { array_unshift($pathParts, '../'); continue; } unset($pathParts[$index]); } $this->setPath(implode($pathParts)); return $this; } public function getScheme() { return $this->scheme; } public function getUserInfo() { return $this->userInfo; } public function getHost() { return $this->host; } public function getPort() { return $this->port; } public function getPath() { return $this->path; } public function getQuery() { return $this->query; } public function getQueryAsArray() { $query = array(); if ($this->query) { parse_str($this->query, $query); } return $query; } public function getFragment() { return $this->fragment; } public function setScheme($scheme) { if (($scheme !== null) && (!self::validateScheme($scheme))) { throw new Exception\InvalidUriPartException(sprintf( 'Scheme "%s" is not valid or is not accepted by %s', $scheme, get_class($this) ), Exception\InvalidUriPartException::INVALID_SCHEME); } $this->scheme = $scheme; return $this; } public function setUserInfo($userInfo) { $this->userInfo = $userInfo; return $this; } public function setHost($host) { if (($host !== '') && ($host !== null) && !self::validateHost($host, $this->validHostTypes) ) { throw new Exception\InvalidUriPartException(sprintf( 'Host "%s" is not valid or is not accepted by %s', $host, get_class($this) ), Exception\InvalidUriPartException::INVALID_HOSTNAME); } $this->host = $host; return $this; } public function setPort($port) { $this->port = $port; return $this; } public function setPath($path) { $this->path = $path; return $this; } public function setQuery($query) { if (is_array($query)) { $query = str_replace('+', '%20', http_build_query($query)); } $this->query = $query; return $this; } public function setFragment($fragment) { $this->fragment = $fragment; return $this; } public function __toString() { try { return $this->toString(); } catch (\Exception $e) { return ''; } } public static function validateScheme($scheme) { if (!empty(static::$validSchemes) && !in_array(strtolower($scheme), static::$validSchemes) ) { return false; } return (bool) preg_match('/^[A-Za-z][A-Za-z0-9\-\.+]*$/', $scheme); } public static function validateUserInfo($userInfo) { $regex = '/^(?:[' . self::CHAR_UNRESERVED . self::CHAR_SUB_DELIMS . ':]+|%[A-Fa-f0-9]{2})*$/'; return (bool) preg_match($regex, $userInfo); } public static function validateHost($host, $allowed = self::HOST_ALL) { if ($allowed & self::HOST_IPVANY) { if (static::isValidIpAddress($host, $allowed)) { return true; } } if ($allowed & self::HOST_REGNAME) { if (static::isValidRegName($host)) { return true; } } if ($allowed & self::HOST_DNS) { if (static::isValidDnsHostname($host)) { return true; } } return false; } public static function validatePort($port) { if ($port === 0) { return false; } if ($port) { $port = (int) $port; if ($port < 1 || $port > 0xffff) { return false; } } return true; } public static function validatePath($path) { $pchar = '(?:[' . self::CHAR_UNRESERVED . ':@&=\+\$,]+|%[A-Fa-f0-9]{2})*'; $segment = $pchar . "(?:;{$pchar})*"; $regex = "/^{$segment}(?:\/{$segment})*$/"; return (bool) preg_match($regex, $path); } public static function validateQueryFragment($input) { $regex = '/^(?:[' . self::CHAR_UNRESERVED . self::CHAR_SUB_DELIMS . ':@\/\?]+|%[A-Fa-f0-9]{2})*$/'; return (bool) preg_match($regex, $input); } public static function encodeUserInfo($userInfo) { if (!is_string($userInfo)) { throw new Exception\InvalidArgumentException(sprintf( 'Expecting a string, got %s', (is_object($userInfo) ? get_class($userInfo) : gettype($userInfo)) )); } $regex = '/(?:[^' . self::CHAR_UNRESERVED . self::CHAR_SUB_DELIMS . '%:]|%(?![A-Fa-f0-9]{2}))/'; $escaper = static::getEscaper(); $replace = function ($match) use ($escaper) { return $escaper->escapeUrl($match[0]); }; return preg_replace_callback($regex, $replace, $userInfo); } public static function encodePath($path) { if (!is_string($path)) { throw new Exception\InvalidArgumentException(sprintf( 'Expecting a string, got %s', (is_object($path) ? get_class($path) : gettype($path)) )); } $regex = '/(?:[^' . self::CHAR_UNRESERVED . ':@&=\+\$,\/;%]+|%(?![A-Fa-f0-9]{2}))/'; $escaper = static::getEscaper(); $replace = function ($match) use ($escaper) { return $escaper->escapeUrl($match[0]); }; return preg_replace_callback($regex, $replace, $path); } public static function encodeQueryFragment($input) { if (!is_string($input)) { throw new Exception\InvalidArgumentException(sprintf( 'Expecting a string, got %s', (is_object($input) ? get_class($input) : gettype($input)) )); } $regex = '/(?:[^' . self::CHAR_UNRESERVED . self::CHAR_SUB_DELIMS . '%:@\/\?]+|%(?![A-Fa-f0-9]{2}))/'; $escaper = static::getEscaper(); $replace = function ($match) use ($escaper) { return $escaper->escapeUrl($match[0]); }; return preg_replace_callback($regex, $replace, $input); } public static function parseScheme($uriString) { if (! is_string($uriString)) { throw new Exception\InvalidArgumentException(sprintf( 'Expecting a string, got %s', (is_object($uriString) ? get_class($uriString) : gettype($uriString)) )); } if (preg_match('/^([A-Za-z][A-Za-z0-9\.\+\-]*):/', $uriString, $match)) { return $match[1]; } return null; } public static function removePathDotSegments($path) { $output = ''; while ($path) { if ($path == '..' || $path == '.') { break; } switch (true) { case ($path == '/.'): $path = '/'; break; case ($path == '/..'): $path = '/'; $output = substr($output, 0, strrpos($output, '/', -1)); break; case (substr($path, 0, 4) == '/../'): $path = '/' . substr($path, 4); $output = substr($output, 0, strrpos($output, '/', -1)); break; case (substr($path, 0, 3) == '/./'): $path = substr($path, 2); break; case (substr($path, 0, 2) == './'): $path = substr($path, 2); break; case (substr($path, 0, 3) == '../'): $path = substr($path, 3); break; default: $slash = strpos($path, '/', 1); if ($slash === false) { $seg = $path; } else { $seg = substr($path, 0, $slash); } $output .= $seg; $path = substr($path, strlen($seg)); break; } } return $output; } public static function merge($baseUri, $relativeUri) { $uri = new static($relativeUri); return $uri->resolve($baseUri); } protected static function isValidIpAddress($host, $allowed) { $validatorParams = array( 'allowipv4' => (bool) ($allowed & self::HOST_IPV4), 'allowipv6' => false, 'allowipvfuture' => false, 'allowliteral' => false, ); $validator = new Validator\Ip($validatorParams); $return = $validator->isValid($host); if ($return) { return true; } $validatorParams = array( 'allowipv4' => false, 'allowipv6' => (bool) ($allowed & self::HOST_IPV6), 'allowipvfuture' => (bool) ($allowed & self::HOST_IPVFUTURE), 'allowliteral' => true, ); static $regex = '/^\[.*\]$/'; $validator->setOptions($validatorParams); return (preg_match($regex, $host) && $validator->isValid($host)); } protected static function isValidDnsHostname($host) { $validator = new Validator\Hostname(array( 'allow' => Validator\Hostname::ALLOW_DNS | Validator\Hostname::ALLOW_LOCAL, )); return $validator->isValid($host); } protected static function isValidRegName($host) { $regex = '/^(?:[' . self::CHAR_UNRESERVED . self::CHAR_SUB_DELIMS . ':@\/\?]+|%[A-Fa-f0-9]{2})+$/'; return (bool) preg_match($regex, $host); } protected static function normalizeScheme($scheme) { return strtolower($scheme); } protected static function normalizeHost($host) { return strtolower($host); } protected static function normalizePort($port, $scheme = null) { if ($scheme && isset(static::$defaultPorts[$scheme]) && ($port == static::$defaultPorts[$scheme]) ) { return null; } return $port; } protected static function normalizePath($path) { $path = self::encodePath( self::decodeUrlEncodedChars( self::removePathDotSegments($path), '/[' . self::CHAR_UNRESERVED . ':@&=\+\$,\/;%]/' ) ); return $path; } protected static function normalizeQuery($query) { $query = self::encodeQueryFragment( self::decodeUrlEncodedChars( $query, '/[' . self::CHAR_UNRESERVED . self::CHAR_SUB_DELIMS . '%:@\/\?]/' ) ); return $query; } protected static function normalizeFragment($fragment) { return static::normalizeQuery($fragment); } protected static function decodeUrlEncodedChars($input, $allowed = '') { $decodeCb = function ($match) use ($allowed) { $char = rawurldecode($match[0]); if (preg_match($allowed, $char)) { return $char; } return strtoupper($match[0]); }; return preg_replace_callback('/%[A-Fa-f0-9]{2}/', $decodeCb, $input); } } 
namespace Zend\Uri; class Http extends Uri { protected static $validSchemes = array( 'http', 'https' ); protected static $defaultPorts = array( 'http' => 80, 'https' => 443, ); protected $validHostTypes = self::HOST_DNS_OR_IPV4_OR_IPV6_OR_REGNAME; protected $user; protected $password; public function isValid() { return parent::isValid(); } public function getUser() { if (null !== $this->user) { return $this->user; } $this->parseUserInfo(); return $this->user; } public function getPassword() { if (null !== $this->password) { return $this->password; } $this->parseUserInfo(); return $this->password; } public function setUser($user) { $this->user = $user; return $this; } public function setPassword($password) { $this->password = $password; return $this; } public static function validateHost($host, $allowed = self::HOST_DNS_OR_IPV4_OR_IPV6) { return parent::validateHost($host, $allowed); } protected function parseUserInfo() { if (null === $this->userInfo) { return; } if (false === strpos($this->userInfo, ':')) { $this->setUser($this->userInfo); return; } list($user, $password) = explode(':', $this->userInfo, 2); $this->setUser($user); $this->setPassword($password); } public function getPort() { if (empty($this->port)) { if (array_key_exists($this->scheme, static::$defaultPorts)) { return static::$defaultPorts[$this->scheme]; } } return $this->port; } public function parse($uri) { parent::parse($uri); if (empty($this->path)) { $this->path = '/'; } return $this; } } 
namespace Zend\Loader; interface ShortNameLocator { public function isLoaded($name); public function getClassName($name); public function load($name); } 
namespace Zend\Loader; use IteratorAggregate; use Traversable; interface PluginClassLocator extends ShortNameLocator, IteratorAggregate { public function registerPlugin($shortName, $className); public function unregisterPlugin($shortName); public function getRegisteredPlugins(); } 
namespace Zend\Loader; use ArrayIterator; use IteratorAggregate; use Traversable; class PluginClassLoader implements PluginClassLocator { protected $plugins = array(); protected static $staticMap = array(); public function __construct($map = null) { if (!empty(static::$staticMap)) { $this->registerPlugins(static::$staticMap); } if ($map !== null) { $this->registerPlugins($map); } } public static function addStaticMap($map) { if (null === $map) { static::$staticMap = array(); return; } if (!is_array($map) && !$map instanceof Traversable) { throw new Exception\InvalidArgumentException('Expects an array or Traversable object'); } foreach ($map as $key => $value) { static::$staticMap[$key] = $value; } } public function registerPlugin($shortName, $className) { $this->plugins[strtolower($shortName)] = $className; return $this; } public function registerPlugins($map) { if (is_string($map)) { if (!class_exists($map)) { throw new Exception\InvalidArgumentException('Map class provided is invalid'); } $map = new $map; } if (is_array($map)) { $map = new ArrayIterator($map); } if (!$map instanceof Traversable) { throw new Exception\InvalidArgumentException('Map provided is invalid; must be traversable'); } if ($map instanceof IteratorAggregate) { $map = $map->getIterator(); } foreach ($map as $name => $class) { if (is_int($name) || is_numeric($name)) { if (!is_object($class) && class_exists($class)) { $class = new $class(); } if ($class instanceof Traversable) { $this->registerPlugins($class); continue; } } $this->registerPlugin($name, $class); } return $this; } public function unregisterPlugin($shortName) { $lookup = strtolower($shortName); if (array_key_exists($lookup, $this->plugins)) { unset($this->plugins[$lookup]); } return $this; } public function getRegisteredPlugins() { return $this->plugins; } public function isLoaded($name) { $lookup = strtolower($name); return isset($this->plugins[$lookup]); } public function getClassName($name) { return $this->load($name); } public function load($name) { if (!$this->isLoaded($name)) { return false; } return $this->plugins[strtolower($name)]; } public function getIterator() { return new ArrayIterator($this->plugins); } } 
namespace Zend\Http; use Zend\Loader\PluginClassLoader; class HeaderLoader extends PluginClassLoader { protected $plugins = array( 'accept' => 'Zend\Http\Header\Accept', 'acceptcharset' => 'Zend\Http\Header\AcceptCharset', 'acceptencoding' => 'Zend\Http\Header\AcceptEncoding', 'acceptlanguage' => 'Zend\Http\Header\AcceptLanguage', 'acceptranges' => 'Zend\Http\Header\AcceptRanges', 'age' => 'Zend\Http\Header\Age', 'allow' => 'Zend\Http\Header\Allow', 'authenticationinfo' => 'Zend\Http\Header\AuthenticationInfo', 'authorization' => 'Zend\Http\Header\Authorization', 'cachecontrol' => 'Zend\Http\Header\CacheControl', 'connection' => 'Zend\Http\Header\Connection', 'contentdisposition' => 'Zend\Http\Header\ContentDisposition', 'contentencoding' => 'Zend\Http\Header\ContentEncoding', 'contentlanguage' => 'Zend\Http\Header\ContentLanguage', 'contentlength' => 'Zend\Http\Header\ContentLength', 'contentlocation' => 'Zend\Http\Header\ContentLocation', 'contentmd5' => 'Zend\Http\Header\ContentMD5', 'contentrange' => 'Zend\Http\Header\ContentRange', 'contenttransferencoding' => 'Zend\Http\Header\ContentTransferEncoding', 'contenttype' => 'Zend\Http\Header\ContentType', 'cookie' => 'Zend\Http\Header\Cookie', 'date' => 'Zend\Http\Header\Date', 'etag' => 'Zend\Http\Header\Etag', 'expect' => 'Zend\Http\Header\Expect', 'expires' => 'Zend\Http\Header\Expires', 'from' => 'Zend\Http\Header\From', 'host' => 'Zend\Http\Header\Host', 'ifmatch' => 'Zend\Http\Header\IfMatch', 'ifmodifiedsince' => 'Zend\Http\Header\IfModifiedSince', 'ifnonematch' => 'Zend\Http\Header\IfNoneMatch', 'ifrange' => 'Zend\Http\Header\IfRange', 'ifunmodifiedsince' => 'Zend\Http\Header\IfUnmodifiedSince', 'keepalive' => 'Zend\Http\Header\KeepAlive', 'lastmodified' => 'Zend\Http\Header\LastModified', 'location' => 'Zend\Http\Header\Location', 'maxforwards' => 'Zend\Http\Header\MaxForwards', 'pragma' => 'Zend\Http\Header\Pragma', 'proxyauthenticate' => 'Zend\Http\Header\ProxyAuthenticate', 'proxyauthorization' => 'Zend\Http\Header\ProxyAuthorization', 'range' => 'Zend\Http\Header\Range', 'referer' => 'Zend\Http\Header\Referer', 'refresh' => 'Zend\Http\Header\Refresh', 'retryafter' => 'Zend\Http\Header\RetryAfter', 'server' => 'Zend\Http\Header\Server', 'setcookie' => 'Zend\Http\Header\SetCookie', 'te' => 'Zend\Http\Header\TE', 'trailer' => 'Zend\Http\Header\Trailer', 'transferencoding' => 'Zend\Http\Header\TransferEncoding', 'upgrade' => 'Zend\Http\Header\Upgrade', 'useragent' => 'Zend\Http\Header\UserAgent', 'vary' => 'Zend\Http\Header\Vary', 'via' => 'Zend\Http\Header\Via', 'warning' => 'Zend\Http\Header\Warning', 'wwwauthenticate' => 'Zend\Http\Header\WWWAuthenticate' ); } 
namespace Zend\Http\Header; class Host implements HeaderInterface { public static function fromString($headerLine) { $header = new static(); list($name, $value) = GenericHeader::splitHeaderLine($headerLine); if (strtolower($name) !== 'host') { throw new Exception\InvalidArgumentException('Invalid header line for Host string: "' . $name . '"'); } $header->value = $value; return $header; } public function getFieldName() { return 'Host'; } public function getFieldValue() { return $this->value; } public function toString() { return 'Host: ' . $this->getFieldValue(); } } 
namespace Zend\Http\Header; class GenericHeader implements HeaderInterface { protected $fieldName = null; protected $fieldValue = null; public static function fromString($headerLine) { list($fieldName, $fieldValue) = GenericHeader::splitHeaderLine($headerLine); $header = new static($fieldName, $fieldValue); return $header; } public static function splitHeaderLine($headerLine) { $parts = explode(':', $headerLine, 2); if (count($parts) !== 2) { throw new Exception\InvalidArgumentException('Header must match with the format "name:value"'); } $parts[1] = ltrim($parts[1]); return $parts; } public function __construct($fieldName = null, $fieldValue = null) { if ($fieldName) { $this->setFieldName($fieldName); } if ($fieldValue !== null) { $this->setFieldValue($fieldValue); } } public function setFieldName($fieldName) { if (!is_string($fieldName) || empty($fieldName)) { throw new Exception\InvalidArgumentException('Header name must be a string'); } $fieldName = str_replace('_', '-', $fieldName); if (!preg_match('/^[!#-\'*+\-\.0-9A-Z\^-z|~]+$/', $fieldName)) { throw new Exception\InvalidArgumentException( 'Header name must be a valid RFC 2616 (section 4.2) field-name.' ); } $this->fieldName = $fieldName; return $this; } public function getFieldName() { return $this->fieldName; } public function setFieldValue($fieldValue) { $fieldValue = (string) $fieldValue; if (preg_match('/^\s+$/', $fieldValue)) { $fieldValue = ''; } $this->fieldValue = $fieldValue; return $this; } public function getFieldValue() { return $this->fieldValue; } public function toString() { return $this->getFieldName() . ': ' . $this->getFieldValue(); } } 
namespace Zend\Validator; interface ValidatorInterface { public function isValid($value); public function getMessages(); } 
namespace Zend\Validator\Translator; interface TranslatorAwareInterface { public function setTranslator(TranslatorInterface $translator = null, $textDomain = null); public function getTranslator(); public function hasTranslator(); public function setTranslatorEnabled($enabled = true); public function isTranslatorEnabled(); public function setTranslatorTextDomain($textDomain = 'default'); public function getTranslatorTextDomain(); } 
namespace Zend\Validator; use Traversable; use Zend\Stdlib\ArrayUtils; abstract class AbstractValidator implements Translator\TranslatorAwareInterface, ValidatorInterface { protected $value; protected static $defaultTranslator; protected static $defaultTranslatorTextDomain = 'default'; protected static $messageLength = -1; protected $abstractOptions = array( 'messages' => array(), 'messageTemplates' => array(), 'messageVariables' => array(), 'translator' => null, 'translatorTextDomain' => null, 'translatorEnabled' => true, 'valueObscured' => false, ); public function __construct($options = null) { if ($options instanceof Traversable) { $options = ArrayUtils::iteratorToArray($options); } if (isset($this->messageTemplates)) { $this->abstractOptions['messageTemplates'] = $this->messageTemplates; } if (isset($this->messageVariables)) { $this->abstractOptions['messageVariables'] = $this->messageVariables; } if (is_array($options)) { $this->setOptions($options); } } public function getOption($option) { if (array_key_exists($option, $this->abstractOptions)) { return $this->abstractOptions[$option]; } if (isset($this->options) && array_key_exists($option, $this->options)) { return $this->options[$option]; } throw new Exception\InvalidArgumentException("Invalid option '$option'"); } public function getOptions() { $result = $this->abstractOptions; if (isset($this->options)) { $result += $this->options; } return $result; } public function setOptions($options = array()) { if (!is_array($options) && !$options instanceof Traversable) { throw new Exception\InvalidArgumentException(__METHOD__ . ' expects an array or Traversable'); } foreach ($options as $name => $option) { $fname = 'set' . ucfirst($name); $fname2 = 'is' . ucfirst($name); if (($name != 'setOptions') && method_exists($this, $name)) { $this->{$name}($option); } elseif (($fname != 'setOptions') && method_exists($this, $fname)) { $this->{$fname}($option); } elseif (method_exists($this, $fname2)) { $this->{$fname2}($option); } elseif (isset($this->options)) { $this->options[$name] = $option; } else { $this->abstractOptions[$name] = $option; } } return $this; } public function getMessages() { return array_unique($this->abstractOptions['messages']); } public function __invoke($value) { return $this->isValid($value); } public function getMessageVariables() { return array_keys($this->abstractOptions['messageVariables']); } public function getMessageTemplates() { return $this->abstractOptions['messageTemplates']; } public function setMessage($messageString, $messageKey = null) { if ($messageKey === null) { $keys = array_keys($this->abstractOptions['messageTemplates']); foreach ($keys as $key) { $this->setMessage($messageString, $key); } return $this; } if (!isset($this->abstractOptions['messageTemplates'][$messageKey])) { throw new Exception\InvalidArgumentException("No message template exists for key '$messageKey'"); } $this->abstractOptions['messageTemplates'][$messageKey] = $messageString; return $this; } public function setMessages(array $messages) { foreach ($messages as $key => $message) { $this->setMessage($message, $key); } return $this; } public function __get($property) { if ($property == 'value') { return $this->value; } if (array_key_exists($property, $this->abstractOptions['messageVariables'])) { $result = $this->abstractOptions['messageVariables'][$property]; if (is_array($result)) { $result = $this->{key($result)}[current($result)]; } else { $result = $this->{$result}; } return $result; } if (isset($this->messageVariables) && array_key_exists($property, $this->messageVariables)) { $result = $this->{$this->messageVariables[$property]}; if (is_array($result)) { $result = $this->{key($result)}[current($result)]; } else { $result = $this->{$result}; } return $result; } throw new Exception\InvalidArgumentException("No property exists by the name '$property'"); } protected function createMessage($messageKey, $value) { if (!isset($this->abstractOptions['messageTemplates'][$messageKey])) { return null; } $message = $this->abstractOptions['messageTemplates'][$messageKey]; $message = $this->translateMessage($messageKey, $message); if (is_object($value) && !in_array('__toString', get_class_methods($value)) ) { $value = get_class($value) . ' object'; } elseif (is_array($value)) { $value = var_export($value, 1); } else { $value = (string) $value; } if ($this->isValueObscured()) { $value = str_repeat('*', strlen($value)); } $message = str_replace('%value%', (string) $value, $message); foreach ($this->abstractOptions['messageVariables'] as $ident => $property) { if (is_array($property)) { $value = $this->{key($property)}[current($property)]; if (is_array($value)) { $value = '[' . implode(', ', $value) . ']'; } } else { $value = $this->$property; } $message = str_replace("%$ident%", (string) $value, $message); } $length = self::getMessageLength(); if (($length > -1) && (strlen($message) > $length)) { $message = substr($message, 0, ($length - 3)) . '...'; } return $message; } protected function error($messageKey, $value = null) { if ($messageKey === null) { $keys = array_keys($this->abstractOptions['messageTemplates']); $messageKey = current($keys); } if ($value === null) { $value = $this->value; } $this->abstractOptions['messages'][$messageKey] = $this->createMessage($messageKey, $value); } protected function getValue() { return $this->value; } protected function setValue($value) { $this->value = $value; $this->abstractOptions['messages'] = array(); } public function setValueObscured($flag) { $this->abstractOptions['valueObscured'] = (bool) $flag; return $this; } public function isValueObscured() { return $this->abstractOptions['valueObscured']; } public function setTranslator(Translator\TranslatorInterface $translator = null, $textDomain = null) { $this->abstractOptions['translator'] = $translator; if (null !== $textDomain) { $this->setTranslatorTextDomain($textDomain); } return $this; } public function getTranslator() { if (! $this->isTranslatorEnabled()) { return null; } if (null === $this->abstractOptions['translator']) { $this->abstractOptions['translator'] = self::getDefaultTranslator(); } return $this->abstractOptions['translator']; } public function hasTranslator() { return (bool) $this->abstractOptions['translator']; } public function setTranslatorTextDomain($textDomain = 'default') { $this->abstractOptions['translatorTextDomain'] = $textDomain; return $this; } public function getTranslatorTextDomain() { if (null === $this->abstractOptions['translatorTextDomain']) { $this->abstractOptions['translatorTextDomain'] = self::getDefaultTranslatorTextDomain(); } return $this->abstractOptions['translatorTextDomain']; } public static function setDefaultTranslator( Translator\TranslatorInterface $translator = null, $textDomain = null ) { static::$defaultTranslator = $translator; if (null !== $textDomain) { self::setDefaultTranslatorTextDomain($textDomain); } } public static function getDefaultTranslator() { return static::$defaultTranslator; } public static function hasDefaultTranslator() { return (bool) static::$defaultTranslator; } public static function setDefaultTranslatorTextDomain($textDomain = 'default') { static::$defaultTranslatorTextDomain = $textDomain; } public static function getDefaultTranslatorTextDomain() { return static::$defaultTranslatorTextDomain; } public function setTranslatorEnabled($flag = true) { $this->abstractOptions['translatorEnabled'] = (bool) $flag; return $this; } public function isTranslatorEnabled() { return $this->abstractOptions['translatorEnabled']; } public static function getMessageLength() { return static::$messageLength; } public static function setMessageLength($length = -1) { static::$messageLength = $length; } protected function translateMessage($messageKey, $message) { $translator = $this->getTranslator(); if (!$translator) { return $message; } $translated = $translator->translate( $messageKey, $this->getTranslatorTextDomain() ); if ($translated !== $messageKey) { return $translated; } return $translator->translate( $message, $this->getTranslatorTextDomain() ); } } 
namespace Zend\Validator; use Zend\Stdlib\ErrorHandler; use Zend\Stdlib\StringUtils; class Hostname extends AbstractValidator { const CANNOT_DECODE_PUNYCODE = 'hostnameCannotDecodePunycode'; const INVALID = 'hostnameInvalid'; const INVALID_DASH = 'hostnameDashCharacter'; const INVALID_HOSTNAME = 'hostnameInvalidHostname'; const INVALID_HOSTNAME_SCHEMA = 'hostnameInvalidHostnameSchema'; const INVALID_LOCAL_NAME = 'hostnameInvalidLocalName'; const INVALID_URI = 'hostnameInvalidUri'; const IP_ADDRESS_NOT_ALLOWED = 'hostnameIpAddressNotAllowed'; const LOCAL_NAME_NOT_ALLOWED = 'hostnameLocalNameNotAllowed'; const UNDECIPHERABLE_TLD = 'hostnameUndecipherableTld'; const UNKNOWN_TLD = 'hostnameUnknownTld'; protected $messageTemplates = array( self::CANNOT_DECODE_PUNYCODE => "The input appears to be a DNS hostname but the given punycode notation cannot be decoded", self::INVALID => "Invalid type given. String expected", self::INVALID_DASH => "The input appears to be a DNS hostname but contains a dash in an invalid position", self::INVALID_HOSTNAME => "The input does not match the expected structure for a DNS hostname", self::INVALID_HOSTNAME_SCHEMA => "The input appears to be a DNS hostname but cannot match against hostname schema for TLD '%tld%'", self::INVALID_LOCAL_NAME => "The input does not appear to be a valid local network name", self::INVALID_URI => "The input does not appear to be a valid URI hostname", self::IP_ADDRESS_NOT_ALLOWED => "The input appears to be an IP address, but IP addresses are not allowed", self::LOCAL_NAME_NOT_ALLOWED => "The input appears to be a local network name but local network names are not allowed", self::UNDECIPHERABLE_TLD => "The input appears to be a DNS hostname but cannot extract TLD part", self::UNKNOWN_TLD => "The input appears to be a DNS hostname but cannot match TLD against known list", ); protected $messageVariables = array( 'tld' => 'tld', ); const ALLOW_DNS = 1; const ALLOW_IP = 2; const ALLOW_LOCAL = 4; const ALLOW_URI = 8; const ALLOW_ALL = 15; protected $validTlds = array( 'ac', 'ad', 'ae', 'aero', 'af', 'ag', 'ai', 'al', 'am', 'an', 'ao', 'aq', 'ar', 'arpa', 'as', 'asia', 'at', 'au', 'aw', 'ax', 'az', 'ba', 'bb', 'bd', 'be', 'bf', 'bg', 'bh', 'bi', 'biz', 'bj', 'bm', 'bn', 'bo', 'br', 'bs', 'bt', 'bv', 'bw', 'by', 'bz', 'ca', 'cat', 'cc', 'cd', 'cf', 'cg', 'ch', 'ci', 'ck', 'cl', 'cm', 'cn', 'co', 'com', 'coop', 'cr', 'cu', 'cv', 'cx', 'cy', 'cz', 'de', 'dj', 'dk', 'dm', 'do', 'dz', 'ec', 'edu', 'ee', 'eg', 'er', 'es', 'et', 'eu', 'fi', 'fj', 'fk', 'fm', 'fo', 'fr', 'ga', 'gb', 'gd', 'ge', 'gf', 'gg', 'gh', 'gi', 'gl', 'gm', 'gn', 'gov', 'gp', 'gq', 'gr', 'gs', 'gt', 'gu', 'gw', 'gy', 'hk', 'hm', 'hn', 'hr', 'ht', 'hu', 'id', 'ie', 'il', 'im', 'in', 'info', 'int', 'io', 'iq', 'ir', 'is', 'it', 'je', 'jm', 'jo', 'jobs', 'jp', 'ke', 'kg', 'kh', 'ki', 'km', 'kn', 'kp', 'kr', 'kw', 'ky', 'kz', 'la', 'lb', 'lc', 'li', 'lk', 'lr', 'ls', 'lt', 'lu', 'lv', 'ly', 'ma', 'mc', 'md', 'me', 'mg', 'mh', 'mil', 'mk', 'ml', 'mm', 'mn', 'mo', 'mobi', 'mp', 'mq', 'mr', 'ms', 'mt', 'mu', 'museum', 'mv', 'mw', 'mx', 'my', 'mz', 'na', 'name', 'nc', 'ne', 'net', 'nf', 'ng', 'ni', 'nl', 'no', 'np', 'nr', 'nu', 'nz', 'om', 'org', 'pa', 'pe', 'pf', 'pg', 'ph', 'pk', 'pl', 'pm', 'pn', 'pr', 'pro', 'ps', 'pt', 'pw', 'py', 'qa', 're', 'ro', 'rs', 'ru', 'rw', 'sa', 'sb', 'sc', 'sd', 'se', 'sg', 'sh', 'si', 'sj', 'sk', 'sl', 'sm', 'sn', 'so', 'sr', 'st', 'su', 'sv', 'sy', 'sz', 'tc', 'td', 'tel', 'tf', 'tg', 'th', 'tj', 'tk', 'tl', 'tm', 'tn', 'to', 'tp', 'tr', 'travel', 'tt', 'tv', 'tw', 'tz', 'ua', 'ug', 'uk', 'um', 'us', 'uy', 'uz', 'va', 'vc', 've', 'vg', 'vi', 'vn', 'vu', 'wf', 'ws', 'xxx', 'ye', 'yt', 'yu', 'za', 'zm', 'zw' ); protected $validIdns = array( 'AC' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿāăąćĉċčďđēėęěĝġģĥħīįĵķĺļľŀłńņňŋőœŕŗřśŝşšţťŧūŭůűųŵŷźżž]{1,63}$/iu'), 'AR' => array(1 => '/^[\x{002d}0-9a-zà-ãç-êìíñ-õü]{1,63}$/iu'), 'AS' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿāăąćĉċčďđēĕėęěĝğġģĥħĩīĭįıĵķĸĺļľłńņňŋōŏőœŕŗřśŝşšţťŧũūŭůűųŵŷźż]{1,63}$/iu'), 'AT' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿœšž]{1,63}$/iu'), 'BIZ' => 'Hostname/Biz.php', 'BR' => array(1 => '/^[\x{002d}0-9a-zà-ãçéíó-õúü]{1,63}$/iu'), 'BV' => array(1 => '/^[\x{002d}0-9a-zàáä-éêñ-ôöøüčđńŋšŧž]{1,63}$/iu'), 'CAT' => array(1 => '/^[\x{002d}0-9a-z·àç-éíïòóúü]{1,63}$/iu'), 'CH' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿœ]{1,63}$/iu'), 'CL' => array(1 => '/^[\x{002d}0-9a-záéíñóúü]{1,63}$/iu'), 'CN' => 'Hostname/Cn.php', 'COM' => 'Hostname/Com.php', 'DE' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿăąāćĉčċďđĕěėęēğĝġģĥħĭĩįīıĵķĺľļłńňņŋŏőōœĸŕřŗśŝšşťţŧŭůűũųūŵŷźžż]{1,63}$/iu'), 'DK' => array(1 => '/^[\x{002d}0-9a-zäéöü]{1,63}$/iu'), 'ES' => array(1 => '/^[\x{002d}0-9a-zàáçèéíïñòóúü·]{1,63}$/iu'), 'EU' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿ]{1,63}$/iu', 2 => '/^[\x{002d}0-9a-zāăąćĉċčďđēĕėęěĝğġģĥħĩīĭįıĵķĺļľŀłńņňŉŋōŏőœŕŗřśŝšťŧũūŭůűųŵŷźżž]{1,63}$/iu', 3 => '/^[\x{002d}0-9a-zșț]{1,63}$/iu', 4 => '/^[\x{002d}0-9a-zΐάέήίΰαβγδεζηθικλμνξοπρςστυφχψωϊϋόύώ]{1,63}$/iu', 5 => '/^[\x{002d}0-9a-zабвгдежзийклмнопрстуфхцчшщъыьэюя]{1,63}$/iu', 6 => '/^[\x{002d}0-9a-zἀ-ἇἐ-ἕἠ-ἧἰ-ἷὀ-ὅὐ-ὗὠ-ὧὰ-ὼώᾀ-ᾇᾐ-ᾗᾠ-ᾧᾰ-ᾴᾶᾷῂῃῄῆῇῐ-ῒΐῖῗῠ-ῧῲῳῴῶῷ]{1,63}$/iu'), 'FI' => array(1 => '/^[\x{002d}0-9a-zäåö]{1,63}$/iu'), 'GR' => array(1 => '/^[\x{002d}0-9a-zΆΈΉΊΌΎ-ΡΣ-ώἀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼῂῃῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲῳῴῶ-ῼ]{1,63}$/iu'), 'HK' => 'Hostname/Cn.php', 'HU' => array(1 => '/^[\x{002d}0-9a-záéíóöúüőű]{1,63}$/iu'), 'INFO'=> array(1 => '/^[\x{002d}0-9a-zäåæéöøü]{1,63}$/iu', 2 => '/^[\x{002d}0-9a-záéíóöúüőű]{1,63}$/iu', 3 => '/^[\x{002d}0-9a-záæéíðóöúýþ]{1,63}$/iu', 4 => '/^[\x{AC00}-\x{D7A3}]{1,17}$/iu', 5 => '/^[\x{002d}0-9a-zāčēģīķļņōŗšūž]{1,63}$/iu', 6 => '/^[\x{002d}0-9a-ząčėęįšūųž]{1,63}$/iu', 7 => '/^[\x{002d}0-9a-zóąćęłńśźż]{1,63}$/iu', 8 => '/^[\x{002d}0-9a-záéíñóúü]{1,63}$/iu'), 'IO' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿăąāćĉčċďđĕěėęēğĝġģĥħĭĩįīıĵķĺľļłńňņŋŏőōœĸŕřŗśŝšşťţŧŭůűũųūŵŷźžż]{1,63}$/iu'), 'IS' => array(1 => '/^[\x{002d}0-9a-záéýúíóþæöð]{1,63}$/iu'), 'IT' => array(1 => '/^[\x{002d}0-9a-zàâäèéêëìîïòôöùûüæœçÿß-]{1,63}$/iu'), 'JP' => 'Hostname/Jp.php', 'KR' => array(1 => '/^[\x{AC00}-\x{D7A3}]{1,17}$/iu'), 'LI' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿœ]{1,63}$/iu'), 'LT' => array(1 => '/^[\x{002d}0-9ąčęėįšųūž]{1,63}$/iu'), 'MD' => array(1 => '/^[\x{002d}0-9ăâîşţ]{1,63}$/iu'), 'MUSEUM' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿāăąćċčďđēėęěğġģħīįıķĺļľłńņňŋōőœŕŗřśşšţťŧūůűųŵŷźżžǎǐǒǔ\x{01E5}\x{01E7}\x{01E9}\x{01EF}ə\x{0292}ẁẃẅỳ]{1,63}$/iu'), 'NET' => 'Hostname/Com.php', 'NO' => array(1 => '/^[\x{002d}0-9a-zàáä-éêñ-ôöøüčđńŋšŧž]{1,63}$/iu'), 'NU' => 'Hostname/Com.php', 'ORG' => array(1 => '/^[\x{002d}0-9a-záéíñóúü]{1,63}$/iu', 2 => '/^[\x{002d}0-9a-zóąćęłńśźż]{1,63}$/iu', 3 => '/^[\x{002d}0-9a-záäåæéëíðóöøúüýþ]{1,63}$/iu', 4 => '/^[\x{002d}0-9a-záéíóöúüőű]{1,63}$/iu', 5 => '/^[\x{002d}0-9a-ząčėęįšūųž]{1,63}$/iu', 6 => '/^[\x{AC00}-\x{D7A3}]{1,17}$/iu', 7 => '/^[\x{002d}0-9a-zāčēģīķļņōŗšūž]{1,63}$/iu'), 'PE' => array(1 => '/^[\x{002d}0-9a-zñáéíóúü]{1,63}$/iu'), 'PL' => array(1 => '/^[\x{002d}0-9a-zāčēģīķļņōŗšūž]{1,63}$/iu', 2 => '/^[\x{002d}а-ик-ш\x{0450}ѓѕјљњќџ]{1,63}$/iu', 3 => '/^[\x{002d}0-9a-zâîăşţ]{1,63}$/iu', 4 => '/^[\x{002d}0-9а-яё\x{04C2}]{1,63}$/iu', 5 => '/^[\x{002d}0-9a-zàáâèéêìíîòóôùúûċġħż]{1,63}$/iu', 6 => '/^[\x{002d}0-9a-zàäåæéêòóôöøü]{1,63}$/iu', 7 => '/^[\x{002d}0-9a-zóąćęłńśźż]{1,63}$/iu', 8 => '/^[\x{002d}0-9a-zàáâãçéêíòóôõúü]{1,63}$/iu', 9 => '/^[\x{002d}0-9a-zâîăşţ]{1,63}$/iu', 10=> '/^[\x{002d}0-9a-záäéíóôúýčďĺľňŕšťž]{1,63}$/iu', 11=> '/^[\x{002d}0-9a-zçë]{1,63}$/iu', 12=> '/^[\x{002d}0-9а-ик-шђјљњћџ]{1,63}$/iu', 13=> '/^[\x{002d}0-9a-zćčđšž]{1,63}$/iu', 14=> '/^[\x{002d}0-9a-zâçöûüğış]{1,63}$/iu', 15=> '/^[\x{002d}0-9a-záéíñóúü]{1,63}$/iu', 16=> '/^[\x{002d}0-9a-zäõöüšž]{1,63}$/iu', 17=> '/^[\x{002d}0-9a-zĉĝĥĵŝŭ]{1,63}$/iu', 18=> '/^[\x{002d}0-9a-zâäéëîô]{1,63}$/iu', 19=> '/^[\x{002d}0-9a-zàáâäåæçèéêëìíîïðñòôöøùúûüýćčłńřśš]{1,63}$/iu', 20=> '/^[\x{002d}0-9a-zäåæõöøüšž]{1,63}$/iu', 21=> '/^[\x{002d}0-9a-zàáçèéìíòóùú]{1,63}$/iu', 22=> '/^[\x{002d}0-9a-zàáéíóöúüőű]{1,63}$/iu', 23=> '/^[\x{002d}0-9ΐά-ώ]{1,63}$/iu', 24=> '/^[\x{002d}0-9a-zàáâåæçèéêëðóôöøüþœ]{1,63}$/iu', 25=> '/^[\x{002d}0-9a-záäéíóöúüýčďěňřšťůž]{1,63}$/iu', 26=> '/^[\x{002d}0-9a-z·àçèéíïòóúü]{1,63}$/iu', 27=> '/^[\x{002d}0-9а-ъьюя\x{0450}\x{045D}]{1,63}$/iu', 28=> '/^[\x{002d}0-9а-яёіў]{1,63}$/iu', 29=> '/^[\x{002d}0-9a-ząčėęįšūųž]{1,63}$/iu', 30=> '/^[\x{002d}0-9a-záäåæéëíðóöøúüýþ]{1,63}$/iu', 31=> '/^[\x{002d}0-9a-zàâæçèéêëîïñôùûüÿœ]{1,63}$/iu', 32=> '/^[\x{002d}0-9а-щъыьэюяёєіїґ]{1,63}$/iu', 33=> '/^[\x{002d}0-9א-ת]{1,63}$/iu'), 'PR' => array(1 => '/^[\x{002d}0-9a-záéíóúñäëïüöâêîôûàèùæçœãõ]{1,63}$/iu'), 'PT' => array(1 => '/^[\x{002d}0-9a-záàâãçéêíóôõú]{1,63}$/iu'), 'RU' => array(1 => '/^[\x{002d}0-9а-яё]{1,63}$/iu'), 'SA' => array(1 => '/^[\x{002d}.0-9\x{0621}-\x{063A}\x{0641}-\x{064A}\x{0660}-\x{0669}]{1,63}$/iu'), 'SE' => array(1 => '/^[\x{002d}0-9a-zäåéöü]{1,63}$/iu'), 'SH' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿăąāćĉčċďđĕěėęēğĝġģĥħĭĩįīıĵķĺľļłńňņŋŏőōœĸŕřŗśŝšşťţŧŭůűũųūŵŷźžż]{1,63}$/iu'), 'SI' => array( 1 => '/^[\x{002d}0-9a-zà-öø-ÿ]{1,63}$/iu', 2 => '/^[\x{002d}0-9a-zāăąćĉċčďđēĕėęěĝğġģĥħĩīĭįıĵķĺļľŀłńņňŉŋōŏőœŕŗřśŝšťŧũūŭůűųŵŷźżž]{1,63}$/iu', 3 => '/^[\x{002d}0-9a-zșț]{1,63}$/iu'), 'SJ' => array(1 => '/^[\x{002d}0-9a-zàáä-éêñ-ôöøüčđńŋšŧž]{1,63}$/iu'), 'TH' => array(1 => '/^[\x{002d}0-9a-z\x{0E01}-\x{0E3A}\x{0E40}-\x{0E4D}\x{0E50}-\x{0E59}]{1,63}$/iu'), 'TM' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿāăąćĉċčďđēėęěĝġģĥħīįĵķĺļľŀłńņňŋőœŕŗřśŝşšţťŧūŭůűųŵŷźżž]{1,63}$/iu'), 'TW' => 'Hostname/Cn.php', 'TR' => array(1 => '/^[\x{002d}0-9a-zğıüşöç]{1,63}$/iu'), 'UA' => array(1 => '/^[\x{002d}0-9a-zабвгдежзийклмнопрстуфхцчшщъыьэюяѐёђѓєѕіїјљњћќѝўџґӂʼ]{1,63}$/iu'), 'VE' => array(1 => '/^[\x{002d}0-9a-záéíóúüñ]{1,63}$/iu'), 'VN' => array(1 => '/^[ÀÁÂÃÈÉÊÌÍÒÓÔÕÙÚÝàáâãèéêìíòóôõùúýĂăĐđĨĩŨũƠơƯư\x{1EA0}-\x{1EF9}]{1,63}$/iu'), '中国' => 'Hostname/Cn.php', '中國' => 'Hostname/Cn.php', 'ලංකා' => array(1 => '/^[\x{0d80}-\x{0dff}]{1,63}$/iu'), '香港' => 'Hostname/Cn.php', '台湾' => 'Hostname/Cn.php', '台灣' => 'Hostname/Cn.php', 'امارات' => array(1 => '/^[\x{0621}-\x{0624}\x{0626}-\x{063A}\x{0641}\x{0642}\x{0644}-\x{0648}\x{067E}\x{0686}\x{0698}\x{06A9}\x{06AF}\x{06CC}\x{06F0}-\x{06F9}]{1,30}$/iu'), 'الاردن' => array(1 => '/^[\x{0621}-\x{0624}\x{0626}-\x{063A}\x{0641}\x{0642}\x{0644}-\x{0648}\x{067E}\x{0686}\x{0698}\x{06A9}\x{06AF}\x{06CC}\x{06F0}-\x{06F9}]{1,30}$/iu'), 'السعودية' => array(1 => '/^[\x{0621}-\x{0624}\x{0626}-\x{063A}\x{0641}\x{0642}\x{0644}-\x{0648}\x{067E}\x{0686}\x{0698}\x{06A9}\x{06AF}\x{06CC}\x{06F0}-\x{06F9}]{1,30}$/iu'), 'ไทย' => array(1 => '/^[\x{002d}0-9a-z\x{0E01}-\x{0E3A}\x{0E40}-\x{0E4D}\x{0E50}-\x{0E59}]{1,63}$/iu'), 'рф' => array(1 => '/^[\x{002d}0-9а-яё]{1,63}$/iu'), 'تونس' => array(1 => '/^[\x{0621}-\x{0624}\x{0626}-\x{063A}\x{0641}\x{0642}\x{0644}-\x{0648}\x{067E}\x{0686}\x{0698}\x{06A9}\x{06AF}\x{06CC}\x{06F0}-\x{06F9}]{1,30}$/iu'), 'مصر' => array(1 => '/^[\x{0621}-\x{0624}\x{0626}-\x{063A}\x{0641}\x{0642}\x{0644}-\x{0648}\x{067E}\x{0686}\x{0698}\x{06A9}\x{06AF}\x{06CC}\x{06F0}-\x{06F9}]{1,30}$/iu'), 'இலங்கை' => array(1 => '/^[\x{0b80}-\x{0bff}]{1,63}$/iu'), 'فلسطين' => array(1 => '/^[\x{0621}-\x{0624}\x{0626}-\x{063A}\x{0641}\x{0642}\x{0644}-\x{0648}\x{067E}\x{0686}\x{0698}\x{06A9}\x{06AF}\x{06CC}\x{06F0}-\x{06F9}]{1,30}$/iu'), ); protected $idnLength = array( 'BIZ' => array(5 => 17, 11 => 15, 12 => 20), 'CN' => array(1 => 20), 'COM' => array(3 => 17, 5 => 20), 'HK' => array(1 => 15), 'INFO'=> array(4 => 17), 'KR' => array(1 => 17), 'NET' => array(3 => 17, 5 => 20), 'ORG' => array(6 => 17), 'TW' => array(1 => 20), 'امارات' => array(1 => 30), 'الاردن' => array(1 => 30), 'السعودية' => array(1 => 30), 'تونس' => array(1 => 30), 'مصر' => array(1 => 30), 'فلسطين' => array(1 => 30), '中国' => array(1 => 20), '中國' => array(1 => 20), '香港' => array(1 => 20), '台湾' => array(1 => 20), '台灣' => array(1 => 20), ); protected $tld; protected $options = array( 'allow' => self::ALLOW_DNS, 'useIdnCheck' => true, 'useTldCheck' => true, 'ipValidator' => null, ); public function __construct($options = array()) { if (!is_array($options)) { $options = func_get_args(); $temp['allow'] = array_shift($options); if (!empty($options)) { $temp['useIdnCheck'] = array_shift($options); } if (!empty($options)) { $temp['useTldCheck'] = array_shift($options); } if (!empty($options)) { $temp['ipValidator'] = array_shift($options); } $options = $temp; } if (!array_key_exists('ipValidator', $options)) { $options['ipValidator'] = null; } parent::__construct($options); } public function getIpValidator() { return $this->options['ipValidator']; } public function setIpValidator(Ip $ipValidator = null) { if ($ipValidator === null) { $ipValidator = new Ip(); } $this->options['ipValidator'] = $ipValidator; return $this; } public function getAllow() { return $this->options['allow']; } public function setAllow($allow) { $this->options['allow'] = $allow; return $this; } public function getIdnCheck() { return $this->options['useIdnCheck']; } public function useIdnCheck($useIdnCheck) { $this->options['useIdnCheck'] = (bool) $useIdnCheck; return $this; } public function getTldCheck() { return $this->options['useTldCheck']; } public function useTldCheck($useTldCheck) { $this->options['useTldCheck'] = (bool) $useTldCheck; return $this; } public function isValid($value) { if (!is_string($value)) { $this->error(self::INVALID); return false; } $this->setValue($value); if (preg_match('/^[0-9a-f:.]*$/i', $value) && $this->getIpValidator()->setTranslator($this->getTranslator())->isValid($value)) { if (!($this->getAllow() & self::ALLOW_IP)) { $this->error(self::IP_ADDRESS_NOT_ALLOWED); return false; } else { return true; } } if ($this->getAllow() & self::ALLOW_LOCAL) { if (substr($value, -1) === '.') { $value = substr($value, 0, -1); if (substr($value, -1) === '.') { $this->error(self::INVALID_LOCAL_NAME); return false; } } } $domainParts = explode('.', $value); if ((count($domainParts) == 4) && preg_match('/^[0-9.a-e:.]*$/i', $value) && $this->getIpValidator()->setTranslator($this->getTranslator())->isValid($value)) { $this->error(self::INVALID_LOCAL_NAME); } if ((count($domainParts) > 1) && (strlen($value) >= 4) && (strlen($value) <= 254)) { $utf8StrWrapper = StringUtils::getWrapper('UTF-8'); $status = false; do { $matches = array(); if (preg_match('/([^.]{2,10})$/i', end($domainParts), $matches) || (array_key_exists(end($domainParts), $this->validIdns))) { reset($domainParts); $this->tld = strtolower($matches[1]); if ($this->getTldCheck()) { if (!in_array($this->tld, $this->validTlds)) { $this->error(self::UNKNOWN_TLD); $status = false; break; } } $regexChars = array(0 => '/^[a-z0-9\x2d]{1,63}$/i'); if ($this->getIdnCheck() && isset($this->validIdns[strtoupper($this->tld)])) { if (is_string($this->validIdns[strtoupper($this->tld)])) { $regexChars += include 'D:/EtahWebServer/htdocs/FastZF2-master/vendor/ZF2/library/Zend/Validator' .'/'. $this->validIdns[strtoupper($this->tld)]; } else { $regexChars += $this->validIdns[strtoupper($this->tld)]; } } $check = 0; foreach ($domainParts as $domainPart) { if (strpos($domainPart, 'xn--') === 0) { $domainPart = $this->decodePunycode(substr($domainPart, 4)); if ($domainPart === false) { return false; } } if ((strpos($domainPart, '-') === 0) || ((strlen($domainPart) > 2) && (strpos($domainPart, '-', 2) == 2) && (strpos($domainPart, '-', 3) == 3)) || (strpos($domainPart, '-') === (strlen($domainPart) - 1))) { $this->error(self::INVALID_DASH); $status = false; break 2; } $checked = false; foreach ($regexChars as $regexKey => $regexChar) { ErrorHandler::start(); $status = preg_match($regexChar, $domainPart); ErrorHandler::stop(); if ($status > 0) { $length = 63; if (array_key_exists(strtoupper($this->tld), $this->idnLength) && (array_key_exists($regexKey, $this->idnLength[strtoupper($this->tld)]))) { $length = $this->idnLength[strtoupper($this->tld)]; } if ($utf8StrWrapper->strlen($domainPart) > $length) { $this->error(self::INVALID_HOSTNAME); } else { $checked = true; break; } } } if ($checked) { ++$check; } } if ($check !== count($domainParts)) { $this->error(self::INVALID_HOSTNAME_SCHEMA); $status = false; } } else { $this->error(self::UNDECIPHERABLE_TLD); $status = false; } } while (false); if ($status && ($this->getAllow() & self::ALLOW_DNS)) { return true; } } elseif ($this->getAllow() & self::ALLOW_DNS) { $this->error(self::INVALID_HOSTNAME); } if ($this->getAllow() & self::ALLOW_URI) { if (preg_match("/^([a-zA-Z0-9-._~!$&\'()*+,;=]|%[[:xdigit:]]{2}){1,254}$/i", $value)) { return true; } else { $this->error(self::INVALID_URI); } } ErrorHandler::start(); $regexLocal = '/^(([a-zA-Z0-9\x2d]{1,63}\x2e)*[a-zA-Z0-9\x2d]{1,63}[\x2e]{0,1}){1,254}$/'; $status = preg_match($regexLocal, $value); ErrorHandler::stop(); $allowLocal = $this->getAllow() & self::ALLOW_LOCAL; if ($status && $allowLocal) { return true; } if (!$status) { $this->error(self::INVALID_LOCAL_NAME); } if ($status && !$allowLocal) { $this->error(self::LOCAL_NAME_NOT_ALLOWED); } return false; } protected function decodePunycode($encoded) { if (!preg_match('/^[a-z0-9-]+$/i', $encoded)) { $this->error(self::CANNOT_DECODE_PUNYCODE); return false; } $decoded = array(); $separator = strrpos($encoded, '-'); if ($separator > 0) { for ($x = 0; $x < $separator; ++$x) { $decoded[] = ord($encoded[$x]); } } $lengthd = count($decoded); $lengthe = strlen($encoded); $init = true; $base = 72; $index = 0; $char = 0x80; for ($indexe = ($separator) ? ($separator + 1) : 0; $indexe < $lengthe; ++$lengthd) { for ($oldIndex = $index, $pos = 1, $key = 36; 1; $key += 36) { $hex = ord($encoded[$indexe++]); $digit = ($hex - 48 < 10) ? $hex - 22 : (($hex - 65 < 26) ? $hex - 65 : (($hex - 97 < 26) ? $hex - 97 : 36)); $index += $digit * $pos; $tag = ($key <= $base) ? 1 : (($key >= $base + 26) ? 26 : ($key - $base)); if ($digit < $tag) { break; } $pos = (int) ($pos * (36 - $tag)); } $delta = intval($init ? (($index - $oldIndex) / 700) : (($index - $oldIndex) / 2)); $delta += intval($delta / ($lengthd + 1)); for ($key = 0; $delta > 910 / 2; $key += 36) { $delta = intval($delta / 35); } $base = intval($key + 36 * $delta / ($delta + 38)); $init = false; $char += (int) ($index / ($lengthd + 1)); $index %= ($lengthd + 1); if ($lengthd > 0) { for ($i = $lengthd; $i > $index; $i--) { $decoded[$i] = $decoded[($i - 1)]; } } $decoded[$index++] = $char; } foreach ($decoded as $key => $value) { if ($value < 128) { $decoded[$key] = chr($value); } elseif ($value < (1 << 11)) { $decoded[$key] = chr(192 + ($value >> 6)); $decoded[$key] .= chr(128 + ($value & 63)); } elseif ($value < (1 << 16)) { $decoded[$key] = chr(224 + ($value >> 12)); $decoded[$key] .= chr(128 + (($value >> 6) & 63)); $decoded[$key] .= chr(128 + ($value & 63)); } elseif ($value < (1 << 21)) { $decoded[$key] = chr(240 + ($value >> 18)); $decoded[$key] .= chr(128 + (($value >> 12) & 63)); $decoded[$key] .= chr(128 + (($value >> 6) & 63)); $decoded[$key] .= chr(128 + ($value & 63)); } else { $this->error(self::CANNOT_DECODE_PUNYCODE); return false; } } return implode($decoded); } } 
namespace Zend\Validator; use Traversable; class Ip extends AbstractValidator { const INVALID = 'ipInvalid'; const NOT_IP_ADDRESS = 'notIpAddress'; protected $messageTemplates = array( self::INVALID => 'Invalid type given. String expected', self::NOT_IP_ADDRESS => "The input does not appear to be a valid IP address", ); protected $options = array( 'allowipv4' => true, 'allowipv6' => true, 'allowipvfuture' => false, 'allowliteral' => true, ); public function setOptions($options = array()) { parent::setOptions($options); if (!$this->options['allowipv4'] && !$this->options['allowipv6'] && !$this->options['allowipvfuture']) { throw new Exception\InvalidArgumentException('Nothing to validate. Check your options'); } return $this; } public function isValid($value) { if (!is_string($value)) { $this->error(self::INVALID); return false; } $this->setValue($value); if ($this->options['allowipv4'] && $this->validateIPv4($value)) { return true; } else { if ((bool) $this->options['allowliteral']) { static $regex = '/^\[(.*)\]$/'; if ((bool) preg_match($regex, $value, $matches)) { $value = $matches[1]; } } if (($this->options['allowipv6'] && $this->validateIPv6($value)) || ($this->options['allowipvfuture'] && $this->validateIPvFuture($value)) ) { return true; } } $this->error(self::NOT_IP_ADDRESS); return false; } protected function validateIPv4($value) { if (preg_match('/^([01]{8}.){3}[01]{8}$/i', $value)) { $value = bindec(substr($value, 0, 8)) . '.' . bindec(substr($value, 9, 8)) . '.' . bindec(substr($value, 18, 8)) . '.' . bindec(substr($value, 27, 8)); } elseif (preg_match('/^([0-9]{3}.){3}[0-9]{3}$/i', $value)) { $value = (int) substr($value, 0, 3) . '.' . (int) substr($value, 4, 3) . '.' . (int) substr($value, 8, 3) . '.' . (int) substr($value, 12, 3); } elseif (preg_match('/^([0-9a-f]{2}.){3}[0-9a-f]{2}$/i', $value)) { $value = hexdec(substr($value, 0, 2)) . '.' . hexdec(substr($value, 3, 2)) . '.' . hexdec(substr($value, 6, 2)) . '.' . hexdec(substr($value, 9, 2)); } $ip2long = ip2long($value); if ($ip2long === false) { return false; } return ($value == long2ip($ip2long)); } protected function validateIPv6($value) { if (strlen($value) < 3) { return $value == '::'; } if (strpos($value, '.')) { $lastcolon = strrpos($value, ':'); if (!($lastcolon && $this->validateIPv4(substr($value, $lastcolon + 1)))) { return false; } $value = substr($value, 0, $lastcolon) . ':0:0'; } if (strpos($value, '::') === false) { return preg_match('/\A(?:[a-f0-9]{1,4}:){7}[a-f0-9]{1,4}\z/i', $value); } $colonCount = substr_count($value, ':'); if ($colonCount < 8) { return preg_match('/\A(?::|(?:[a-f0-9]{1,4}:)+):(?:(?:[a-f0-9]{1,4}:)*[a-f0-9]{1,4})?\z/i', $value); } if ($colonCount == 8) { return preg_match('/\A(?:::)?(?:[a-f0-9]{1,4}:){6}[a-f0-9]{1,4}(?:::)?\z/i', $value); } return false; } protected function validateIPvFuture($value) { static $regex = '/^v([[:xdigit:]]+)\.[[:alnum:]\-\._~!\$&\'\(\)\*\+,;=:]+$/'; $result = (bool) preg_match($regex, $value, $matches); return ($result && $matches[1] != 4 && $matches[1] != 6); } } 
namespace Zend\Mvc\Service; use Zend\Console\Console; use Zend\Console\Response as ConsoleResponse; use Zend\Http\PhpEnvironment\Response as HttpResponse; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class ResponseFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { if (Console::isConsole()) { return new ConsoleResponse(); } return new HttpResponse(); } } 
namespace Zend\Stdlib; interface ResponseInterface extends MessageInterface { } 
namespace Zend\Http; use Zend\Stdlib\ErrorHandler; use Zend\Stdlib\ResponseInterface; class Response extends AbstractMessage implements ResponseInterface { const STATUS_CODE_CUSTOM = 0; const STATUS_CODE_100 = 100; const STATUS_CODE_101 = 101; const STATUS_CODE_102 = 102; const STATUS_CODE_200 = 200; const STATUS_CODE_201 = 201; const STATUS_CODE_202 = 202; const STATUS_CODE_203 = 203; const STATUS_CODE_204 = 204; const STATUS_CODE_205 = 205; const STATUS_CODE_206 = 206; const STATUS_CODE_207 = 207; const STATUS_CODE_208 = 208; const STATUS_CODE_300 = 300; const STATUS_CODE_301 = 301; const STATUS_CODE_302 = 302; const STATUS_CODE_303 = 303; const STATUS_CODE_304 = 304; const STATUS_CODE_305 = 305; const STATUS_CODE_306 = 306; const STATUS_CODE_307 = 307; const STATUS_CODE_400 = 400; const STATUS_CODE_401 = 401; const STATUS_CODE_402 = 402; const STATUS_CODE_403 = 403; const STATUS_CODE_404 = 404; const STATUS_CODE_405 = 405; const STATUS_CODE_406 = 406; const STATUS_CODE_407 = 407; const STATUS_CODE_408 = 408; const STATUS_CODE_409 = 409; const STATUS_CODE_410 = 410; const STATUS_CODE_411 = 411; const STATUS_CODE_412 = 412; const STATUS_CODE_413 = 413; const STATUS_CODE_414 = 414; const STATUS_CODE_415 = 415; const STATUS_CODE_416 = 416; const STATUS_CODE_417 = 417; const STATUS_CODE_418 = 418; const STATUS_CODE_422 = 422; const STATUS_CODE_423 = 423; const STATUS_CODE_424 = 424; const STATUS_CODE_425 = 425; const STATUS_CODE_426 = 426; const STATUS_CODE_428 = 428; const STATUS_CODE_429 = 429; const STATUS_CODE_431 = 431; const STATUS_CODE_500 = 500; const STATUS_CODE_501 = 501; const STATUS_CODE_502 = 502; const STATUS_CODE_503 = 503; const STATUS_CODE_504 = 504; const STATUS_CODE_505 = 505; const STATUS_CODE_506 = 506; const STATUS_CODE_507 = 507; const STATUS_CODE_508 = 508; const STATUS_CODE_511 = 511; protected $recommendedReasonPhrases = array( 100 => 'Continue', 101 => 'Switching Protocols', 102 => 'Processing', 200 => 'OK', 201 => 'Created', 202 => 'Accepted', 203 => 'Non-Authoritative Information', 204 => 'No Content', 205 => 'Reset Content', 206 => 'Partial Content', 207 => 'Multi-status', 208 => 'Already Reported', 300 => 'Multiple Choices', 301 => 'Moved Permanently', 302 => 'Found', 303 => 'See Other', 304 => 'Not Modified', 305 => 'Use Proxy', 306 => 'Switch Proxy', 307 => 'Temporary Redirect', 400 => 'Bad Request', 401 => 'Unauthorized', 402 => 'Payment Required', 403 => 'Forbidden', 404 => 'Not Found', 405 => 'Method Not Allowed', 406 => 'Not Acceptable', 407 => 'Proxy Authentication Required', 408 => 'Request Time-out', 409 => 'Conflict', 410 => 'Gone', 411 => 'Length Required', 412 => 'Precondition Failed', 413 => 'Request Entity Too Large', 414 => 'Request-URI Too Large', 415 => 'Unsupported Media Type', 416 => 'Requested range not satisfiable', 417 => 'Expectation Failed', 418 => 'I\'m a teapot', 422 => 'Unprocessable Entity', 423 => 'Locked', 424 => 'Failed Dependency', 425 => 'Unordered Collection', 426 => 'Upgrade Required', 428 => 'Precondition Required', 429 => 'Too Many Requests', 431 => 'Request Header Fields Too Large', 500 => 'Internal Server Error', 501 => 'Not Implemented', 502 => 'Bad Gateway', 503 => 'Service Unavailable', 504 => 'Gateway Time-out', 505 => 'HTTP Version not supported', 506 => 'Variant Also Negotiates', 507 => 'Insufficient Storage', 508 => 'Loop Detected', 511 => 'Network Authentication Required', ); protected $statusCode = 200; protected $reasonPhrase = null; public static function fromString($string) { $lines = explode("\r\n", $string); if (!is_array($lines) || count($lines) == 1) { $lines = explode("\n", $string); } $firstLine = array_shift($lines); $response = new static(); $regex = '/^HTTP\/(?P<version>1\.[01]) (?P<status>\d{3})(?:[ ]+(?P<reason>.*))?$/'; $matches = array(); if (!preg_match($regex, $firstLine, $matches)) { throw new Exception\InvalidArgumentException( 'A valid response status line was not found in the provided string' ); } $response->version = $matches['version']; $response->setStatusCode($matches['status']); $response->setReasonPhrase((isset($matches['reason']) ? $matches['reason'] : '')); if (count($lines) == 0) { return $response; } $isHeader = true; $headers = $content = array(); while ($lines) { $nextLine = array_shift($lines); if ($isHeader && $nextLine == '') { $isHeader = false; continue; } if ($isHeader) { $headers[] = $nextLine; } else { $content[] = $nextLine; } } if ($headers) { $response->headers = implode("\r\n", $headers); } if ($content) { $response->setContent(implode("\r\n", $content)); } return $response; } public function getCookie() { return $this->getHeaders()->get('Set-Cookie'); } public function setStatusCode($code) { if (!is_numeric($code)) { $code = is_scalar($code) ? $code : gettype($code); throw new Exception\InvalidArgumentException(sprintf( 'Invalid status code provided: "%s"', $code )); } $this->statusCode = (int) $code; return $this; } public function getStatusCode() { return $this->statusCode; } public function setReasonPhrase($reasonPhrase) { $this->reasonPhrase = trim($reasonPhrase); return $this; } public function getReasonPhrase() { if ($this->reasonPhrase == null) { return $this->recommendedReasonPhrases[$this->statusCode]; } return $this->reasonPhrase; } public function getBody() { $body = (string) $this->getContent(); $transferEncoding = $this->getHeaders()->get('Transfer-Encoding'); if (!empty($transferEncoding)) { if (strtolower($transferEncoding->getFieldValue()) == 'chunked') { $body = $this->decodeChunkedBody($body); } } $contentEncoding = $this->getHeaders()->get('Content-Encoding'); if (!empty($contentEncoding)) { $contentEncoding = $contentEncoding->getFieldValue(); if ($contentEncoding =='gzip') { $body = $this->decodeGzip($body); } elseif ($contentEncoding == 'deflate') { $body = $this->decodeDeflate($body); } } return $body; } public function isClientError() { $code = $this->getStatusCode(); return ($code < 500 && $code >= 400); } public function isForbidden() { return (403 == $this->getStatusCode()); } public function isInformational() { $code = $this->getStatusCode(); return ($code >= 100 && $code < 200); } public function isNotFound() { return (404 === $this->getStatusCode()); } public function isOk() { return (200 === $this->getStatusCode()); } public function isServerError() { $code = $this->getStatusCode(); return (500 <= $code && 600 > $code); } public function isRedirect() { $code = $this->getStatusCode(); return (300 <= $code && 400 > $code); } public function isSuccess() { $code = $this->getStatusCode(); return (200 <= $code && 300 > $code); } public function renderStatusLine() { $status = sprintf( 'HTTP/%s %d %s', $this->getVersion(), $this->getStatusCode(), $this->getReasonPhrase() ); return trim($status); } public function toString() { $str = $this->renderStatusLine() . "\r\n"; $str .= $this->getHeaders()->toString(); $str .= "\r\n"; $str .= $this->getContent(); return $str; } protected function decodeChunkedBody($body) { $decBody = ''; while (trim($body)) { if (! preg_match("/^([\da-fA-F]+)[^\r\n]*\r\n/sm", $body, $m)) { throw new Exception\RuntimeException( "Error parsing body - doesn't seem to be a chunked message" ); } $length = hexdec(trim($m[1])); $cut = strlen($m[0]); $decBody .= substr($body, $cut, $length); $body = substr($body, $cut + $length + 2); } return $decBody; } protected function decodeGzip($body) { if (!function_exists('gzinflate')) { throw new Exception\RuntimeException( 'zlib extension is required in order to decode "gzip" encoding' ); } ErrorHandler::start(); $return = gzinflate(substr($body, 10)); $test = ErrorHandler::stop(); if ($test) { throw new Exception\RuntimeException( 'Error occurred during gzip inflation', 0, $test ); } return $return; } protected function decodeDeflate($body) { if (!function_exists('gzuncompress')) { throw new Exception\RuntimeException( 'zlib extension is required in order to decode "deflate" encoding' ); } $zlibHeader = unpack('n', substr($body, 0, 2)); if ($zlibHeader[1] % 31 == 0) { return gzuncompress($body); } return gzinflate($body); } } 
namespace Zend\Http\PhpEnvironment; use Zend\Http\Header\MultipleHeaderInterface; use Zend\Http\Response as HttpResponse; class Response extends HttpResponse { protected $version; protected $contentSent = false; public function getVersion() { if (!$this->version) { $this->version = $this->detectVersion(); } return $this->version; } protected function detectVersion() { if (isset($_SERVER['SERVER_PROTOCOL']) && $_SERVER['SERVER_PROTOCOL'] == 'HTTP/1.1') { return self::VERSION_11; } return self::VERSION_10; } public function headersSent() { return headers_sent(); } public function contentSent() { return $this->contentSent; } public function sendHeaders() { if ($this->headersSent()) { return $this; } $status = $this->renderStatusLine(); header($status); foreach ($this->getHeaders() as $header) { if ($header instanceof MultipleHeaderInterface) { header($header->toString(), false); continue; } header($header->toString()); } $this->headersSent = true; return $this; } public function sendContent() { if ($this->contentSent()) { return $this; } echo $this->getContent(); $this->contentSent = true; return $this; } public function send() { $this->sendHeaders() ->sendContent(); return $this; } } 
namespace Zend\Mvc; use Zend\EventManager\EventManagerInterface; use Zend\EventManager\ListenerAggregateInterface; use Zend\Mvc\Application; class RouteListener implements ListenerAggregateInterface { protected $listeners = array(); public function attach(EventManagerInterface $events) { $this->listeners[] = $events->attach(MvcEvent::EVENT_ROUTE, array($this, 'onRoute')); } public function detach(EventManagerInterface $events) { foreach ($this->listeners as $index => $listener) { if ($events->detach($listener)) { unset($this->listeners[$index]); } } } public function onRoute($e) { $target = $e->getTarget(); $request = $e->getRequest(); $router = $e->getRouter(); $routeMatch = $router->match($request); if (!$routeMatch instanceof Router\RouteMatch) { $e->setError(Application::ERROR_ROUTER_NO_MATCH); $results = $target->getEventManager()->trigger(MvcEvent::EVENT_DISPATCH_ERROR, $e); if (count($results)) { $return = $results->last(); } else { $return = $e->getParams(); } return $return; } $e->setRouteMatch($routeMatch); return $routeMatch; } } 
namespace Zend\Mvc; use ArrayObject; use Zend\EventManager\EventManagerInterface; use Zend\EventManager\ListenerAggregateInterface; use Zend\Mvc\Exception\InvalidControllerException; use Zend\Stdlib\ArrayUtils; class DispatchListener implements ListenerAggregateInterface { protected $listeners = array(); public function attach(EventManagerInterface $events) { $this->listeners[] = $events->attach(MvcEvent::EVENT_DISPATCH, array($this, 'onDispatch')); if (function_exists('zend_monitor_custom_event_ex')) { $this->listeners[] = $events->attach(MvcEvent::EVENT_DISPATCH_ERROR, array($this, 'reportMonitorEvent')); } } public function detach(EventManagerInterface $events) { foreach ($this->listeners as $index => $listener) { if ($events->detach($listener)) { unset($this->listeners[$index]); } } } public function onDispatch(MvcEvent $e) { $routeMatch = $e->getRouteMatch(); $controllerName = $routeMatch->getParam('controller', 'not-found'); $application = $e->getApplication(); $events = $application->getEventManager(); $controllerLoader = $application->getServiceManager()->get('ControllerLoader'); if (!$controllerLoader->has($controllerName)) { $return = $this->marshallControllerNotFoundEvent($application::ERROR_CONTROLLER_NOT_FOUND, $controllerName, $e, $application); return $this->complete($return, $e); } try { $controller = $controllerLoader->get($controllerName); } catch (InvalidControllerException $exception) { $return = $this->marshallControllerNotFoundEvent($application::ERROR_CONTROLLER_INVALID, $controllerName, $e, $application, $exception); return $this->complete($return, $e); } catch (\Exception $exception) { $return = $this->marshallBadControllerEvent($controllerName, $e, $application, $exception); return $this->complete($return, $e); } $request = $e->getRequest(); $response = $application->getResponse(); if ($controller instanceof InjectApplicationEventInterface) { $controller->setEvent($e); } try { $return = $controller->dispatch($request, $response); } catch (\Exception $ex) { $e->setError($application::ERROR_EXCEPTION) ->setController($controllerName) ->setControllerClass(get_class($controller)) ->setParam('exception', $ex); $results = $events->trigger(MvcEvent::EVENT_DISPATCH_ERROR, $e); $return = $results->last(); if (! $return) { $return = $e->getResult(); } } return $this->complete($return, $e); } public function reportMonitorEvent(MvcEvent $e) { $error = $e->getError(); $exception = $e->getParam('exception'); if ($exception instanceof \Exception) { zend_monitor_custom_event_ex($error, $exception->getMessage(), 'Zend Framework Exception', array('code' => $exception->getCode(), 'trace' => $exception->getTraceAsString())); } } protected function complete($return, MvcEvent $event) { if (!is_object($return)) { if (ArrayUtils::hasStringKeys($return)) { $return = new ArrayObject($return, ArrayObject::ARRAY_AS_PROPS); } } $event->setResult($return); return $return; } protected function marshallControllerNotFoundEvent( $type, $controllerName, MvcEvent $event, Application $application, \Exception $exception = null ) { $event->setError($type) ->setController($controllerName) ->setControllerClass('invalid controller class or alias: ' . $controllerName); if ($exception !== null) { $event->setParam('exception', $exception); } $events = $application->getEventManager(); $results = $events->trigger(MvcEvent::EVENT_DISPATCH_ERROR, $event); $return = $results->last(); if (! $return) { $return = $event->getResult(); } return $return; } protected function marshallBadControllerEvent( $controllerName, MvcEvent $event, Application $application, \Exception $exception ) { $event->setError($application::ERROR_EXCEPTION) ->setController($controllerName) ->setParam('exception', $exception); $events = $application->getEventManager(); $results = $events->trigger(MvcEvent::EVENT_DISPATCH_ERROR, $event); $return = $results->last(); if (! $return) { $return = $event->getResult(); } return $return; } } 
namespace Zend\Mvc\Service; use Zend\Console\Console; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; use Zend\Mvc\View\Console\ViewManager as ConsoleViewManager; use Zend\Mvc\View\Http\ViewManager as HttpViewManager; class ViewManagerFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { if (Console::isConsole()) { return $serviceLocator->get('ConsoleViewManager'); } return $serviceLocator->get('HttpViewManager'); } } 
namespace Zend\Mvc\Service; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; use Zend\Mvc\View\Http\ViewManager as HttpViewManager; class HttpViewManagerFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { return new HttpViewManager(); } } 
namespace Zend\EventManager; abstract class AbstractListenerAggregate implements ListenerAggregateInterface { protected $listeners = array(); public function detach(EventManagerInterface $events) { foreach ($this->listeners as $index => $callback) { if ($events->detach($callback)) { unset($this->listeners[$index]); } } } } 
namespace Zend\Mvc\View\Http; use ArrayAccess; use Traversable; use Zend\EventManager\AbstractListenerAggregate; use Zend\EventManager\EventManagerInterface; use Zend\EventManager\ListenerAggregateInterface; use Zend\Mvc\MvcEvent; use Zend\Mvc\View\SendResponseListener; use Zend\ServiceManager\ServiceManager; use Zend\View\HelperPluginManager as ViewHelperManager; use Zend\View\Renderer\PhpRenderer as ViewPhpRenderer; use Zend\View\Resolver as ViewResolver; use Zend\View\Strategy\PhpRendererStrategy; use Zend\View\View; class ViewManager extends AbstractListenerAggregate { protected $config; protected $event; protected $services; protected $exceptionStrategy; protected $helperManager; protected $mvcRenderingStrategy; protected $renderer; protected $rendererStrategy; protected $resolver; protected $routeNotFoundStrategy; protected $view; protected $viewModel; public function attach(EventManagerInterface $events) { $this->listeners[] = $events->attach(MvcEvent::EVENT_BOOTSTRAP, array($this, 'onBootstrap'), 10000); } public function detach(EventManagerInterface $events) { foreach ($this->listeners as $index => $listener) { if ($events->detach($listener)) { unset($this->listeners[$index]); } } } public function onBootstrap($event) { $application = $event->getApplication(); $services = $application->getServiceManager(); $config = $services->get('Config'); $events = $application->getEventManager(); $sharedEvents = $events->getSharedManager(); $this->config = isset($config['view_manager']) && (is_array($config['view_manager']) || $config['view_manager'] instanceof ArrayAccess) ? $config['view_manager'] : array(); $this->services = $services; $this->event = $event; $routeNotFoundStrategy = $this->getRouteNotFoundStrategy(); $exceptionStrategy = $this->getExceptionStrategy(); $mvcRenderingStrategy = $this->getMvcRenderingStrategy(); $createViewModelListener = new CreateViewModelListener(); $injectTemplateListener = new InjectTemplateListener(); $injectViewModelListener = new InjectViewModelListener(); $this->registerMvcRenderingStrategies($events); $this->registerViewStrategies(); $events->attach($routeNotFoundStrategy); $events->attach($exceptionStrategy); $events->attach(MvcEvent::EVENT_DISPATCH_ERROR, array($injectViewModelListener, 'injectViewModel'), -100); $events->attach(MvcEvent::EVENT_RENDER_ERROR, array($injectViewModelListener, 'injectViewModel'), -100); $events->attach($mvcRenderingStrategy); $sharedEvents->attach('Zend\Stdlib\DispatchableInterface', MvcEvent::EVENT_DISPATCH, array($createViewModelListener, 'createViewModelFromArray'), -80); $sharedEvents->attach('Zend\Stdlib\DispatchableInterface', MvcEvent::EVENT_DISPATCH, array($routeNotFoundStrategy, 'prepareNotFoundViewModel'), -90); $sharedEvents->attach('Zend\Stdlib\DispatchableInterface', MvcEvent::EVENT_DISPATCH, array($createViewModelListener, 'createViewModelFromNull'), -80); $sharedEvents->attach('Zend\Stdlib\DispatchableInterface', MvcEvent::EVENT_DISPATCH, array($injectTemplateListener, 'injectTemplate'), -90); $sharedEvents->attach('Zend\Stdlib\DispatchableInterface', MvcEvent::EVENT_DISPATCH, array($injectViewModelListener, 'injectViewModel'), -100); } public function getHelperManager() { if ($this->helperManager) { return $this->helperManager; } return $this->helperManager = $this->services->get('ViewHelperManager'); } public function getResolver() { if (null === $this->resolver) { $this->resolver = $this->services->get('ViewResolver'); } return $this->resolver; } public function getRenderer() { if ($this->renderer) { return $this->renderer; } $this->renderer = new ViewPhpRenderer; $this->renderer->setHelperPluginManager($this->getHelperManager()); $this->renderer->setResolver($this->getResolver()); $model = $this->getViewModel(); $modelHelper = $this->renderer->plugin('view_model'); $modelHelper->setRoot($model); $this->services->setService('ViewRenderer', $this->renderer); $this->services->setAlias('Zend\View\Renderer\PhpRenderer', 'ViewRenderer'); $this->services->setAlias('Zend\View\Renderer\RendererInterface', 'ViewRenderer'); return $this->renderer; } public function getRendererStrategy() { if ($this->rendererStrategy) { return $this->rendererStrategy; } $this->rendererStrategy = new PhpRendererStrategy( $this->getRenderer() ); $this->services->setService('ViewPhpRendererStrategy', $this->rendererStrategy); $this->services->setAlias('Zend\View\Strategy\PhpRendererStrategy', 'ViewPhpRendererStrategy'); return $this->rendererStrategy; } public function getView() { if ($this->view) { return $this->view; } $this->view = new View(); $this->view->setEventManager($this->services->get('EventManager')); $this->view->getEventManager()->attach($this->getRendererStrategy()); $this->services->setService('View', $this->view); $this->services->setAlias('Zend\View\View', 'View'); return $this->view; } public function getLayoutTemplate() { $layout = 'layout/layout'; if (isset($this->config['layout'])) { $layout = $this->config['layout']; } return $layout; } public function getMvcRenderingStrategy() { if ($this->mvcRenderingStrategy) { return $this->mvcRenderingStrategy; } $this->mvcRenderingStrategy = new DefaultRenderingStrategy($this->getView()); $this->mvcRenderingStrategy->setLayoutTemplate($this->getLayoutTemplate()); $this->services->setService('DefaultRenderingStrategy', $this->mvcRenderingStrategy); $this->services->setAlias('Zend\Mvc\View\DefaultRenderingStrategy', 'DefaultRenderingStrategy'); $this->services->setAlias('Zend\Mvc\View\Http\DefaultRenderingStrategy', 'DefaultRenderingStrategy'); return $this->mvcRenderingStrategy; } public function getExceptionStrategy() { if ($this->exceptionStrategy) { return $this->exceptionStrategy; } $this->exceptionStrategy = new ExceptionStrategy(); $displayExceptions = false; $exceptionTemplate = 'error'; if (isset($this->config['display_exceptions'])) { $displayExceptions = $this->config['display_exceptions']; } if (isset($this->config['exception_template'])) { $exceptionTemplate = $this->config['exception_template']; } $this->exceptionStrategy->setDisplayExceptions($displayExceptions); $this->exceptionStrategy->setExceptionTemplate($exceptionTemplate); $this->services->setService('ExceptionStrategy', $this->exceptionStrategy); $this->services->setAlias('Zend\Mvc\View\ExceptionStrategy', 'ExceptionStrategy'); $this->services->setAlias('Zend\Mvc\View\Http\ExceptionStrategy', 'ExceptionStrategy'); return $this->exceptionStrategy; } public function getRouteNotFoundStrategy() { if ($this->routeNotFoundStrategy) { return $this->routeNotFoundStrategy; } $this->routeNotFoundStrategy = new RouteNotFoundStrategy(); $displayExceptions = false; $displayNotFoundReason = false; $notFoundTemplate = '404'; if (isset($this->config['display_exceptions'])) { $displayExceptions = $this->config['display_exceptions']; } if (isset($this->config['display_not_found_reason'])) { $displayNotFoundReason = $this->config['display_not_found_reason']; } if (isset($this->config['not_found_template'])) { $notFoundTemplate = $this->config['not_found_template']; } $this->routeNotFoundStrategy->setDisplayExceptions($displayExceptions); $this->routeNotFoundStrategy->setDisplayNotFoundReason($displayNotFoundReason); $this->routeNotFoundStrategy->setNotFoundTemplate($notFoundTemplate); $this->services->setService('RouteNotFoundStrategy', $this->routeNotFoundStrategy); $this->services->setAlias('Zend\Mvc\View\RouteNotFoundStrategy', 'RouteNotFoundStrategy'); $this->services->setAlias('Zend\Mvc\View\Http\RouteNotFoundStrategy', 'RouteNotFoundStrategy'); $this->services->setAlias('404Strategy', 'RouteNotFoundStrategy'); return $this->routeNotFoundStrategy; } public function getViewModel() { if ($this->viewModel) { return $this->viewModel; } $this->viewModel = $model = $this->event->getViewModel(); $model->setTemplate($this->getLayoutTemplate()); return $this->viewModel; } protected function registerMvcRenderingStrategies(EventManagerInterface $events) { if (!isset($this->config['mvc_strategies'])) { return; } $mvcStrategies = $this->config['mvc_strategies']; if (is_string($mvcStrategies)) { $mvcStrategies = array($mvcStrategies); } if (!is_array($mvcStrategies) && !$mvcStrategies instanceof Traversable) { return; } foreach ($mvcStrategies as $mvcStrategy) { if (!is_string($mvcStrategy)) { continue; } $listener = $this->services->get($mvcStrategy); if ($listener instanceof ListenerAggregateInterface) { $events->attach($listener, 100); } } } protected function registerViewStrategies() { if (!isset($this->config['strategies'])) { return; } $strategies = $this->config['strategies']; if (is_string($strategies)) { $strategies = array($strategies); } if (!is_array($strategies) && !$strategies instanceof Traversable) { return; } $view = $this->getView(); foreach ($strategies as $strategy) { if (!is_string($strategy)) { continue; } $listener = $this->services->get($strategy); if ($listener instanceof ListenerAggregateInterface) { $view->getEventManager()->attach($listener, 100); } } } } 
namespace Zend\Mvc; use Zend\EventManager\EventManager; use Zend\EventManager\EventManagerAwareInterface; use Zend\EventManager\EventManagerInterface; use Zend\EventManager\ListenerAggregateInterface; use Zend\Mvc\MvcEvent; use Zend\Mvc\ResponseSender\ConsoleResponseSender; use Zend\Mvc\ResponseSender\HttpResponseSender; use Zend\Mvc\ResponseSender\PhpEnvironmentResponseSender; use Zend\Mvc\ResponseSender\SendResponseEvent; use Zend\Mvc\ResponseSender\SimpleStreamResponseSender; use Zend\Stdlib\ResponseInterface as Response; class SendResponseListener implements EventManagerAwareInterface, ListenerAggregateInterface { protected $listeners = array(); protected $event; protected $eventManager; public function setEventManager(EventManagerInterface $eventManager) { $eventManager->setIdentifiers(array( __CLASS__, get_class($this), )); $this->eventManager = $eventManager; $this->attachDefaultListeners(); return $this; } public function getEventManager() { if (!$this->eventManager instanceof EventManagerInterface) { $this->setEventManager(new EventManager()); } return $this->eventManager; } public function attach(EventManagerInterface $events) { $this->listeners[] = $events->attach(MvcEvent::EVENT_FINISH, array($this, 'sendResponse'), -10000); } public function detach(EventManagerInterface $events) { foreach ($this->listeners as $index => $listener) { if ($events->detach($listener)) { unset($this->listeners[$index]); } } } public function sendResponse(MvcEvent $e) { $response = $e->getResponse(); if (!$response instanceof Response) { return; } $event = $this->getEvent(); $event->setResponse($response); $event->setTarget($this); $this->getEventManager()->trigger($event); } public function getEvent() { if (!$this->event instanceof SendResponseEvent) { $this->setEvent(new SendResponseEvent()); } return $this->event; } public function setEvent(SendResponseEvent $e) { $this->event = $e; return $this; } protected function attachDefaultListeners() { $events = $this->getEventManager(); $events->attach(SendResponseEvent::EVENT_SEND_RESPONSE, new PhpEnvironmentResponseSender(), -1000); $events->attach(SendResponseEvent::EVENT_SEND_RESPONSE, new ConsoleResponseSender(), -2000); $events->attach(SendResponseEvent::EVENT_SEND_RESPONSE, new SimpleStreamResponseSender(), -3000); $events->attach(SendResponseEvent::EVENT_SEND_RESPONSE, new HttpResponseSender(), -4000); } } 
namespace Zend\Mvc\ResponseSender; use Zend\EventManager\Event; use Zend\Stdlib\ResponseInterface; class SendResponseEvent extends Event { const EVENT_SEND_RESPONSE = 'sendResponse'; protected $name = 'sendResponse'; protected $response; protected $headersSent = array(); protected $contentSent = array(); public function setResponse(ResponseInterface $response) { $this->setParam('response', $response); $this->response = $response; return $this; } public function getResponse() { return $this->response; } public function setContentSent() { $response = $this->getResponse(); $contentSent = $this->getParam('contentSent', array()); $contentSent[spl_object_hash($response)] = true; $this->setParam('contentSent', $contentSent); $this->contentSent[spl_object_hash($response)] = true; return $this; } public function contentSent() { $response = $this->getResponse(); if (isset($this->contentSent[spl_object_hash($response)])) { return true; } return false; } public function setHeadersSent() { $response = $this->getResponse(); $headersSent = $this->getParam('headersSent', array()); $headersSent[spl_object_hash($response)] = true; $this->setParam('headersSent', $headersSent); $this->headersSent[spl_object_hash($response)] = true; return $this; } public function headersSent() { $response = $this->getResponse(); if (isset($this->headersSent[spl_object_hash($response)])) { return true; } return false; } } 
namespace Zend\Mvc\ResponseSender; use Zend\Mvc\ResponseSender\SendResponseEvent; interface ResponseSenderInterface { public function __invoke(SendResponseEvent $event); } 
namespace Zend\Mvc\ResponseSender; use Zend\Http\Response; use Zend\Mvc\ResponseSender\SendResponseEvent; class HttpResponseSender extends AbstractResponseSender { public function sendContent(SendResponseEvent $event) { if ($event->contentSent()) { return $this; } $response = $event->getResponse(); echo $response->getContent(); $event->setContentSent(); return $this; } public function __invoke(SendResponseEvent $event) { $response = $event->getResponse(); if (!$response instanceof Response) { return $this; } $this->sendHeaders($event) ->sendContent($event); $event->stopPropagation(true); return $this; } } 
namespace Zend\Mvc\ResponseSender; use Zend\Http\PhpEnvironment\Response; use Zend\Mvc\ResponseSender\SendResponseEvent; class PhpEnvironmentResponseSender extends HttpResponseSender { public function __invoke(SendResponseEvent $event) { $response = $event->getResponse(); if (!$response instanceof Response) { return $this; } $this->sendHeaders($event) ->sendContent($event); $event->stopPropagation(true); return $this; } } 
namespace Zend\Mvc\ResponseSender; use Zend\Console\Response; class ConsoleResponseSender implements ResponseSenderInterface { public function sendContent(SendResponseEvent $event) { if ($event->contentSent()) { return $this; } $response = $event->getResponse(); echo $response->getContent(); $event->setContentSent(); return $this; } public function __invoke(SendResponseEvent $event) { $response = $event->getResponse(); if (!$response instanceof Response) { return; } $this->sendContent($event); $errorLevel = (int) $response->getMetadata('errorLevel',0); $event->stopPropagation(true); exit($errorLevel); } } 
namespace Zend\Mvc\ResponseSender; use Zend\Http\Header\MultipleHeaderInterface; use Zend\Http\Response\Stream; class SimpleStreamResponseSender extends AbstractResponseSender { public function sendStream(SendResponseEvent $event) { if ($event->contentSent()) { return $this; } $response = $event->getResponse(); $stream = $response->getStream(); fpassthru($stream); $event->setContentSent(); } public function __invoke(SendResponseEvent $event) { $response = $event->getResponse(); if (!$response instanceof Stream) { return $this; } $this->sendHeaders($event); $this->sendStream($event); $event->stopPropagation(true); return $this; } } 
namespace Zend\Mvc\Service; use Zend\Console\Console; use Zend\Mvc\Router\Console\SimpleRouteStack as ConsoleRouter; use Zend\Mvc\Router\Http\TreeRouteStack as HttpRouter; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class RouterFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator, $cName = null, $rName = null) { $config = $serviceLocator->has('Config') ? $serviceLocator->get('Config') : array(); $routerClass = 'Zend\Mvc\Router\Http\TreeRouteStack'; $routerConfig = isset($config['router']) ? $config['router'] : array(); if ($rName === 'ConsoleRouter' || ($cName === 'router' && Console::isConsole()) ) { $routerClass = 'Zend\Mvc\Router\Console\SimpleRouteStack'; $routerConfig = isset($config['console']['router']) ? $config['console']['router'] : array(); } if (isset($routerConfig['router_class']) && class_exists($routerConfig['router_class'])) { $routerClass = $routerConfig['router_class']; } if (!isset($routerConfig['route_plugins'])) { $routePluginManager = $serviceLocator->get('RoutePluginManager'); $routerConfig['route_plugins'] = $routePluginManager; } $factory = sprintf('%s::factory', $routerClass); return call_user_func($factory, $routerConfig); } } 
namespace Zend\Mvc\Router; use Zend\Stdlib\RequestInterface as Request; interface RouteInterface { public static function factory($options = array()); public function match(Request $request); public function assemble(array $params = array(), array $options = array()); } 
namespace Zend\Mvc\Router; interface RouteStackInterface extends RouteInterface { public function addRoute($name, $route, $priority = null); public function addRoutes($routes); public function removeRoute($name); public function setRoutes($routes); } 
namespace Zend\Mvc\Router; use Traversable; use Zend\Stdlib\ArrayUtils; use Zend\Stdlib\RequestInterface as Request; class SimpleRouteStack implements RouteStackInterface { protected $routes; protected $routePluginManager; protected $defaultParams = array(); public function __construct(RoutePluginManager $routePluginManager = null) { $this->routes = new PriorityList(); if (null === $routePluginManager) { $routePluginManager = new RoutePluginManager(); } $this->routePluginManager = $routePluginManager; $this->init(); } public static function factory($options = array()) { if ($options instanceof Traversable) { $options = ArrayUtils::iteratorToArray($options); } elseif (!is_array($options)) { throw new Exception\InvalidArgumentException(__METHOD__ . ' expects an array or Traversable set of options'); } $routePluginManager = null; if (isset($options['route_plugins'])) { $routePluginManager = $options['route_plugins']; } $instance = new static($routePluginManager); if (isset($options['routes'])) { $instance->addRoutes($options['routes']); } if (isset($options['default_params'])) { $instance->setDefaultParams($options['default_params']); } return $instance; } protected function init() { } public function setRoutePluginManager(RoutePluginManager $routePlugins) { $this->routePluginManager = $routePlugins; return $this; } public function getRoutePluginManager() { return $this->routePluginManager; } public function addRoutes($routes) { if (!is_array($routes) && !$routes instanceof Traversable) { throw new Exception\InvalidArgumentException('addRoutes expects an array or Traversable set of routes'); } foreach ($routes as $name => $route) { $this->addRoute($name, $route); } return $this; } public function addRoute($name, $route, $priority = null) { if (!$route instanceof RouteInterface) { $route = $this->routeFromArray($route); } if ($priority === null && isset($route->priority)) { $priority = $route->priority; } $this->routes->insert($name, $route, $priority); return $this; } public function removeRoute($name) { $this->routes->remove($name); return $this; } public function setRoutes($routes) { $this->routes->clear(); $this->addRoutes($routes); return $this; } public function getRoutes() { return $this->routes; } public function hasRoute($name) { return $this->routes->get($name) !== null; } public function getRoute($name) { return $this->routes->get($name); } public function setDefaultParams(array $params) { $this->defaultParams = $params; return $this; } public function setDefaultParam($name, $value) { $this->defaultParams[$name] = $value; return $this; } protected function routeFromArray($specs) { if ($specs instanceof Traversable) { $specs = ArrayUtils::iteratorToArray($specs); } elseif (!is_array($specs)) { throw new Exception\InvalidArgumentException('Route definition must be an array or Traversable object'); } if (!isset($specs['type'])) { throw new Exception\InvalidArgumentException('Missing "type" option'); } elseif (!isset($specs['options'])) { $specs['options'] = array(); } $route = $this->getRoutePluginManager()->get($specs['type'], $specs['options']); if (isset($specs['priority'])) { $route->priority = $specs['priority']; } return $route; } public function match(Request $request) { foreach ($this->routes as $name => $route) { if (($match = $route->match($request)) instanceof RouteMatch) { $match->setMatchedRouteName($name); foreach ($this->defaultParams as $paramName => $value) { if ($match->getParam($paramName) === null) { $match->setParam($paramName, $value); } } return $match; } } return null; } public function assemble(array $params = array(), array $options = array()) { if (!isset($options['name'])) { throw new Exception\InvalidArgumentException('Missing "name" option'); } $route = $this->routes->get($options['name']); if (!$route) { throw new Exception\RuntimeException(sprintf('Route with name "%s" not found', $options['name'])); } unset($options['name']); return $route->assemble(array_merge($this->defaultParams, $params), $options); } } 
namespace Zend\Mvc\Router\Http; use ArrayObject; use Traversable; use Zend\Mvc\Router\Exception; use Zend\Mvc\Router\SimpleRouteStack; use Zend\Stdlib\ArrayUtils; use Zend\Stdlib\RequestInterface as Request; use Zend\Uri\Http as HttpUri; class TreeRouteStack extends SimpleRouteStack { protected $baseUrl; protected $requestUri; protected $prototypes; public static function factory($options = array()) { if ($options instanceof Traversable) { $options = ArrayUtils::iteratorToArray($options); } elseif (!is_array($options)) { throw new Exception\InvalidArgumentException(__METHOD__ . ' expects an array or Traversable set of options'); } $instance = parent::factory($options); if (isset($options['prototypes'])) { $instance->addPrototypes($options['prototypes']); } return $instance; } protected function init() { $this->prototypes = new ArrayObject; $routes = $this->routePluginManager; foreach (array( 'chain' => __NAMESPACE__ . '\Chain', 'hostname' => __NAMESPACE__ . '\Hostname', 'literal' => __NAMESPACE__ . '\Literal', 'method' => __NAMESPACE__ . '\Method', 'part' => __NAMESPACE__ . '\Part', 'query' => __NAMESPACE__ . '\Query', 'regex' => __NAMESPACE__ . '\Regex', 'scheme' => __NAMESPACE__ . '\Scheme', 'segment' => __NAMESPACE__ . '\Segment', 'wildcard' => __NAMESPACE__ . '\Wildcard', ) as $name => $class ) { $routes->setInvokableClass($name, $class); }; } public function addRoute($name, $route, $priority = null) { if (!$route instanceof RouteInterface) { $route = $this->routeFromArray($route); } return parent::addRoute($name, $route, $priority); } protected function routeFromArray($specs) { if (is_string($specs)) { if (null === ($route = $this->getPrototype($specs))) { throw new Exception\RuntimeException(sprintf('Could not find prototype with name %s', $specs)); } return $route; } elseif ($specs instanceof Traversable) { $specs = ArrayUtils::iteratorToArray($specs); } elseif (!is_array($specs)) { throw new Exception\InvalidArgumentException('Route definition must be an array or Traversable object'); } if (isset($specs['chain_routes'])) { if (!is_array($specs['chain_routes'])) { throw new Exception\InvalidArgumentException('Chain routes must be an array or Traversable object'); } $chainRoutes = array_merge(array($specs), $specs['chain_routes']); unset($chainRoutes[0]['chain_routes']); $options = array( 'routes' => $chainRoutes, 'route_plugins' => $this->routePluginManager, 'prototypes' => $this->prototypes, ); $route = $this->routePluginManager->get('chain', $options); } else { $route = parent::routeFromArray($specs); } if (!$route instanceof RouteInterface) { throw new Exception\RuntimeException('Given route does not implement HTTP route interface'); } if (isset($specs['child_routes'])) { $options = array( 'route' => $route, 'may_terminate' => (isset($specs['may_terminate']) && $specs['may_terminate']), 'child_routes' => $specs['child_routes'], 'route_plugins' => $this->routePluginManager, 'prototypes' => $this->prototypes, ); $priority = (isset($route->priority) ? $route->priority : null); $route = $this->routePluginManager->get('part', $options); $route->priority = $priority; } return $route; } public function addPrototypes($routes) { if (!is_array($routes) && !$routes instanceof Traversable) { throw new Exception\InvalidArgumentException('addPrototypes expects an array or Traversable set of routes'); } foreach ($routes as $name => $route) { $this->addPrototype($name, $route); } return $this; } public function addPrototype($name, $route) { if (!$route instanceof RouteInterface) { $route = $this->routeFromArray($route); } $this->prototypes[$name] = $route; return $this; } public function getPrototype($name) { if (isset($this->prototypes[$name])) { return $this->prototypes[$name]; } return null; } public function match(Request $request, $pathOffset = null, array $options = array()) { if (!method_exists($request, 'getUri')) { return null; } if ($this->baseUrl === null && method_exists($request, 'getBaseUrl')) { $this->setBaseUrl($request->getBaseUrl()); } $uri = $request->getUri(); $baseUrlLength = strlen($this->baseUrl) ?: null; if ($pathOffset !== null) { $baseUrlLength += $pathOffset; } if ($this->requestUri === null) { $this->setRequestUri($uri); } if ($baseUrlLength !== null) { $pathLength = strlen($uri->getPath()) - $baseUrlLength; } else { $pathLength = null; } foreach ($this->routes as $name => $route) { if ( ($match = $route->match($request, $baseUrlLength, $options)) instanceof RouteMatch && ($pathLength === null || $match->getLength() === $pathLength) ) { $match->setMatchedRouteName($name); foreach ($this->defaultParams as $paramName => $value) { if ($match->getParam($paramName) === null) { $match->setParam($paramName, $value); } } return $match; } } return null; } public function assemble(array $params = array(), array $options = array()) { if (!isset($options['name'])) { throw new Exception\InvalidArgumentException('Missing "name" option'); } $names = explode('/', $options['name'], 2); $route = $this->routes->get($names[0]); if (!$route) { throw new Exception\RuntimeException(sprintf('Route with name "%s" not found', $names[0])); } if (isset($names[1])) { if (!$route instanceof TreeRouteStack) { throw new Exception\RuntimeException(sprintf('Route with name "%s" does not have child routes', $names[0])); } $options['name'] = $names[1]; } else { unset($options['name']); } if (isset($options['only_return_path']) && $options['only_return_path']) { return $this->baseUrl . $route->assemble(array_merge($this->defaultParams, $params), $options); } if (!isset($options['uri'])) { $uri = new HttpUri(); if (isset($options['force_canonical']) && $options['force_canonical']) { if ($this->requestUri === null) { throw new Exception\RuntimeException('Request URI has not been set'); } $uri->setScheme($this->requestUri->getScheme()) ->setHost($this->requestUri->getHost()) ->setPort($this->requestUri->getPort()); } $options['uri'] = $uri; } else { $uri = $options['uri']; } $path = $this->baseUrl . $route->assemble(array_merge($this->defaultParams, $params), $options); if (isset($options['query'])) { $uri->setQuery($options['query']); } if (isset($options['fragment'])) { $uri->setFragment($options['fragment']); } if ((isset($options['force_canonical']) && $options['force_canonical']) || $uri->getHost() !== null || $uri->getScheme() !== null) { if (($uri->getHost() === null || $uri->getScheme() === null) && $this->requestUri === null) { throw new Exception\RuntimeException('Request URI has not been set'); } if ($uri->getHost() === null) { $uri->setHost($this->requestUri->getHost()); } if ($uri->getScheme() === null) { $uri->setScheme($this->requestUri->getScheme()); } return $uri->setPath($path)->normalize()->toString(); } elseif (!$uri->isAbsolute() && $uri->isValidRelative()) { return $uri->setPath($path)->normalize()->toString(); } return $path; } public function setBaseUrl($baseUrl) { $this->baseUrl = rtrim($baseUrl, '/'); return $this; } public function getBaseUrl() { return $this->baseUrl; } public function setRequestUri(HttpUri $uri) { $this->requestUri = $uri; return $this; } public function getRequestUri() { return $this->requestUri; } } 
namespace Zend\Mvc\Router; use Countable; use Iterator; class PriorityList implements Iterator, Countable { protected $routes = array(); protected $serial = 0; protected $count = 0; protected $sorted = false; public function insert($name, RouteInterface $route, $priority) { $this->sorted = false; $this->count++; $this->routes[$name] = array( 'route' => $route, 'priority' => (int) $priority, 'serial' => $this->serial++, ); } public function remove($name) { if (!isset($this->routes[$name])) { return; } $this->count--; unset($this->routes[$name]); } public function clear() { $this->routes = array(); $this->serial = 0; $this->count = 0; $this->sorted = false; } public function get($name) { if (!isset($this->routes[$name])) { return null; } return $this->routes[$name]['route']; } protected function sort() { uasort($this->routes, array($this, 'compare')); $this->sorted = true; } protected function compare(array $route1, array $route2) { if ($route1['priority'] === $route2['priority']) { return ($route1['serial'] > $route2['serial'] ? -1 : 1); } return ($route1['priority'] > $route2['priority'] ? -1 : 1); } public function rewind() { if (!$this->sorted) { $this->sort(); } reset($this->routes); } public function current() { $node = current($this->routes); return ($node !== false ? $node['route'] : false); } public function key() { return key($this->routes); } public function next() { $node = next($this->routes); return ($node !== false ? $node['route'] : false); } public function valid() { return ($this->current() !== false); } public function count() { return $this->count; } } 
namespace Zend\Mvc\Router\Http; use Zend\Mvc\Router\RouteInterface as BaseRoute; interface RouteInterface extends BaseRoute { public function getAssembledParams(); } 
namespace Zend\Mvc\Router\Http; use Traversable; use Zend\Mvc\Router\Exception; use Zend\Stdlib\ArrayUtils; use Zend\Stdlib\RequestInterface as Request; class Literal implements RouteInterface { protected $route; protected $defaults; public function __construct($route, array $defaults = array()) { $this->route = $route; $this->defaults = $defaults; } public static function factory($options = array()) { if ($options instanceof Traversable) { $options = ArrayUtils::iteratorToArray($options); } elseif (!is_array($options)) { throw new Exception\InvalidArgumentException(__METHOD__ . ' expects an array or Traversable set of options'); } if (!isset($options['route'])) { throw new Exception\InvalidArgumentException('Missing "route" in options array'); } if (!isset($options['defaults'])) { $options['defaults'] = array(); } return new static($options['route'], $options['defaults']); } public function match(Request $request, $pathOffset = null) { if (!method_exists($request, 'getUri')) { return null; } $uri = $request->getUri(); $path = $uri->getPath(); if ($pathOffset !== null) { if ($pathOffset >= 0 && strlen($path) >= $pathOffset && !empty($this->route)) { if (strpos($path, $this->route, $pathOffset) === $pathOffset) { return new RouteMatch($this->defaults, strlen($this->route)); } } return null; } if ($path === $this->route) { return new RouteMatch($this->defaults, strlen($this->route)); } return null; } public function assemble(array $params = array(), array $options = array()) { return $this->route; } public function getAssembledParams() { return array(); } } 
namespace Zend\Mvc\Router\Http; use ArrayObject; use Traversable; use Zend\Mvc\Router\Exception; use Zend\Mvc\Router\PriorityList; use Zend\Mvc\Router\RoutePluginManager; use Zend\Stdlib\ArrayUtils; use Zend\Stdlib\RequestInterface as Request; class Part extends TreeRouteStack implements RouteInterface { protected $route; protected $mayTerminate; protected $childRoutes; public function __construct($route, $mayTerminate, RoutePluginManager $routePlugins, array $childRoutes = null, ArrayObject $prototypes = null) { $this->routePluginManager = $routePlugins; if (!$route instanceof RouteInterface) { $route = $this->routeFromArray($route); } if ($route instanceof self) { throw new Exception\InvalidArgumentException('Base route may not be a part route'); } $this->route = $route; $this->mayTerminate = $mayTerminate; $this->childRoutes = $childRoutes; $this->prototypes = $prototypes; $this->routes = new PriorityList(); } public static function factory($options = array()) { if ($options instanceof Traversable) { $options = ArrayUtils::iteratorToArray($options); } elseif (!is_array($options)) { throw new Exception\InvalidArgumentException(__METHOD__ . ' expects an array or Traversable set of options'); } if (!isset($options['route'])) { throw new Exception\InvalidArgumentException('Missing "route" in options array'); } if (!isset($options['route_plugins'])) { throw new Exception\InvalidArgumentException('Missing "route_plugins" in options array'); } if (!isset($options['prototypes'])) { $options['prototypes'] = null; } if (!isset($options['may_terminate'])) { $options['may_terminate'] = false; } if (!isset($options['child_routes']) || !$options['child_routes']) { $options['child_routes'] = null; } if ($options['child_routes'] instanceof Traversable) { $options['child_routes'] = ArrayUtils::iteratorToArray($options['child_routes']); } return new static( $options['route'], $options['may_terminate'], $options['route_plugins'], $options['child_routes'], $options['prototypes'] ); } public function match(Request $request, $pathOffset = null, array $options = array()) { if ($pathOffset === null) { $pathOffset = 0; } $match = $this->route->match($request, $pathOffset, $options); if ($match !== null && method_exists($request, 'getUri')) { if ($this->childRoutes !== null) { $this->addRoutes($this->childRoutes); $this->childRoutes = null; } $nextOffset = $pathOffset + $match->getLength(); $uri = $request->getUri(); $pathLength = strlen($uri->getPath()); if ($this->mayTerminate && $nextOffset === $pathLength) { $query = $uri->getQuery(); if ('' == trim($query) || !$this->hasQueryChild()) { return $match; } } foreach ($this->routes as $name => $route) { if (($subMatch = $route->match($request, $nextOffset, $options)) instanceof RouteMatch) { if ($match->getLength() + $subMatch->getLength() + $pathOffset === $pathLength) { return $match->merge($subMatch)->setMatchedRouteName($name); } } } } return null; } public function assemble(array $params = array(), array $options = array()) { if ($this->childRoutes !== null) { $this->addRoutes($this->childRoutes); $this->childRoutes = null; } $options['has_child'] = (isset($options['name'])); $path = $this->route->assemble($params, $options); $params = array_diff_key($params, array_flip($this->route->getAssembledParams())); if (!isset($options['name'])) { if (!$this->mayTerminate) { throw new Exception\RuntimeException('Part route may not terminate'); } else { return $path; } } unset($options['has_child']); $options['only_return_path'] = true; $path .= parent::assemble($params, $options); return $path; } public function getAssembledParams() { return array(); } protected function hasQueryChild() { foreach ($this->routes as $route) { if ($route instanceof Query) { return true; } } return false; } } 
namespace Zend\Mvc\View\Http; use Zend\EventManager\AbstractListenerAggregate; use Zend\EventManager\EventManagerInterface; use Zend\Http\Response as HttpResponse; use Zend\Mvc\Application; use Zend\Mvc\MvcEvent; use Zend\Stdlib\ResponseInterface as Response; use Zend\View\Model\ViewModel; class RouteNotFoundStrategy extends AbstractListenerAggregate { protected $displayExceptions = false; protected $displayNotFoundReason = false; protected $notFoundTemplate = 'error'; protected $reason = false; public function attach(EventManagerInterface $events) { $this->listeners[] = $events->attach(MvcEvent::EVENT_DISPATCH, array($this, 'prepareNotFoundViewModel'), -90); $this->listeners[] = $events->attach(MvcEvent::EVENT_DISPATCH_ERROR, array($this, 'detectNotFoundError')); $this->listeners[] = $events->attach(MvcEvent::EVENT_DISPATCH_ERROR, array($this, 'prepareNotFoundViewModel')); } public function setDisplayExceptions($displayExceptions) { $this->displayExceptions = (bool) $displayExceptions; return $this; } public function displayExceptions() { return $this->displayExceptions; } public function setDisplayNotFoundReason($displayNotFoundReason) { $this->displayNotFoundReason = (bool) $displayNotFoundReason; return $this; } public function displayNotFoundReason() { return $this->displayNotFoundReason; } public function setNotFoundTemplate($notFoundTemplate) { $this->notFoundTemplate = (string) $notFoundTemplate; return $this; } public function getNotFoundTemplate() { return $this->notFoundTemplate; } public function detectNotFoundError(MvcEvent $e) { $error = $e->getError(); if (empty($error)) { return; } switch ($error) { case Application::ERROR_CONTROLLER_NOT_FOUND: case Application::ERROR_CONTROLLER_INVALID: case Application::ERROR_ROUTER_NO_MATCH: $this->reason = $error; $response = $e->getResponse(); if (!$response) { $response = new HttpResponse(); $e->setResponse($response); } $response->setStatusCode(404); break; default: return; } } public function prepareNotFoundViewModel(MvcEvent $e) { $vars = $e->getResult(); if ($vars instanceof Response) { return; } $response = $e->getResponse(); if ($response->getStatusCode() != 404) { return; } if (!$vars instanceof ViewModel) { $model = new ViewModel(); if (is_string($vars)) { $model->setVariable('message', $vars); } else { $model->setVariable('message', 'Page not found.'); } } else { $model = $vars; if ($model->getVariable('message') === null) { $model->setVariable('message', 'Page not found.'); } } $model->setTemplate($this->getNotFoundTemplate()); $this->injectNotFoundReason($model); $this->injectException($model, $e); $this->injectController($model, $e); $e->setResult($model); } protected function injectNotFoundReason(ViewModel $model) { if (!$this->displayNotFoundReason()) { return; } if ($this->reason) { $model->setVariable('reason', $this->reason); return; } $model->setVariable('reason', Application::ERROR_CONTROLLER_CANNOT_DISPATCH); } protected function injectException($model, $e) { if (!$this->displayExceptions()) { return; } $model->setVariable('display_exceptions', true); $exception = $e->getParam('exception', false); if (!$exception instanceof \Exception) { return; } $model->setVariable('exception', $exception); } protected function injectController($model, $e) { if (!$this->displayExceptions() && !$this->displayNotFoundReason()) { return; } $controller = $e->getController(); if (empty($controller)) { $routeMatch = $e->getRouteMatch(); if (empty($routeMatch)) { return; } $controller = $routeMatch->getParam('controller', false); if (!$controller) { return; } } $controllerClass = $e->getControllerClass(); $model->setVariable('controller', $controller); $model->setVariable('controller_class', $controllerClass); } } 
namespace Zend\Mvc\View\Http; use Zend\EventManager\AbstractListenerAggregate; use Zend\EventManager\EventManagerInterface; use Zend\Http\Response as HttpResponse; use Zend\Mvc\Application; use Zend\Mvc\MvcEvent; use Zend\Stdlib\ResponseInterface as Response; use Zend\View\Model\ViewModel; class ExceptionStrategy extends AbstractListenerAggregate { protected $displayExceptions = false; protected $exceptionTemplate = 'error'; public function attach(EventManagerInterface $events) { $this->listeners[] = $events->attach(MvcEvent::EVENT_DISPATCH_ERROR, array($this, 'prepareExceptionViewModel')); $this->listeners[] = $events->attach(MvcEvent::EVENT_RENDER_ERROR, array($this, 'prepareExceptionViewModel')); } public function setDisplayExceptions($displayExceptions) { $this->displayExceptions = (bool) $displayExceptions; return $this; } public function displayExceptions() { return $this->displayExceptions; } public function setExceptionTemplate($exceptionTemplate) { $this->exceptionTemplate = (string) $exceptionTemplate; return $this; } public function getExceptionTemplate() { return $this->exceptionTemplate; } public function prepareExceptionViewModel(MvcEvent $e) { $error = $e->getError(); if (empty($error)) { return; } $result = $e->getResult(); if ($result instanceof Response) { return; } switch ($error) { case Application::ERROR_CONTROLLER_NOT_FOUND: case Application::ERROR_CONTROLLER_INVALID: case Application::ERROR_ROUTER_NO_MATCH: return; case Application::ERROR_EXCEPTION: default: $model = new ViewModel(array( 'message' => 'An error occurred during execution; please try again later.', 'exception' => $e->getParam('exception'), 'display_exceptions' => $this->displayExceptions(), )); $model->setTemplate($this->getExceptionTemplate()); $e->setResult($model); $response = $e->getResponse(); if (!$response) { $response = new HttpResponse(); $response->setStatusCode(500); $e->setResponse($response); } else { $statusCode = $response->getStatusCode(); if ($statusCode === 200) { $response->setStatusCode(500); } } break; } } } 
namespace Zend\Mvc\View\Http; use Zend\EventManager\AbstractListenerAggregate; use Zend\EventManager\EventManagerInterface; use Zend\Mvc\Application; use Zend\Mvc\MvcEvent; use Zend\Stdlib\ResponseInterface as Response; use Zend\View\Model\ModelInterface as ViewModel; use Zend\View\View; class DefaultRenderingStrategy extends AbstractListenerAggregate { protected $layoutTemplate = 'layout'; protected $view; public function __construct(View $view) { $this->view = $view; } public function attach(EventManagerInterface $events) { $this->listeners[] = $events->attach(MvcEvent::EVENT_RENDER, array($this, 'render'), -10000); $this->listeners[] = $events->attach(MvcEvent::EVENT_RENDER_ERROR, array($this, 'render'), -10000); } public function setLayoutTemplate($layoutTemplate) { $this->layoutTemplate = (string) $layoutTemplate; return $this; } public function getLayoutTemplate() { return $this->layoutTemplate; } public function render(MvcEvent $e) { $result = $e->getResult(); if ($result instanceof Response) { return $result; } $request = $e->getRequest(); $response = $e->getResponse(); $viewModel = $e->getViewModel(); if (!$viewModel instanceof ViewModel) { return; } $view = $this->view; $view->setRequest($request); $view->setResponse($response); try { $view->render($viewModel); } catch (\Exception $ex) { if ($e->getName() === MvcEvent::EVENT_RENDER_ERROR) { throw $ex; } $application = $e->getApplication(); $events = $application->getEventManager(); $e->setError(Application::ERROR_EXCEPTION) ->setParam('exception', $ex); $events->trigger(MvcEvent::EVENT_RENDER_ERROR, $e); } return $response; } } 
namespace Zend\View; use Zend\EventManager\EventManager; use Zend\EventManager\EventManagerAwareInterface; use Zend\EventManager\EventManagerInterface; use Zend\Stdlib\RequestInterface as Request; use Zend\Stdlib\ResponseInterface as Response; use Zend\View\Model\ModelInterface as Model; use Zend\View\Renderer\RendererInterface as Renderer; use Zend\View\Renderer\TreeRendererInterface; class View implements EventManagerAwareInterface { protected $events; protected $request; protected $response; public function setRequest(Request $request) { $this->request = $request; return $this; } public function setResponse(Response $response) { $this->response = $response; return $this; } public function getRequest() { return $this->request; } public function getResponse() { return $this->response; } public function setEventManager(EventManagerInterface $events) { $events->setIdentifiers(array( __CLASS__, get_class($this), )); $this->events = $events; return $this; } public function getEventManager() { if (!$this->events instanceof EventManagerInterface) { $this->setEventManager(new EventManager()); } return $this->events; } public function addRenderingStrategy($callable, $priority = 1) { $this->getEventManager()->attach(ViewEvent::EVENT_RENDERER, $callable, $priority); return $this; } public function addResponseStrategy($callable, $priority = 1) { $this->getEventManager()->attach(ViewEvent::EVENT_RESPONSE, $callable, $priority); return $this; } public function render(Model $model) { $event = $this->getEvent(); $event->setModel($model); $events = $this->getEventManager(); $results = $events->trigger(ViewEvent::EVENT_RENDERER, $event, function ($result) { return ($result instanceof Renderer); }); $renderer = $results->last(); if (!$renderer instanceof Renderer) { throw new Exception\RuntimeException(sprintf( '%s: no renderer selected!', __METHOD__ )); } $event->setRenderer($renderer); $results = $events->trigger(ViewEvent::EVENT_RENDERER_POST, $event); $model = $event->getModel(); if ($model->hasChildren() && (!$renderer instanceof TreeRendererInterface || !$renderer->canRenderTrees()) ) { $this->renderChildren($model); } $event->setModel($model); $event->setRenderer($renderer); $rendered = $renderer->render($model); $options = $model->getOptions(); if (array_key_exists('has_parent', $options) && $options['has_parent']) { return $rendered; } $event->setResult($rendered); $events->trigger(ViewEvent::EVENT_RESPONSE, $event); } protected function renderChildren(Model $model) { foreach ($model as $child) { if ($child->terminate()) { throw new Exception\DomainException('Inconsistent state; child view model is marked as terminal'); } $child->setOption('has_parent', true); $result = $this->render($child); $child->setOption('has_parent', null); $capture = $child->captureTo(); if (!empty($capture)) { if ($child->isAppend()) { $oldResult=$model->{$capture}; $model->setVariable($capture, $oldResult . $result); } else { $model->setVariable($capture, $result); } } } } protected function getEvent() { $event = new ViewEvent(); $event->setTarget($this); if (null !== ($request = $this->getRequest())) { $event->setRequest($request); } if (null !== ($response = $this->getResponse())) { $event->setResponse($response); } return $event; } } 
namespace Zend\View\Strategy; use Zend\EventManager\AbstractListenerAggregate; use Zend\EventManager\EventManagerInterface; use Zend\View\Renderer\PhpRenderer; use Zend\View\ViewEvent; class PhpRendererStrategy extends AbstractListenerAggregate { protected $contentPlaceholders = array('article', 'content'); protected $renderer; public function __construct(PhpRenderer $renderer) { $this->renderer = $renderer; } public function getRenderer() { return $this->renderer; } public function setContentPlaceholders(array $contentPlaceholders) { $this->contentPlaceholders = $contentPlaceholders; return $this; } public function getContentPlaceholders() { return $this->contentPlaceholders; } public function attach(EventManagerInterface $events, $priority = 1) { $this->listeners[] = $events->attach(ViewEvent::EVENT_RENDERER, array($this, 'selectRenderer'), $priority); $this->listeners[] = $events->attach(ViewEvent::EVENT_RESPONSE, array($this, 'injectResponse'), $priority); } public function selectRenderer(ViewEvent $e) { return $this->renderer; } public function injectResponse(ViewEvent $e) { $renderer = $e->getRenderer(); if ($renderer !== $this->renderer) { return; } $result = $e->getResult(); $response = $e->getResponse(); if (empty($result)) { $placeholders = $renderer->plugin('placeholder'); foreach ($this->contentPlaceholders as $placeholder) { if ($placeholders->containerExists($placeholder)) { $result = (string) $placeholders->getContainer($placeholder); break; } } } $response->setContent($result); } } 
namespace Zend\View\Renderer; use Zend\View\Model\ModelInterface; use Zend\View\Resolver\ResolverInterface; interface RendererInterface { public function getEngine(); public function setResolver(ResolverInterface $resolver); public function render($nameOrModel, $values = null); } 
namespace Zend\View\Renderer; interface TreeRendererInterface { public function canRenderTrees(); } 
namespace Zend\View\Renderer; use ArrayAccess; use Traversable; use Zend\Filter\FilterChain; use Zend\View\Exception; use Zend\View\HelperPluginManager; use Zend\View\Helper\AbstractHelper; use Zend\View\Model\ModelInterface as Model; use Zend\View\Renderer\RendererInterface as Renderer; use Zend\View\Resolver\ResolverInterface as Resolver; use Zend\View\Resolver\TemplatePathStack; use Zend\View\Variables; class PhpRenderer implements Renderer, TreeRendererInterface { private $__content = ''; private $__renderTrees = false; private $__template = null; private $__templates = array(); private $__templateResolver; private $__file = null; private $__helpers; private $__filterChain; private $__vars; private $__varsCache = array(); private $__pluginCache = array(); public function __construct($config = array()) { $this->init(); } public function getEngine() { return $this; } public function init() { } public function setResolver(Resolver $resolver) { $this->__templateResolver = $resolver; return $this; } public function resolver($name = null) { if (null === $this->__templateResolver) { $this->setResolver(new TemplatePathStack()); } if (null !== $name) { return $this->__templateResolver->resolve($name, $this); } return $this->__templateResolver; } public function setVars($variables) { if (!is_array($variables) && !$variables instanceof ArrayAccess) { throw new Exception\InvalidArgumentException(sprintf( 'Expected array or ArrayAccess object; received "%s"', (is_object($variables) ? get_class($variables) : gettype($variables)) )); } if (!$variables instanceof Variables) { $variablesAsArray = array(); foreach ($variables as $key => $value) { $variablesAsArray[$key] = $value; } $variables = new Variables($variablesAsArray); } $this->__vars = $variables; return $this; } public function vars($key = null) { if (null === $this->__vars) { $this->setVars(new Variables()); } if (null === $key) { return $this->__vars; } return $this->__vars[$key]; } public function get($key) { if (null === $this->__vars) { $this->setVars(new Variables()); } return $this->__vars[$key]; } public function __get($name) { $vars = $this->vars(); return $vars[$name]; } public function __set($name, $value) { $vars = $this->vars(); $vars[$name] = $value; } public function __isset($name) { $vars = $this->vars(); return isset($vars[$name]); } public function __unset($name) { $vars = $this->vars(); if (!isset($vars[$name])) { return; } unset($vars[$name]); } public function setHelperPluginManager($helpers) { if (is_string($helpers)) { if (!class_exists($helpers)) { throw new Exception\InvalidArgumentException(sprintf( 'Invalid helper helpers class provided (%s)', $helpers )); } $helpers = new $helpers(); } if (!$helpers instanceof HelperPluginManager) { throw new Exception\InvalidArgumentException(sprintf( 'Helper helpers must extend Zend\View\HelperPluginManager; got type "%s" instead', (is_object($helpers) ? get_class($helpers) : gettype($helpers)) )); } $helpers->setRenderer($this); $this->__helpers = $helpers; return $this; } public function getHelperPluginManager() { if (null === $this->__helpers) { $this->setHelperPluginManager(new HelperPluginManager()); } return $this->__helpers; } public function plugin($name, array $options = null) { return $this->getHelperPluginManager()->get($name, $options); } public function __call($method, $argv) { if (!isset($this->__pluginCache[$method])) { $this->__pluginCache[$method] = $this->plugin($method); } if (is_callable($this->__pluginCache[$method])) { return call_user_func_array($this->__pluginCache[$method], $argv); } return $this->__pluginCache[$method]; } public function setFilterChain(FilterChain $filters) { $this->__filterChain = $filters; return $this; } public function getFilterChain() { if (null === $this->__filterChain) { $this->setFilterChain(new FilterChain()); } return $this->__filterChain; } public function render($nameOrModel, $values = null) { if ($nameOrModel instanceof Model) { $model = $nameOrModel; $nameOrModel = $model->getTemplate(); if (empty($nameOrModel)) { throw new Exception\DomainException(sprintf( '%s: received View Model argument, but template is empty', __METHOD__ )); } $options = $model->getOptions(); foreach ($options as $setting => $value) { $method = 'set' . $setting; if (method_exists($this, $method)) { $this->$method($value); } unset($method, $setting, $value); } unset($options); $helper = $this->plugin('view_model'); $helper->setCurrent($model); $values = $model->getVariables(); unset($model); } $this->addTemplate($nameOrModel); unset($nameOrModel); $this->__varsCache[] = $this->vars(); if (null !== $values) { $this->setVars($values); } unset($values); $__vars = $this->vars()->getArrayCopy(); if (array_key_exists('this', $__vars)) { unset($__vars['this']); } extract($__vars); unset($__vars); while ($this->__template = array_pop($this->__templates)) { $this->__file = $this->resolver($this->__template); if (!$this->__file) { throw new Exception\RuntimeException(sprintf( '%s: Unable to render template "%s"; resolver could not resolve to a file', __METHOD__, $this->__template )); } try { ob_start(); include $this->__file; $this->__content = ob_get_clean(); } catch (\Exception $ex) { ob_end_clean(); throw $ex; } } $this->setVars(array_pop($this->__varsCache)); return $this->getFilterChain()->filter($this->__content); } public function setCanRenderTrees($renderTrees) { $this->__renderTrees = (bool) $renderTrees; return $this; } public function canRenderTrees() { return $this->__renderTrees; } public function addTemplate($template) { $this->__templates[] = $template; return $this; } public function __clone() { $this->__vars = clone $this->vars(); } } 
namespace Zend\Mvc\Service; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; use Zend\View\Resolver as ViewResolver; class ViewResolverFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { $resolver = new ViewResolver\AggregateResolver(); $resolver->attach($serviceLocator->get('ViewTemplateMapResolver')); $resolver->attach($serviceLocator->get('ViewTemplatePathStack')); return $resolver; } } 
namespace Zend\View\Resolver; use Zend\View\Renderer\RendererInterface as Renderer; interface ResolverInterface { public function resolve($name, Renderer $renderer = null); } 
namespace Zend\View\Resolver; use Countable; use IteratorAggregate; use Zend\Stdlib\PriorityQueue; use Zend\View\Renderer\RendererInterface as Renderer; use Zend\View\Resolver\ResolverInterface as Resolver; class AggregateResolver implements Countable, IteratorAggregate, ResolverInterface { const FAILURE_NO_RESOLVERS = 'AggregateResolver_Failure_No_Resolvers'; const FAILURE_NOT_FOUND = 'AggregateResolver_Failure_Not_Found'; protected $lastLookupFailure = false; protected $lastSuccessfulResolver; protected $queue; public function __construct() { $this->queue = new PriorityQueue(); } public function count() { return $this->queue->count(); } public function getIterator() { return $this->queue; } public function attach(Resolver $resolver, $priority = 1) { $this->queue->insert($resolver, $priority); return $this; } public function resolve($name, Renderer $renderer = null) { $this->lastLookupFailure = false; $this->lastSuccessfulResolver = null; if (0 === count($this->queue)) { $this->lastLookupFailure = static::FAILURE_NO_RESOLVERS; return false; } foreach ($this->queue as $resolver) { $resource = $resolver->resolve($name, $renderer); if (!$resource) { continue; } $this->lastSuccessfulResolver = $resolver; return $resource; } $this->lastLookupFailure = static::FAILURE_NOT_FOUND; return false; } public function getLastSuccessfulResolver() { return $this->lastSuccessfulResolver; } public function getLastLookupFailure() { return $this->lastLookupFailure; } } 
namespace Zend\Mvc\Service; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; use Zend\View\Resolver as ViewResolver; class ViewTemplateMapResolverFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { $config = $serviceLocator->get('Config'); $map = array(); if (is_array($config) && isset($config['view_manager'])) { $config = $config['view_manager']; if (is_array($config) && isset($config['template_map'])) { $map = $config['template_map']; } } return new ViewResolver\TemplateMapResolver($map); } } 
namespace Zend\View\Resolver; use ArrayIterator; use IteratorAggregate; use Traversable; use Zend\Stdlib\ArrayUtils; use Zend\View\Exception; use Zend\View\Renderer\RendererInterface as Renderer; class TemplateMapResolver implements IteratorAggregate, ResolverInterface { protected $map = array(); public function __construct($map = array()) { $this->setMap($map); } public function getIterator() { return new ArrayIterator($this->map); } public function setMap($map) { if (!is_array($map) && !$map instanceof Traversable) { throw new Exception\InvalidArgumentException(sprintf( '%s: expects an array or Traversable, received "%s"', __METHOD__, (is_object($map) ? get_class($map) : gettype($map)) )); } if ($map instanceof Traversable) { $map = ArrayUtils::iteratorToArray($map); } $this->map = $map; return $this; } public function add($nameOrMap, $path = null) { if (is_array($nameOrMap) || $nameOrMap instanceof Traversable) { $this->merge($nameOrMap); return $this; } if (!is_string($nameOrMap)) { throw new Exception\InvalidArgumentException(sprintf( '%s: expects a string, array, or Traversable for the first argument; received "%s"', __METHOD__, (is_object($nameOrMap) ? get_class($nameOrMap) : gettype($nameOrMap)) )); } if (empty($path)) { if (isset($this->map[$nameOrMap])) { unset($this->map[$nameOrMap]); } return $this; } $this->map[$nameOrMap] = $path; return $this; } public function merge($map) { if (!is_array($map) && !$map instanceof Traversable) { throw new Exception\InvalidArgumentException(sprintf( '%s: expects an array or Traversable, received "%s"', __METHOD__, (is_object($map) ? get_class($map) : gettype($map)) )); } if ($map instanceof Traversable) { $map = ArrayUtils::iteratorToArray($map); } $this->map = array_replace_recursive($this->map, $map); return $this; } public function has($name) { return array_key_exists($name, $this->map); } public function get($name) { if (!$this->has($name)) { return false; } return $this->map[$name]; } public function getMap() { return $this->map; } public function resolve($name, Renderer $renderer = null) { return $this->get($name); } } 
namespace Zend\Mvc\Service; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; use Zend\View\Resolver as ViewResolver; class ViewTemplatePathStackFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { $config = $serviceLocator->get('Config'); $templatePathStack = new ViewResolver\TemplatePathStack(); if (is_array($config) && isset($config['view_manager'])) { $config = $config['view_manager']; if (is_array($config)) { if (isset($config['template_path_stack'])) { $templatePathStack->addPaths($config['template_path_stack']); } if (isset($config['default_template_suffix'])) { $templatePathStack->setDefaultSuffix($config['default_template_suffix']); } } } return $templatePathStack; } } 
namespace Zend\View\Resolver; use SplFileInfo; use Traversable; use Zend\Stdlib\SplStack; use Zend\View\Exception; use Zend\View\Renderer\RendererInterface as Renderer; class TemplatePathStack implements ResolverInterface { const FAILURE_NO_PATHS = 'TemplatePathStack_Failure_No_Paths'; const FAILURE_NOT_FOUND = 'TemplatePathStack_Failure_Not_Found'; protected $defaultSuffix = 'phtml'; protected $paths; protected $lastLookupFailure = false; protected $lfiProtectionOn = true; protected $useViewStream = false; protected $useStreamWrapper = false; public function __construct($options = null) { $this->useViewStream = (bool) ini_get('short_open_tag'); if ($this->useViewStream) { if (!in_array('zend.view', stream_get_wrappers())) { stream_wrapper_register('zend.view', 'Zend\View\Stream'); } } $this->paths = new SplStack; if (null !== $options) { $this->setOptions($options); } } public function setOptions($options) { if (!is_array($options) && !$options instanceof Traversable) { throw new Exception\InvalidArgumentException(sprintf( 'Expected array or Traversable object; received "%s"', (is_object($options) ? get_class($options) : gettype($options)) )); } foreach ($options as $key => $value) { switch (strtolower($key)) { case 'lfi_protection': $this->setLfiProtection($value); break; case 'script_paths': $this->addPaths($value); break; case 'use_stream_wrapper': $this->setUseStreamWrapper($value); break; case 'default_suffix': $this->setDefaultSuffix($value); break; default: break; } } } public function setDefaultSuffix($defaultSuffix) { $this->defaultSuffix = (string) $defaultSuffix; $this->defaultSuffix = ltrim($this->defaultSuffix, '.'); return $this; } public function getDefaultSuffix() { return $this->defaultSuffix; } public function addPaths(array $paths) { foreach ($paths as $path) { $this->addPath($path); } return $this; } public function setPaths($paths) { if ($paths instanceof SplStack) { $this->paths = $paths; } elseif (is_array($paths)) { $this->clearPaths(); $this->addPaths($paths); } else { throw new Exception\InvalidArgumentException( "Invalid argument provided for \$paths, expecting either an array or SplStack object" ); } return $this; } public static function normalizePath($path) { $path = rtrim($path, '/'); $path = rtrim($path, '\\'); $path .= DIRECTORY_SEPARATOR; return $path; } public function addPath($path) { if (!is_string($path)) { throw new Exception\InvalidArgumentException(sprintf( 'Invalid path provided; must be a string, received %s', gettype($path) )); } $this->paths[] = static::normalizePath($path); return $this; } public function clearPaths() { $this->paths = new SplStack; } public function getPaths() { return $this->paths; } public function setLfiProtection($flag) { $this->lfiProtectionOn = (bool) $flag; return $this; } public function isLfiProtectionOn() { return $this->lfiProtectionOn; } public function setUseStreamWrapper($flag) { $this->useStreamWrapper = (bool) $flag; return $this; } public function useStreamWrapper() { return ($this->useViewStream && $this->useStreamWrapper); } public function resolve($name, Renderer $renderer = null) { $this->lastLookupFailure = false; if ($this->isLfiProtectionOn() && preg_match('#\.\.[\\\/]#', $name)) { throw new Exception\DomainException( 'Requested scripts may not include parent directory traversal ("../", "..\\" notation)' ); } if (!count($this->paths)) { $this->lastLookupFailure = static::FAILURE_NO_PATHS; return false; } $defaultSuffix = $this->getDefaultSuffix(); if (pathinfo($name, PATHINFO_EXTENSION) == '') { $name .= '.' . $defaultSuffix; } foreach ($this->paths as $path) { $file = new SplFileInfo($path . $name); if ($file->isReadable()) { if (($filePath = $file->getRealPath()) === false && substr($path, 0, 7) === 'phar://') { $filePath = $path . $name; if (!file_exists($filePath)) { break; } } if ($this->useStreamWrapper()) { $filePath = 'zend.view://' . $filePath; } return $filePath; } } $this->lastLookupFailure = static::FAILURE_NOT_FOUND; return false; } public function getLastLookupFailure() { return $this->lastLookupFailure; } } 
namespace Zend\View; class Stream { protected $pos = 0; protected $data; protected $stat; public function stream_open($path, $mode, $options, &$opened_path) { $path = str_replace('zend.view://', '', $path); $this->data = file_get_contents($path); if ($this->data === false) { $this->stat = stat($path); return false; } $this->data = preg_replace('/\<\?\=/', "<?php echo ", $this->data); $this->data = preg_replace('/<\?(?!xml|php)/s', '<?php ', $this->data); $this->stat = stat($path); return true; } public function url_stat() { return $this->stat; } public function stream_read($count) { $ret = substr($this->data, $this->pos, $count); $this->pos += strlen($ret); return $ret; } public function stream_tell() { return $this->pos; } public function stream_eof() { return $this->pos >= strlen($this->data); } public function stream_stat() { return $this->stat; } public function stream_seek($offset, $whence) { switch ($whence) { case SEEK_SET: if ($offset < strlen($this->data) && $offset >= 0) { $this->pos = $offset; return true; } else { return false; } break; case SEEK_CUR: if ($offset >= 0) { $this->pos += $offset; return true; } else { return false; } break; case SEEK_END: if (strlen($this->data) + $offset >= 0) { $this->pos = strlen($this->data) + $offset; return true; } else { return false; } break; default: return false; } } } 
namespace Zend\Stdlib; use Serializable; class SplStack extends \SplStack implements Serializable { public function toArray() { $array = array(); foreach ($this as $item) { $array[] = $item; } return $array; } public function serialize() { return serialize($this->toArray()); } public function unserialize($data) { foreach (unserialize($data) as $item) { $this->unshift($item); } } } 
namespace Zend\View\Model; use Countable; use IteratorAggregate; interface ModelInterface extends Countable, IteratorAggregate { public function setOption($name, $value); public function setOptions($options); public function getOptions(); public function getVariable($name, $default = null); public function setVariable($name, $value); public function setVariables($variables); public function getVariables(); public function setTemplate($template); public function getTemplate(); public function addChild(ModelInterface $child, $captureTo = null, $append = false); public function getChildren(); public function hasChildren(); public function setCaptureTo($capture); public function captureTo(); public function setTerminal($terminate); public function terminate(); public function setAppend($append); public function isAppend(); } 
namespace Zend\View\Model; interface ClearableModelInterface { public function clearChildren(); public function clearOptions(); public function clearVariables(); } 
namespace Zend\View\Model; use ArrayAccess; use ArrayIterator; use Traversable; use Zend\Stdlib\ArrayUtils; use Zend\View\Exception; use Zend\View\Model; use Zend\View\Variables as ViewVariables; class ViewModel implements ModelInterface, ClearableModelInterface { protected $captureTo = 'content'; protected $children = array(); protected $options = array(); protected $template = ''; protected $terminate = false; protected $variables = array(); protected $append = false; public function __construct($variables = null, $options = null) { if (null === $variables) { $variables = new ViewVariables(); } $this->setVariables($variables, true); if (null !== $options) { $this->setOptions($options); } } public function __set($name, $value) { $this->setVariable($name, $value); } public function __get($name) { if (!$this->__isset($name)) { return null; } $variables = $this->getVariables(); return $variables[$name]; } public function __isset($name) { $variables = $this->getVariables(); return isset($variables[$name]); } public function __unset($name) { if (!$this->__isset($name)) { return null; } unset($this->variables[$name]); } public function setOption($name, $value) { $this->options[(string) $name] = $value; return $this; } public function getOption($name, $default = null) { $name = (string) $name; return array_key_exists($name, $this->options) ? $this->options[$name] : $default; } public function setOptions($options) { if ($options instanceof Traversable) { $options = ArrayUtils::iteratorToArray($options); } if (!is_array($options)) { throw new Exception\InvalidArgumentException(sprintf( '%s: expects an array, or Traversable argument; received "%s"', __METHOD__, (is_object($options) ? get_class($options) : gettype($options)) )); } $this->options = $options; return $this; } public function getOptions() { return $this->options; } public function clearOptions() { $this->options = array(); return $this; } public function getVariable($name, $default = null) { $name = (string) $name; if (array_key_exists($name, $this->variables)) { return $this->variables[$name]; } return $default; } public function setVariable($name, $value) { $this->variables[(string) $name] = $value; return $this; } public function setVariables($variables, $overwrite = false) { if (!is_array($variables) && !$variables instanceof Traversable) { throw new Exception\InvalidArgumentException(sprintf( '%s: expects an array, or Traversable argument; received "%s"', __METHOD__, (is_object($variables) ? get_class($variables) : gettype($variables)) )); } if ($overwrite) { if (is_object($variables) && !$variables instanceof ArrayAccess) { $variables = ArrayUtils::iteratorToArray($variables); } $this->variables = $variables; return $this; } foreach ($variables as $key => $value) { $this->setVariable($key, $value); } return $this; } public function getVariables() { return $this->variables; } public function clearVariables() { $this->variables = new ViewVariables(); return $this; } public function setTemplate($template) { $this->template = (string) $template; return $this; } public function getTemplate() { return $this->template; } public function addChild(ModelInterface $child, $captureTo = null, $append = null) { $this->children[] = $child; if (null !== $captureTo) { $child->setCaptureTo($captureTo); } if (null !== $append) { $child->setAppend($append); } return $this; } public function getChildren() { return $this->children; } public function hasChildren() { return (0 < count($this->children)); } public function clearChildren() { $this->children = array(); return $this; } public function setCaptureTo($capture) { $this->captureTo = (string) $capture; return $this; } public function captureTo() { return $this->captureTo; } public function setTerminal($terminate) { $this->terminate = (bool) $terminate; return $this; } public function terminate() { return $this->terminate; } public function setAppend($append) { $this->append = (bool) $append; return $this; } public function isAppend() { return $this->append; } public function count() { return count($this->children); } public function getIterator() { return new ArrayIterator($this->children); } } 
namespace Zend\View; use ArrayObject; class Variables extends ArrayObject { protected $strictVars = false; public function __construct(array $variables = array(), array $options = array()) { parent::__construct( $variables, ArrayObject::ARRAY_AS_PROPS, 'ArrayIterator' ); $this->setOptions($options); } public function setOptions(array $options) { foreach ($options as $key => $value) { switch (strtolower($key)) { case 'strict_vars': $this->setStrictVars($value); break; default: $this[$key] = $value; break; } } return $this; } public function setStrictVars($flag) { $this->strictVars = (bool) $flag; return $this; } public function isStrict() { return $this->strictVars; } public function assign($spec) { if (is_object($spec)) { if (method_exists($spec, 'toArray')) { $spec = $spec->toArray(); } else { $spec = (array) $spec; } } if (!is_array($spec)) { throw new Exception\InvalidArgumentException(sprintf( 'assign() expects either an array or an object as an argument; received "%s"', gettype($spec) )); } foreach ($spec as $key => $value) { $this[$key] = $value; } return $this; } public function offsetGet($key) { if (!$this->offsetExists($key)) { if ($this->isStrict()) { trigger_error(sprintf( 'View variable "%s" does not exist', $key ), E_USER_NOTICE); } return null; } $return = parent::offsetGet($key); if (is_object($return) && is_callable($return)) { $return = call_user_func($return); } return $return; } public function clear() { $this->exchangeArray(array()); } } 
namespace Zend\View\Helper; use Zend\View\Renderer\RendererInterface as Renderer; interface HelperInterface { public function setView(Renderer $view); public function getView(); } 
namespace Zend\View\Helper; use Zend\View\Helper\HelperInterface; use Zend\View\Renderer\RendererInterface as Renderer; abstract class AbstractHelper implements HelperInterface { protected $view = null; public function setView(Renderer $view) { $this->view = $view; return $this; } public function getView() { return $this->view; } } 
namespace Zend\View\Helper; use Zend\View\Model\ModelInterface as Model; class ViewModel extends AbstractHelper { protected $current; protected $root; public function setCurrent(Model $model) { $this->current = $model; return $this; } public function getCurrent() { return $this->current; } public function hasCurrent() { return ($this->current instanceof Model); } public function setRoot(Model $model) { $this->root = $model; return $this; } public function getRoot() { return $this->root; } public function hasRoot() { return ($this->root instanceof Model); } } 
namespace Zend\View; use ArrayAccess; use Zend\EventManager\Event; use Zend\Stdlib\RequestInterface as Request; use Zend\Stdlib\ResponseInterface as Response; use Zend\View\Model\ModelInterface as Model; use Zend\View\Renderer\RendererInterface as Renderer; class ViewEvent extends Event { const EVENT_RENDERER = 'renderer'; const EVENT_RENDERER_POST = 'renderer.post'; const EVENT_RESPONSE = 'response'; protected $model; protected $renderer; protected $request; protected $response; protected $result; public function setModel(Model $model) { $this->model = $model; return $this; } public function setRequest(Request $request) { $this->request = $request; return $this; } public function setResponse(Response $response) { $this->response = $response; return $this; } public function setResult($result) { $this->result = $result; return $this; } public function getModel() { return $this->model; } public function setRenderer(Renderer $renderer) { $this->renderer = $renderer; return $this; } public function getRenderer() { return $this->renderer; } public function getRequest() { return $this->request; } public function getResponse() { return $this->response; } public function getResult() { return $this->result; } public function getParam($name, $default = null) { switch ($name) { case 'model': return $this->getModel(); case 'renderer': return $this->getRenderer(); case 'request': return $this->getRequest(); case 'response': return $this->getResponse(); case 'result': return $this->getResult(); default: return parent::getParam($name, $default); } } public function getParams() { $params = parent::getParams(); $params['model'] = $this->getModel(); $params['renderer'] = $this->getRenderer(); $params['request'] = $this->getRequest(); $params['response'] = $this->getResponse(); $params['result'] = $this->getResult(); return $params; } public function setParams($params) { parent::setParams($params); if (!is_array($params) && !$params instanceof ArrayAccess) { return $this; } foreach (array('model', 'renderer', 'request', 'response', 'result') as $param) { if (isset($params[$param])) { $method = 'set' . $param; $this->$method($params[$param]); } } return $this; } public function setParam($name, $value) { switch ($name) { case 'model': $this->setModel($value); break; case 'renderer': $this->setRenderer($value); break; case 'request': $this->setRequest($value); break; case 'response': $this->setResponse($value); break; case 'result': $this->setResult($value); break; default: parent::setParam($name, $value); break; } return $this; } } 
namespace Zend\Mvc\View\Http; use Zend\EventManager\AbstractListenerAggregate; use Zend\EventManager\EventManagerInterface as Events; use Zend\Mvc\MvcEvent; use Zend\Stdlib\ArrayUtils; use Zend\View\Model\ViewModel; class CreateViewModelListener extends AbstractListenerAggregate { public function attach(Events $events) { $this->listeners[] = $events->attach('dispatch', array($this, 'createViewModelFromArray'), -80); $this->listeners[] = $events->attach('dispatch', array($this, 'createViewModelFromNull'), -80); } public function createViewModelFromArray(MvcEvent $e) { $result = $e->getResult(); if (!ArrayUtils::hasStringKeys($result, true)) { return; } $model = new ViewModel($result); $e->setResult($model); } public function createViewModelFromNull(MvcEvent $e) { $result = $e->getResult(); if (null !== $result) { return; } $model = new ViewModel; $e->setResult($model); } } 
namespace Zend\Mvc\View\Http; use Zend\EventManager\AbstractListenerAggregate; use Zend\EventManager\EventManagerInterface as Events; use Zend\Filter\Word\CamelCaseToDash as CamelCaseToDashFilter; use Zend\Mvc\MvcEvent; use Zend\Mvc\ModuleRouteListener; use Zend\View\Model\ModelInterface as ViewModel; class InjectTemplateListener extends AbstractListenerAggregate { protected $inflector; public function attach(Events $events) { $this->listeners[] = $events->attach(MvcEvent::EVENT_DISPATCH, array($this, 'injectTemplate'), -90); } public function injectTemplate(MvcEvent $e) { $model = $e->getResult(); if (!$model instanceof ViewModel) { return; } $template = $model->getTemplate(); if (!empty($template)) { return; } $routeMatch = $e->getRouteMatch(); $controller = $e->getTarget(); if (is_object($controller)) { $controller = get_class($controller); } if (!$controller) { $controller = $routeMatch->getParam('controller', ''); } $module = $this->deriveModuleNamespace($controller); if ($namespace = $routeMatch->getParam(ModuleRouteListener::MODULE_NAMESPACE)) { $controllerSubNs = $this->deriveControllerSubNamespace($namespace); if (!empty($controllerSubNs)) { if (!empty($module)) { $module .= '/' . $controllerSubNs; } else { $module = $controllerSubNs; } } } $controller = $this->deriveControllerClass($controller); $template = $this->inflectName($module); if (!empty($template)) { $template .= '/'; } $template .= $this->inflectName($controller); $action = $routeMatch->getParam('action'); if (null !== $action) { $template .= '/' . $this->inflectName($action); } $model->setTemplate($template); } protected function inflectName($name) { if (!$this->inflector) { $this->inflector = new CamelCaseToDashFilter(); } $name = $this->inflector->filter($name); return strtolower($name); } protected function deriveModuleNamespace($controller) { if (!strstr($controller, '\\')) { return ''; } $module = substr($controller, 0, strpos($controller, '\\')); return $module; } protected function deriveControllerSubNamespace($namespace) { if (!strstr($namespace, '\\')) { return ''; } $nsArray = explode('\\', $namespace); $subNsArray = array_slice($nsArray, 2); if (empty($subNsArray)) { return ''; } return implode('/', $subNsArray); } protected function deriveControllerClass($controller) { if (strstr($controller, '\\')) { $controller = substr($controller, strrpos($controller, '\\') + 1); } if ((10 < strlen($controller)) && ('Controller' == substr($controller, -10)) ) { $controller = substr($controller, 0, -10); } return $controller; } } 
namespace Zend\Mvc\View\Http; use Zend\EventManager\AbstractListenerAggregate; use Zend\EventManager\EventManagerInterface as Events; use Zend\Mvc\MvcEvent; use Zend\View\Model\ClearableModelInterface; use Zend\View\Model\ModelInterface as ViewModel; class InjectViewModelListener extends AbstractListenerAggregate { protected $inflector; public function attach(Events $events) { $this->listeners[] = $events->attach(MvcEvent::EVENT_DISPATCH, array($this, 'injectViewModel'), -100); $this->listeners[] = $events->attach(MvcEvent::EVENT_DISPATCH_ERROR, array($this, 'injectViewModel'), -100); $this->listeners[] = $events->attach(MvcEvent::EVENT_RENDER_ERROR, array($this, 'injectViewModel'), -100); } public function injectViewModel(MvcEvent $e) { $result = $e->getResult(); if (!$result instanceof ViewModel) { return; } $model = $e->getViewModel(); if ($result->terminate()) { $e->setViewModel($result); return; } if ($e->getError() && $model instanceof ClearableModelInterface) { $model->clearChildren(); } $model->addChild($result); } } 
namespace Zend\Mvc; use Zend\EventManager\EventManagerInterface; use Zend\EventManager\ListenerAggregateInterface; class ModuleRouteListener implements ListenerAggregateInterface { const MODULE_NAMESPACE = '__NAMESPACE__'; const ORIGINAL_CONTROLLER = '__CONTROLLER__'; protected $listeners = array(); public function attach(EventManagerInterface $events, $priority = 1) { $this->listeners[] = $events->attach(MvcEvent::EVENT_ROUTE, array($this, 'onRoute'), $priority); } public function detach(EventManagerInterface $events) { foreach ($this->listeners as $index => $listener) { if ($events->detach($listener)) { unset($this->listeners[$index]); } } } public function onRoute(MvcEvent $e) { $matches = $e->getRouteMatch(); if (!$matches instanceof Router\RouteMatch) { return; } $module = $matches->getParam(self::MODULE_NAMESPACE, false); if (!$module) { return; } $controller = $matches->getParam('controller', false); if (!$controller) { return; } if (0 === strpos($controller, $module)) { return; } $matches->setParam(self::ORIGINAL_CONTROLLER, $controller); $controller = $module . '\\' . str_replace(' ', '', ucwords(str_replace('-', ' ', $controller))); $matches->setParam('controller', $controller); } } 
namespace Zend\Mvc\Router; class RouteMatch { protected $params = array(); protected $matchedRouteName; public function __construct(array $params) { $this->params = $params; } public function setMatchedRouteName($name) { $this->matchedRouteName = $name; return $this; } public function getMatchedRouteName() { return $this->matchedRouteName; } public function setParam($name, $value) { $this->params[$name] = $value; return $this; } public function getParams() { return $this->params; } public function getParam($name, $default = null) { if (array_key_exists($name, $this->params)) { return $this->params[$name]; } return $default; } } 
namespace Zend\Mvc\Router\Http; use Zend\Mvc\Router\RouteMatch as BaseRouteMatch; class RouteMatch extends BaseRouteMatch { protected $length; public function __construct(array $params, $length = 0) { parent::__construct($params); $this->length = $length; } public function setMatchedRouteName($name) { if ($this->matchedRouteName === null) { $this->matchedRouteName = $name; } else { $this->matchedRouteName = $name . '/' . $this->matchedRouteName; } return $this; } public function merge(RouteMatch $match) { $this->params = array_merge($this->params, $match->getParams()); $this->length += $match->getLength(); $this->matchedRouteName = $match->getMatchedRouteName(); return $this; } public function getLength() { return $this->length; } } 
namespace Zend\Mvc; use Zend\EventManager\EventInterface as Event; interface InjectApplicationEventInterface { public function setEvent(Event $event); public function getEvent(); } 
namespace Zend\Stdlib; interface DispatchableInterface { public function dispatch(RequestInterface $request, ResponseInterface $response = null); } 
namespace Zend\Mvc\Controller; use Zend\EventManager\EventInterface as Event; use Zend\EventManager\EventManager; use Zend\EventManager\EventManagerAwareInterface; use Zend\EventManager\EventManagerInterface; use Zend\Http\PhpEnvironment\Response as HttpResponse; use Zend\Http\Request as HttpRequest; use Zend\Mvc\InjectApplicationEventInterface; use Zend\Mvc\MvcEvent; use Zend\ServiceManager\ServiceLocatorAwareInterface; use Zend\ServiceManager\ServiceLocatorInterface; use Zend\Stdlib\DispatchableInterface as Dispatchable; use Zend\Stdlib\RequestInterface as Request; use Zend\Stdlib\ResponseInterface as Response; abstract class AbstractController implements Dispatchable, EventManagerAwareInterface, InjectApplicationEventInterface, ServiceLocatorAwareInterface { protected $plugins; protected $request; protected $response; protected $event; protected $events; protected $serviceLocator; protected $eventIdentifier; abstract public function onDispatch(MvcEvent $e); public function dispatch(Request $request, Response $response = null) { $this->request = $request; if (!$response) { $response = new HttpResponse(); } $this->response = $response; $e = $this->getEvent(); $e->setRequest($request) ->setResponse($response) ->setTarget($this); $result = $this->getEventManager()->trigger(MvcEvent::EVENT_DISPATCH, $e, function ($test) { return ($test instanceof Response); }); if ($result->stopped()) { return $result->last(); } return $e->getResult(); } public function getRequest() { if (!$this->request) { $this->request = new HttpRequest(); } return $this->request; } public function getResponse() { if (!$this->response) { $this->response = new HttpResponse(); } return $this->response; } public function setEventManager(EventManagerInterface $events) { $events->setIdentifiers(array( 'Zend\Stdlib\DispatchableInterface', __CLASS__, get_class($this), $this->eventIdentifier, substr(get_class($this), 0, strpos(get_class($this), '\\')) )); $this->events = $events; $this->attachDefaultListeners(); return $this; } public function getEventManager() { if (!$this->events) { $this->setEventManager(new EventManager()); } return $this->events; } public function setEvent(Event $e) { if (!$e instanceof MvcEvent) { $eventParams = $e->getParams(); $e = new MvcEvent(); $e->setParams($eventParams); unset($eventParams); } $this->event = $e; } public function getEvent() { if (!$this->event) { $this->setEvent(new MvcEvent()); } return $this->event; } public function setServiceLocator(ServiceLocatorInterface $serviceLocator) { $this->serviceLocator = $serviceLocator; } public function getServiceLocator() { return $this->serviceLocator; } public function getPluginManager() { if (!$this->plugins) { $this->setPluginManager(new PluginManager()); } $this->plugins->setController($this); return $this->plugins; } public function setPluginManager(PluginManager $plugins) { $this->plugins = $plugins; $this->plugins->setController($this); return $this; } public function plugin($name, array $options = null) { return $this->getPluginManager()->get($name, $options); } public function __call($method, $params) { $plugin = $this->plugin($method); if (is_callable($plugin)) { return call_user_func_array($plugin, $params); } return $plugin; } protected function attachDefaultListeners() { $events = $this->getEventManager(); $events->attach(MvcEvent::EVENT_DISPATCH, array($this, 'onDispatch')); } public static function getMethodFromAction($action) { $method = str_replace(array('.', '-', '_'), ' ', $action); $method = ucwords($method); $method = str_replace(' ', '', $method); $method = lcfirst($method); $method .= 'Action'; return $method; } } 
namespace Zend\Mvc\Controller; use Zend\Http\Response as HttpResponse; use Zend\Mvc\Exception; use Zend\Mvc\MvcEvent; use Zend\View\Model\ConsoleModel; use Zend\View\Model\ViewModel; abstract class AbstractActionController extends AbstractController { protected $eventIdentifier = __CLASS__; public function indexAction() { return new ViewModel(array( 'content' => 'Placeholder page' )); } public function notFoundAction() { $response = $this->response; $event = $this->getEvent(); $routeMatch = $event->getRouteMatch(); $routeMatch->setParam('action', 'not-found'); if ($response instanceof HttpResponse) { return $this->createHttpNotFoundModel($response); } return $this->createConsoleNotFoundModel($response); } public function onDispatch(MvcEvent $e) { $routeMatch = $e->getRouteMatch(); if (!$routeMatch) { throw new Exception\DomainException('Missing route matches; unsure how to retrieve action'); } $action = $routeMatch->getParam('action', 'not-found'); $method = static::getMethodFromAction($action); if (!method_exists($this, $method)) { $method = 'notFoundAction'; } $actionResponse = $this->$method(); $e->setResult($actionResponse); return $actionResponse; } protected function createHttpNotFoundModel(HttpResponse $response) { $response->setStatusCode(404); return new ViewModel(array( 'content' => 'Page not found', )); } protected function createConsoleNotFoundModel($response) { $viewModel = new ConsoleModel(); $viewModel->setErrorLevel(1); $viewModel->setResult('Page not found'); return $viewModel; } } 
namespace Zend\Filter; interface FilterInterface { public function filter($value); } 
namespace Zend\Filter\Word; use Zend\Stdlib\StringUtils; class CamelCaseToSeparator extends AbstractSeparator { public function filter($value) { if (StringUtils::hasPcreUnicodeSupport()) { $pattern = array('#(?<=(?:\p{Lu}))(\p{Lu}\p{Ll})#', '#(?<=(?:\p{Ll}|\p{Nd}))(\p{Lu})#'); $replacement = array($this->separator . '\1', $this->separator . '\1'); } else { $pattern = array('#(?<=(?:[A-Z]))([A-Z]+)([A-Z][a-z])#', '#(?<=(?:[a-z0-9]))([A-Z])#'); $replacement = array('\1' . $this->separator . '\2', $this->separator . '\1'); } return preg_replace($pattern, $replacement, $value); } } 
namespace Zend\Filter\Word; class CamelCaseToDash extends CamelCaseToSeparator { public function __construct() { parent::__construct('-'); } } 
namespace Zend\Stdlib; use Zend\Stdlib\ErrorHandler; use Zend\Stdlib\StringWrapper\StringWrapperInterface; abstract class StringUtils { protected static $wrapperRegistry = null; protected static $singleByteEncodings = array( 'ASCII', '7BIT', '8BIT', 'ISO-8859-1', 'ISO-8859-2', 'ISO-8859-3', 'ISO-8859-4', 'ISO-8859-5', 'ISO-8859-6', 'ISO-8859-7', 'ISO-8859-8', 'ISO-8859-9', 'ISO-8859-10', 'ISO-8859-11', 'ISO-8859-13', 'ISO-8859-14', 'ISO-8859-15', 'ISO-8859-16', 'CP-1251', 'CP-1252', ); protected static $hasPcreUnicodeSupport = null; public static function getRegisteredWrappers() { if (static::$wrapperRegistry === null) { static::$wrapperRegistry = array(); if (extension_loaded('intl')) { static::$wrapperRegistry[] = 'Zend\Stdlib\StringWrapper\Intl'; } if (extension_loaded('mbstring')) { static::$wrapperRegistry[] = 'Zend\Stdlib\StringWrapper\MbString'; } if (extension_loaded('iconv')) { static::$wrapperRegistry[] = 'Zend\Stdlib\StringWrapper\Iconv'; } static::$wrapperRegistry[] = 'Zend\Stdlib\StringWrapper\Native'; } return static::$wrapperRegistry; } public static function registerWrapper($wrapper) { $wrapper = (string) $wrapper; if (!in_array($wrapper, static::$wrapperRegistry, true)) { static::$wrapperRegistry[] = $wrapper; } } public static function unregisterWrapper($wrapper) { $index = array_search((string) $wrapper, static::$wrapperRegistry, true); if ($index !== false) { unset(static::$wrapperRegistry[$index]); } } public static function resetRegisteredWrappers() { static::$wrapperRegistry = null; } public static function getWrapper($encoding = 'UTF-8', $convertEncoding = null) { foreach (static::getRegisteredWrappers() as $wrapperClass) { if ($wrapperClass::isSupported($encoding, $convertEncoding)) { $wrapper = new $wrapperClass($encoding, $convertEncoding); $wrapper->setEncoding($encoding, $convertEncoding); return $wrapper; } } throw new Exception\RuntimeException( 'No wrapper found supporting "' . $encoding . '"' . (($convertEncoding !== null) ? ' and "' . $convertEncoding . '"' : '') ); } public static function getSingleByteEncodings() { return static::$singleByteEncodings; } public static function isSingleByteEncoding($encoding) { return in_array(strtoupper($encoding), static::$singleByteEncodings); } public static function isValidUtf8($str) { return is_string($str) && ($str === '' || preg_match('/^./su', $str) == 1); } public static function hasPcreUnicodeSupport() { if (static::$hasPcreUnicodeSupport === null) { ErrorHandler::start(); static::$hasPcreUnicodeSupport = defined('PREG_BAD_UTF8_OFFSET_ERROR') && preg_match('/\pL/u', 'a') == 1; ErrorHandler::stop(); } return static::$hasPcreUnicodeSupport; } } 
namespace Zend\I18n\Translator; interface TranslatorAwareInterface { public function setTranslator(Translator $translator = null, $textDomain = null); public function getTranslator(); public function hasTranslator(); public function setTranslatorEnabled($enabled = true); public function isTranslatorEnabled(); public function setTranslatorTextDomain($textDomain = 'default'); public function getTranslatorTextDomain(); } 
namespace Zend\I18n\View\Helper; use Zend\I18n\Translator\Translator; use Zend\I18n\Translator\TranslatorAwareInterface; use Zend\View\Helper\AbstractHelper; abstract class AbstractTranslatorHelper extends AbstractHelper implements TranslatorAwareInterface { protected $translator; protected $translatorTextDomain = 'default'; protected $translatorEnabled = true; public function setTranslator(Translator $translator = null, $textDomain = null) { $this->translator = $translator; if (null !== $textDomain) { $this->setTranslatorTextDomain($textDomain); } return $this; } public function getTranslator() { if (! $this->isTranslatorEnabled()) { return null; } return $this->translator; } public function hasTranslator() { return (bool) $this->getTranslator(); } public function setTranslatorEnabled($enabled = true) { $this->translatorEnabled = (bool) $enabled; return $this; } public function isTranslatorEnabled() { return $this->translatorEnabled; } public function setTranslatorTextDomain($textDomain = 'default') { $this->translatorTextDomain = $textDomain; return $this; } public function getTranslatorTextDomain() { return $this->translatorTextDomain; } } 
namespace Zend\I18n\View\Helper; use Zend\I18n\Exception; class Translate extends AbstractTranslatorHelper { public function __invoke($message, $textDomain = null, $locale = null) { $translator = $this->getTranslator(); if (null === $translator) { throw new Exception\RuntimeException('Translator has not been set'); } if (null === $textDomain) { $textDomain = $this->getTranslatorTextDomain(); } return $translator->translate($message, $textDomain, $locale); } } 
namespace Zend\I18n\Translator; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class TranslatorServiceFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { $config = $serviceLocator->get('Config'); $trConfig = isset($config['translator']) ? $config['translator'] : array(); $translator = Translator::factory($trConfig); return $translator; } } 
namespace Zend\Mvc\Service; use Zend\I18n\Translator\TranslatorServiceFactory as I18nTranslatorServiceFactory; use Zend\Mvc\I18n\Translator; use Zend\ServiceManager\ServiceLocatorInterface; class TranslatorServiceFactory extends I18nTranslatorServiceFactory { public function createService(ServiceLocatorInterface $serviceLocator) { $config = $serviceLocator->get('Config'); $trConfig = isset($config['translator']) ? $config['translator'] : array(); $translator = Translator::factory($trConfig); return $translator; } } 
namespace Zend\Validator\Translator; interface TranslatorInterface { public function translate($message, $textDomain = 'default', $locale = null); } 
namespace Zend\I18n\Translator; use Locale; use Traversable; use Zend\Cache; use Zend\Cache\Storage\StorageInterface as CacheStorage; use Zend\EventManager\EventManager; use Zend\EventManager\EventManagerInterface; use Zend\I18n\Exception; use Zend\I18n\Translator\Loader\FileLoaderInterface; use Zend\I18n\Translator\Loader\RemoteLoaderInterface; use Zend\Stdlib\ArrayUtils; class Translator { const EVENT_MISSING_TRANSLATION = 'missingTranslation'; const EVENT_NO_MESSAGES_LOADED = 'noMessagesLoaded'; protected $messages = array(); protected $files = array(); protected $patterns = array(); protected $remote = array(); protected $locale; protected $fallbackLocale; protected $cache; protected $pluginManager; protected $events; protected $eventsEnabled = false; public static function factory($options) { if ($options instanceof Traversable) { $options = ArrayUtils::iteratorToArray($options); } elseif (!is_array($options)) { throw new Exception\InvalidArgumentException(sprintf( '%s expects an array or Traversable object; received "%s"', __METHOD__, (is_object($options) ? get_class($options) : gettype($options)) )); } $translator = new static(); if (isset($options['locale'])) { $locales = (array) $options['locale']; $translator->setLocale(array_shift($locales)); if (count($locales) > 0) { $translator->setFallbackLocale(array_shift($locales)); } } if (isset($options['translation_file_patterns'])) { if (!is_array($options['translation_file_patterns'])) { throw new Exception\InvalidArgumentException( '"translation_file_patterns" should be an array' ); } $requiredKeys = array('type', 'base_dir', 'pattern'); foreach ($options['translation_file_patterns'] as $pattern) { foreach ($requiredKeys as $key) { if (!isset($pattern[$key])) { throw new Exception\InvalidArgumentException( "'{$key}' is missing for translation pattern options" ); } } $translator->addTranslationFilePattern( $pattern['type'], $pattern['base_dir'], $pattern['pattern'], isset($pattern['text_domain']) ? $pattern['text_domain'] : 'default' ); } } if (isset($options['translation_files'])) { if (!is_array($options['translation_files'])) { throw new Exception\InvalidArgumentException( '"translation_files" should be an array' ); } $requiredKeys = array('type', 'filename'); foreach ($options['translation_files'] as $file) { foreach ($requiredKeys as $key) { if (!isset($file[$key])) { throw new Exception\InvalidArgumentException( "'{$key}' is missing for translation file options" ); } } $translator->addTranslationFile( $file['type'], $file['filename'], isset($file['text_domain']) ? $file['text_domain'] : 'default', isset($file['locale']) ? $file['locale'] : null ); } } if (isset($options['remote_translation'])) { if (!is_array($options['remote_translation'])) { throw new Exception\InvalidArgumentException( '"remote_translation" should be an array' ); } $requiredKeys = array('type'); foreach ($options['remote_translation'] as $remote) { foreach ($requiredKeys as $key) { if (!isset($remote[$key])) { throw new Exception\InvalidArgumentException( "'{$key}' is missing for remote translation options" ); } } $translator->addRemoteTranslations( $remote['type'], isset($remote['text_domain']) ? $remote['text_domain'] : 'default' ); } } if (isset($options['cache'])) { if ($options['cache'] instanceof CacheStorage) { $translator->setCache($options['cache']); } else { $translator->setCache(Cache\StorageFactory::factory($options['cache'])); } } if (isset($options['event_manager_enabled']) && $options['event_manager_enabled']) { $translator->enableEventManager(); } return $translator; } public function setLocale($locale) { $this->locale = $locale; return $this; } public function getLocale() { if ($this->locale === null) { if (!extension_loaded('intl')) { throw new Exception\ExtensionNotLoadedException(sprintf( '%s component requires the intl PHP extension', __NAMESPACE__ )); } $this->locale = Locale::getDefault(); } return $this->locale; } public function setFallbackLocale($locale) { $this->fallbackLocale = $locale; return $this; } public function getFallbackLocale() { return $this->fallbackLocale; } public function setCache(CacheStorage $cache = null) { $this->cache = $cache; return $this; } public function getCache() { return $this->cache; } public function setPluginManager(LoaderPluginManager $pluginManager) { $this->pluginManager = $pluginManager; return $this; } public function getPluginManager() { if (!$this->pluginManager instanceof LoaderPluginManager) { $this->setPluginManager(new LoaderPluginManager()); } return $this->pluginManager; } public function translate($message, $textDomain = 'default', $locale = null) { $locale = ($locale ?: $this->getLocale()); $translation = $this->getTranslatedMessage($message, $locale, $textDomain); if ($translation !== null && $translation !== '') { return $translation; } if (null !== ($fallbackLocale = $this->getFallbackLocale()) && $locale !== $fallbackLocale ) { return $this->translate($message, $textDomain, $fallbackLocale); } return $message; } public function translatePlural( $singular, $plural, $number, $textDomain = 'default', $locale = null ) { $locale = $locale ?: $this->getLocale(); $translation = $this->getTranslatedMessage($singular, $locale, $textDomain); if ($translation === null || $translation === '') { if (null !== ($fallbackLocale = $this->getFallbackLocale()) && $locale !== $fallbackLocale ) { return $this->translatePlural( $singular, $plural, $number, $textDomain, $fallbackLocale ); } return ($number == 1 ? $singular : $plural); } $index = $this->messages[$textDomain][$locale] ->getPluralRule() ->evaluate($number); if (!isset($translation[$index])) { throw new Exception\OutOfBoundsException(sprintf( 'Provided index %d does not exist in plural array', $index )); } return $translation[$index]; } protected function getTranslatedMessage( $message, $locale, $textDomain = 'default' ) { if ($message === '') { return ''; } if (!isset($this->messages[$textDomain][$locale])) { $this->loadMessages($textDomain, $locale); } if (isset($this->messages[$textDomain][$locale][$message])) { return $this->messages[$textDomain][$locale][$message]; } if ($this->isEventManagerEnabled()) { $results = $this->getEventManager()->trigger( self::EVENT_MISSING_TRANSLATION, $this, array( 'message' => $message, 'locale' => $locale, 'text_domain' => $textDomain, ), function ($r) { return is_string($r); } ); $last = $results->last(); if (is_string($last)) { return $last; } } return null; } public function addTranslationFile( $type, $filename, $textDomain = 'default', $locale = null ) { $locale = $locale ?: '*'; if (!isset($this->files[$textDomain])) { $this->files[$textDomain] = array(); } $this->files[$textDomain][$locale][] = array( 'type' => $type, 'filename' => $filename, ); return $this; } public function addTranslationFilePattern( $type, $baseDir, $pattern, $textDomain = 'default' ) { if (!isset($this->patterns[$textDomain])) { $this->patterns[$textDomain] = array(); } $this->patterns[$textDomain][] = array( 'type' => $type, 'baseDir' => rtrim($baseDir, '/'), 'pattern' => $pattern, ); return $this; } public function addRemoteTranslations($type, $textDomain = 'default') { if (!isset($this->remote[$textDomain])) { $this->remote[$textDomain] = array(); } $this->remote[$textDomain][] = $type; return $this; } protected function loadMessages($textDomain, $locale) { if (!isset($this->messages[$textDomain])) { $this->messages[$textDomain] = array(); } if (null !== ($cache = $this->getCache())) { $cacheId = 'Zend_I18n_Translator_Messages_' . md5($textDomain . $locale); if (null !== ($result = $cache->getItem($cacheId))) { $this->messages[$textDomain][$locale] = $result; return; } } $messagesLoaded = false; $messagesLoaded |= $this->loadMessagesFromRemote($textDomain, $locale); $messagesLoaded |= $this->loadMessagesFromPatterns($textDomain, $locale); $messagesLoaded |= $this->loadMessagesFromFiles($textDomain, $locale); if (!$messagesLoaded) { $discoveredTextDomain = null; if ($this->isEventManagerEnabled()) { $results = $this->getEventManager()->trigger( self::EVENT_NO_MESSAGES_LOADED, $this, array( 'locale' => $locale, 'text_domain' => $textDomain, ), function ($r) { return ($r instanceof TextDomain); } ); $last = $results->last(); if ($last instanceof TextDomain) { $discoveredTextDomain = $last; } } $this->messages[$textDomain][$locale] = $discoveredTextDomain; $messagesLoaded = true; } if ($messagesLoaded && $cache !== null) { $cache->setItem($cacheId, $this->messages[$textDomain][$locale]); } } protected function loadMessagesFromRemote($textDomain, $locale) { $messagesLoaded = false; if (isset($this->remote[$textDomain])) { foreach ($this->remote[$textDomain] as $loaderType) { $loader = $this->getPluginManager()->get($loaderType); if (!$loader instanceof RemoteLoaderInterface) { throw new Exception\RuntimeException('Specified loader is not a remote loader'); } if (isset($this->messages[$textDomain][$locale])) { $this->messages[$textDomain][$locale]->merge($loader->load($locale, $textDomain)); } else { $this->messages[$textDomain][$locale] = $loader->load($locale, $textDomain); } $messagesLoaded = true; } } return $messagesLoaded; } protected function loadMessagesFromPatterns($textDomain, $locale) { $messagesLoaded = false; if (isset($this->patterns[$textDomain])) { foreach ($this->patterns[$textDomain] as $pattern) { $filename = $pattern['baseDir'] . '/' . sprintf($pattern['pattern'], $locale); if (is_file($filename)) { $loader = $this->getPluginManager()->get($pattern['type']); if (!$loader instanceof FileLoaderInterface) { throw new Exception\RuntimeException('Specified loader is not a file loader'); } if (isset($this->messages[$textDomain][$locale])) { $this->messages[$textDomain][$locale]->merge($loader->load($locale, $filename)); } else { $this->messages[$textDomain][$locale] = $loader->load($locale, $filename); } $messagesLoaded = true; } } } return $messagesLoaded; } protected function loadMessagesFromFiles($textDomain, $locale) { $messagesLoaded = false; foreach (array($locale, '*') as $currentLocale) { if (!isset($this->files[$textDomain][$currentLocale])) { continue; } foreach ($this->files[$textDomain][$currentLocale] as $file) { $loader = $this->getPluginManager()->get($file['type']); if (!$loader instanceof FileLoaderInterface) { throw new Exception\RuntimeException('Specified loader is not a file loader'); } if (isset($this->messages[$textDomain][$locale])) { $this->messages[$textDomain][$locale]->merge($loader->load($locale, $file['filename'])); } else { $this->messages[$textDomain][$locale] = $loader->load($locale, $file['filename']); } $messagesLoaded = true; } unset($this->files[$textDomain][$currentLocale]); } return $messagesLoaded; } public function getEventManager() { if (!$this->events instanceof EventManagerInterface) { $this->setEventManager(new EventManager()); } return $this->events; } public function setEventManager(EventManagerInterface $events) { $events->setIdentifiers(array( __CLASS__, get_class($this), 'translator', )); $this->events = $events; return $this; } public function isEventManagerEnabled() { return $this->eventsEnabled; } public function enableEventManager() { $this->eventsEnabled = true; return $this; } public function disableEventManager() { $this->eventsEnabled = false; return $this; } } 
namespace Zend\Mvc\I18n; use Zend\I18n\Translator\Translator as I18nTranslator; use Zend\Validator\Translator\TranslatorInterface as ValidatorTranslatorInterface; class Translator extends I18nTranslator implements ValidatorTranslatorInterface { } 
namespace Zend\I18n\Translator; use Zend\I18n\Exception; use Zend\ServiceManager\AbstractPluginManager; class LoaderPluginManager extends AbstractPluginManager { protected $invokableClasses = array( 'gettext' => 'Zend\I18n\Translator\Loader\Gettext', 'ini' => 'Zend\I18n\Translator\Loader\Ini', 'phparray' => 'Zend\I18n\Translator\Loader\PhpArray', ); public function validatePlugin($plugin) { if ($plugin instanceof Loader\FileLoaderInterface || $plugin instanceof Loader\RemoteLoaderInterface) { return; } throw new Exception\RuntimeException(sprintf( 'Plugin of type %s is invalid; must implement %s\Loader\FileLoaderInterface or %s\Loader\RemoteLoaderInterface', (is_object($plugin) ? get_class($plugin) : gettype($plugin)), __NAMESPACE__ )); } } 
namespace Zend\I18n\Translator\Loader; interface FileLoaderInterface { public function load($locale, $filename); } 
namespace Zend\I18n\Translator\Loader; use Zend\I18n\Exception; use Zend\I18n\Translator\Plural\Rule as PluralRule; use Zend\I18n\Translator\TextDomain; use Zend\Stdlib\ErrorHandler; class Gettext implements FileLoaderInterface { protected $file; protected $littleEndian; public function load($locale, $filename) { if (!is_file($filename) || !is_readable($filename)) { throw new Exception\InvalidArgumentException(sprintf( 'Could not open file %s for reading', $filename )); } $textDomain = new TextDomain(); ErrorHandler::start(); $this->file = fopen($filename, 'rb'); $error = ErrorHandler::stop(); if (false === $this->file) { throw new Exception\InvalidArgumentException(sprintf( 'Could not open file %s for reading', $filename ), 0, $error); } $magic = fread($this->file, 4); if ($magic == "\x95\x04\x12\xde") { $this->littleEndian = false; } elseif ($magic == "\xde\x12\x04\x95") { $this->littleEndian = true; } else { fclose($this->file); throw new Exception\InvalidArgumentException(sprintf( '%s is not a valid gettext file', $filename )); } $majorRevision = ($this->readInteger() >> 16); if ($majorRevision !== 0 && $majorRevision !== 1) { fclose($this->file); throw new Exception\InvalidArgumentException(sprintf( '%s has an unknown major revision', $filename )); } $numStrings = $this->readInteger(); $originalStringTableOffset = $this->readInteger(); $translationStringTableOffset = $this->readInteger(); fseek($this->file, $originalStringTableOffset); $originalStringTable = $this->readIntegerList(2 * $numStrings); fseek($this->file, $translationStringTableOffset); $translationStringTable = $this->readIntegerList(2 * $numStrings); for ($current = 0; $current < $numStrings; $current++) { $sizeKey = $current * 2 + 1; $offsetKey = $current * 2 + 2; $originalStringSize = $originalStringTable[$sizeKey]; $originalStringOffset = $originalStringTable[$offsetKey]; $translationStringSize = $translationStringTable[$sizeKey]; $translationStringOffset = $translationStringTable[$offsetKey]; $originalString = array(''); if ($originalStringSize > 0) { fseek($this->file, $originalStringOffset); $originalString = explode("\0", fread($this->file, $originalStringSize)); } if ($translationStringSize > 0) { fseek($this->file, $translationStringOffset); $translationString = explode("\0", fread($this->file, $translationStringSize)); if (count($originalString) > 1 && count($translationString) > 1) { $textDomain[$originalString[0]] = $translationString; array_shift($originalString); foreach ($originalString as $string) { $textDomain[$string] = ''; } } else { $textDomain[$originalString[0]] = $translationString[0]; } } } if (array_key_exists('', $textDomain)) { $rawHeaders = explode("\n", trim($textDomain[''])); foreach ($rawHeaders as $rawHeader) { list($header, $content) = explode(':', $rawHeader, 2); if (trim(strtolower($header)) === 'plural-forms') { $textDomain->setPluralRule(PluralRule::fromString($content)); } } unset($textDomain['']); } fclose($this->file); return $textDomain; } protected function readInteger() { if ($this->littleEndian) { $result = unpack('Vint', fread($this->file, 4)); } else { $result = unpack('Nint', fread($this->file, 4)); } return $result['int']; } protected function readIntegerList($num) { if ($this->littleEndian) { return unpack('V' . $num, fread($this->file, 4 * $num)); } return unpack('N' . $num, fread($this->file, 4 * $num)); } } 
namespace Zend\I18n\Translator; use ArrayObject; use Zend\I18n\Exception; use Zend\I18n\Translator\Plural\Rule as PluralRule; class TextDomain extends ArrayObject { protected $pluralRule; public function setPluralRule(PluralRule $rule) { $this->pluralRule = $rule; return $this; } public function getPluralRule() { if ($this->pluralRule === null) { $this->setPluralRule(PluralRule::fromString('nplurals=2; plural=n != 1;')); } return $this->pluralRule; } public function merge(TextDomain $textDomain) { if ($this->getPluralRule()->getNumPlurals() !== $textDomain->getPluralRule()->getNumPlurals()) { throw new Exception\RuntimeException('Plural rule of merging text domain is not compatible with the current one'); } $this->exchangeArray( array_replace( $this->getArrayCopy(), $textDomain->getArrayCopy() ) ); return $this; } } 
namespace Zend\Version; use Zend\Json\Json; final class Version { const VERSION = '2.2.5'; const VERSION_SERVICE_GITHUB = 'GITHUB'; const VERSION_SERVICE_ZEND = 'ZEND'; protected static $latestVersion; public static function compareVersion($version) { $version = strtolower($version); $version = preg_replace('/(\d)pr(\d?)/', '$1a$2', $version); return version_compare($version, strtolower(self::VERSION)); } public static function getLatest($service = self::VERSION_SERVICE_ZEND) { if (null === static::$latestVersion) { static::$latestVersion = 'not available'; if ($service == self::VERSION_SERVICE_GITHUB) { $url = 'https://api.github.com/repos/zendframework/zf2/git/refs/tags/release-'; $apiResponse = Json::decode(file_get_contents($url), Json::TYPE_ARRAY); $tags = array_map(function ($tag) { return substr($tag['ref'], 18); }, $apiResponse); static::$latestVersion = array_reduce($tags, function ($a, $b) { return version_compare($a, $b, '>') ? $a : $b; }); } elseif ($service == self::VERSION_SERVICE_ZEND) { $handle = fopen('http://framework.zend.com/api/zf-version?v=2', 'r'); if (false !== $handle) { static::$latestVersion = stream_get_contents($handle); fclose($handle); } } } return static::$latestVersion; } public static function isLatest() { return static::compareVersion(static::getLatest()) < 1; } } 
namespace Zend\Filter; use Countable; use Zend\Stdlib\PriorityQueue; class FilterChain extends AbstractFilter implements Countable { const DEFAULT_PRIORITY = 1000; protected $plugins; protected $filters; public function __construct($options = null) { $this->filters = new PriorityQueue(); if (null !== $options) { $this->setOptions($options); } } public function setOptions($options) { if (!is_array($options) && !$options instanceof \Traversable) { throw new Exception\InvalidArgumentException(sprintf( 'Expected array or Traversable; received "%s"', (is_object($options) ? get_class($options) : gettype($options)) )); } foreach ($options as $key => $value) { switch (strtolower($key)) { case 'callbacks': foreach ($value as $spec) { $callback = isset($spec['callback']) ? $spec['callback'] : false; $priority = isset($spec['priority']) ? $spec['priority'] : static::DEFAULT_PRIORITY; if ($callback) { $this->attach($callback, $priority); } } break; case 'filters': foreach ($value as $spec) { $name = isset($spec['name']) ? $spec['name'] : false; $options = isset($spec['options']) ? $spec['options'] : array(); $priority = isset($spec['priority']) ? $spec['priority'] : static::DEFAULT_PRIORITY; if ($name) { $this->attachByName($name, $options, $priority); } } break; default: break; } } return $this; } public function count() { return count($this->filters); } public function getPluginManager() { if (!$this->plugins) { $this->setPluginManager(new FilterPluginManager()); } return $this->plugins; } public function setPluginManager(FilterPluginManager $plugins) { $this->plugins = $plugins; return $this; } public function plugin($name, array $options = array()) { $plugins = $this->getPluginManager(); return $plugins->get($name, $options); } public function attach($callback, $priority = self::DEFAULT_PRIORITY) { if (!is_callable($callback)) { if (!$callback instanceof FilterInterface) { throw new Exception\InvalidArgumentException(sprintf( 'Expected a valid PHP callback; received "%s"', (is_object($callback) ? get_class($callback) : gettype($callback)) )); } $callback = array($callback, 'filter'); } $this->filters->insert($callback, $priority); return $this; } public function attachByName($name, $options = array(), $priority = self::DEFAULT_PRIORITY) { if (!is_array($options)) { $options = (array) $options; } elseif (empty($options)) { $options = null; } $filter = $this->getPluginManager()->get($name, $options); return $this->attach($filter, $priority); } public function merge(FilterChain $filterChain) { foreach ($filterChain->filters->toArray(PriorityQueue::EXTR_BOTH) as $item) { $this->attach($item['data'], $item['priority']); } return $this; } public function getFilters() { return $this->filters; } public function filter($value) { $chain = clone $this->filters; $valueFiltered = $value; foreach ($chain as $filter) { $valueFiltered = call_user_func($filter, $valueFiltered); } return $valueFiltered; } public function __clone() { $this->filters = clone $this->filters; } public function __sleep() { return array('filters'); } } 
namespace Zend\View\Helper; use ArrayObject; use Zend\View\Exception; class Doctype extends AbstractHelper { const XHTML11 = 'XHTML11'; const XHTML1_STRICT = 'XHTML1_STRICT'; const XHTML1_TRANSITIONAL = 'XHTML1_TRANSITIONAL'; const XHTML1_FRAMESET = 'XHTML1_FRAMESET'; const XHTML1_RDFA = 'XHTML1_RDFA'; const XHTML1_RDFA11 = 'XHTML1_RDFA11'; const XHTML_BASIC1 = 'XHTML_BASIC1'; const XHTML5 = 'XHTML5'; const HTML4_STRICT = 'HTML4_STRICT'; const HTML4_LOOSE = 'HTML4_LOOSE'; const HTML4_FRAMESET = 'HTML4_FRAMESET'; const HTML5 = 'HTML5'; const CUSTOM_XHTML = 'CUSTOM_XHTML'; const CUSTOM = 'CUSTOM'; protected $defaultDoctype = self::HTML4_LOOSE; protected $registry; protected static $registeredDoctypes; public function __construct() { if (null === static::$registeredDoctypes) { static::registerDefaultDoctypes(); $this->setDoctype($this->defaultDoctype); } $this->registry = static::$registeredDoctypes; } public function __invoke($doctype = null) { if (null !== $doctype) { switch ($doctype) { case self::XHTML11: case self::XHTML1_STRICT: case self::XHTML1_TRANSITIONAL: case self::XHTML1_FRAMESET: case self::XHTML_BASIC1: case self::XHTML1_RDFA: case self::XHTML1_RDFA11: case self::XHTML5: case self::HTML4_STRICT: case self::HTML4_LOOSE: case self::HTML4_FRAMESET: case self::HTML5: $this->setDoctype($doctype); break; default: if (substr($doctype, 0, 9) != '<!DOCTYPE') { throw new Exception\DomainException('The specified doctype is malformed'); } if (stristr($doctype, 'xhtml')) { $type = self::CUSTOM_XHTML; } else { $type = self::CUSTOM; } $this->setDoctype($type); $this->registry['doctypes'][$type] = $doctype; break; } } return $this; } public function __toString() { $doctypes = $this->getDoctypes(); return $doctypes[$this->getDoctype()]; } protected static function registerDefaultDoctypes() { static::$registeredDoctypes = new ArrayObject(array( 'doctypes' => array( self::XHTML11 => '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">', self::XHTML1_STRICT => '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">', self::XHTML1_TRANSITIONAL => '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">', self::XHTML1_FRAMESET => '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">', self::XHTML1_RDFA => '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML+RDFa 1.0//EN" "http://www.w3.org/MarkUp/DTD/xhtml-rdfa-1.dtd">', self::XHTML1_RDFA11 => '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML+RDFa 1.1//EN" "http://www.w3.org/MarkUp/DTD/xhtml-rdfa-2.dtd">', self::XHTML_BASIC1 => '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.0//EN" "http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd">', self::XHTML5 => '<!DOCTYPE html>', self::HTML4_STRICT => '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">', self::HTML4_LOOSE => '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">', self::HTML4_FRAMESET => '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">', self::HTML5 => '<!DOCTYPE html>', ), )); } public static function unsetDoctypeRegistry() { static::$registeredDoctypes = null; } public function setDoctype($doctype) { $this->registry['doctype'] = $doctype; return $this; } public function getDoctype() { if (!isset($this->registry['doctype'])) { $this->setDoctype($this->defaultDoctype); } return $this->registry['doctype']; } public function getDoctypes() { return $this->registry['doctypes']; } public function isXhtml() { return (stristr($this->getDoctype(), 'xhtml') ? true : false); } public function isHtml5() { return (stristr($this->__invoke(), '<!DOCTYPE html>') ? true : false); } public function isRdfa() { return ($this->isHtml5() || stristr($this->getDoctype(), 'rdfa') ? true : false); } } 
namespace Zend\View\Helper\Placeholder\Container; use ArrayAccess; use Countable; use IteratorAggregate; use Zend\Escaper\Escaper; use Zend\View\Exception; use Zend\View\Helper\AbstractHelper; use Zend\View\Renderer\RendererInterface; abstract class AbstractStandalone extends AbstractHelper implements IteratorAggregate, Countable, ArrayAccess { protected $autoEscape = true; protected $container; protected $containerClass = 'Zend\View\Helper\Placeholder\Container'; protected $escapers = array(); public function __construct() { $this->setContainer($this->getContainer()); } public function __call($method, $args) { $container = $this->getContainer(); if (method_exists($container, $method)) { $return = call_user_func_array(array($container, $method), $args); if ($return === $container) { return $this; } return $return; } throw new Exception\BadMethodCallException('Method "' . $method . '" does not exist'); } public function __set($key, $value) { $container = $this->getContainer(); $container[$key] = $value; } public function __get($key) { $container = $this->getContainer(); if (isset($container[$key])) { return $container[$key]; } return null; } public function __isset($key) { $container = $this->getContainer(); return isset($container[$key]); } public function __unset($key) { $container = $this->getContainer(); if (isset($container[$key])) { unset($container[$key]); } } public function __toString() { return $this->toString(); } public function toString() { return $this->getContainer()->toString(); } protected function escape($string) { if ($this->getView() instanceof RendererInterface && method_exists($this->getView(), 'getEncoding') ) { $enc = $this->getView()->getEncoding(); $escaper = $this->getView()->plugin('escapeHtml'); return $escaper((string) $string); } return $this->getEscaper()->escapeHtml((string) $string); } public function setAutoEscape($autoEscape = true) { $this->autoEscape = ($autoEscape) ? true : false; return $this; } public function getAutoEscape() { return $this->autoEscape; } public function setContainer(AbstractContainer $container) { $this->container = $container; return $this; } public function getContainer() { if (!$this->container instanceof AbstractContainer) { $this->container = new $this->containerClass(); } return $this->container; } public function deleteContainer() { if (null != $this->container) { $this->container = null; return true; } return false; } public function setContainerClass($name) { if (!class_exists($name)) { throw new Exception\DomainException( sprintf('%s expects a valid container class name; received "%s", which did not resolve', __METHOD__, $name )); } if (!in_array('Zend\View\Helper\Placeholder\Container\AbstractContainer', class_parents($name))) { throw new Exception\InvalidArgumentException('Invalid Container class specified'); } $this->containerClass = $name; return $this; } public function getContainerClass() { return $this->containerClass; } public function setEscaper(Escaper $escaper) { $encoding = $escaper->getEncoding(); $this->escapers[$encoding] = $escaper; return $this; } public function getEscaper($enc = 'UTF-8') { $enc = strtolower($enc); if (!isset($this->escapers[$enc])) { $this->setEscaper(new Escaper($enc)); } return $this->escapers[$enc]; } public function count() { $container = $this->getContainer(); return count($container); } public function offsetExists($offset) { return $this->getContainer()->offsetExists($offset); } public function offsetGet($offset) { return $this->getContainer()->offsetGet($offset); } public function offsetSet($offset, $value) { return $this->getContainer()->offsetSet($offset, $value); } public function offsetUnset($offset) { return $this->getContainer()->offsetUnset($offset); } public function getIterator() { return $this->getContainer()->getIterator(); } } 
namespace Zend\View\Helper; use Zend\I18n\Translator\Translator; use Zend\I18n\Translator\TranslatorAwareInterface; use Zend\View\Exception; class HeadTitle extends Placeholder\Container\AbstractStandalone implements TranslatorAwareInterface { protected $regKey = 'Zend_View_Helper_HeadTitle'; protected $defaultAttachOrder = null; protected $translator; protected $translatorTextDomain = 'default'; protected $translatorEnabled = true; public function __invoke($title = null, $setType = null) { if (null === $setType) { $setType = (null === $this->getDefaultAttachOrder()) ? Placeholder\Container\AbstractContainer::APPEND : $this->getDefaultAttachOrder(); } $title = (string) $title; if ($title !== '') { if ($setType == Placeholder\Container\AbstractContainer::SET) { $this->set($title); } elseif ($setType == Placeholder\Container\AbstractContainer::PREPEND) { $this->prepend($title); } else { $this->append($title); } } return $this; } public function toString($indent = null) { $indent = (null !== $indent) ? $this->getWhitespace($indent) : $this->getIndent(); $output = $this->renderTitle(); return $indent . '<title>' . $output . '</title>'; } public function renderTitle() { $items = array(); if (null !== ($translator = $this->getTranslator())) { foreach ($this as $item) { $items[] = $translator->translate( $item, $this->getTranslatorTextDomain() ); } } else { foreach ($this as $item) { $items[] = $item; } } $separator = $this->getSeparator(); $output = ''; $prefix = $this->getPrefix(); if ($prefix) { $output .= $prefix; } $output .= implode($separator, $items); $postfix = $this->getPostfix(); if ($postfix) { $output .= $postfix; } $output = ($this->autoEscape) ? $this->escape($output) : $output; return $output; } public function setDefaultAttachOrder($setType) { if (!in_array($setType, array( Placeholder\Container\AbstractContainer::APPEND, Placeholder\Container\AbstractContainer::SET, Placeholder\Container\AbstractContainer::PREPEND ))) { throw new Exception\DomainException( "You must use a valid attach order: 'PREPEND', 'APPEND' or 'SET'" ); } $this->defaultAttachOrder = $setType; return $this; } public function getDefaultAttachOrder() { return $this->defaultAttachOrder; } public function setTranslator(Translator $translator = null, $textDomain = null) { $this->translator = $translator; if (null !== $textDomain) { $this->setTranslatorTextDomain($textDomain); } return $this; } public function getTranslator() { if (! $this->isTranslatorEnabled()) { return null; } return $this->translator; } public function hasTranslator() { return (bool) $this->getTranslator(); } public function setTranslatorEnabled($enabled = true) { $this->translatorEnabled = (bool) $enabled; return $this; } public function isTranslatorEnabled() { return $this->translatorEnabled; } public function setTranslatorTextDomain($textDomain = 'default') { $this->translatorTextDomain = $textDomain; return $this; } public function getTranslatorTextDomain() { return $this->translatorTextDomain; } } 
namespace Zend\View\Helper\Placeholder\Container; use ArrayObject; use Zend\View\Exception; abstract class AbstractContainer extends ArrayObject { const SET = 'SET'; const APPEND = 'APPEND'; const PREPEND = 'PREPEND'; protected $captureKey; protected $captureLock = false; protected $captureType; protected $indent = ''; protected $postfix = ''; protected $prefix = ''; protected $separator = ''; public function __construct() { parent::__construct(array(), parent::ARRAY_AS_PROPS); } public function __toString() { return $this->toString(); } public function toString($indent = null) { $indent = ($indent !== null) ? $this->getWhitespace($indent) : $this->getIndent(); $items = $this->getArrayCopy(); $return = $indent . $this->getPrefix() . implode($this->getSeparator(), $items) . $this->getPostfix(); $return = preg_replace("/(\r\n?|\n)/", '$1' . $indent, $return); return $return; } public function captureStart($type = AbstractContainer::APPEND, $key = null) { if ($this->captureLock) { throw new Exception\RuntimeException( 'Cannot nest placeholder captures for the same placeholder' ); } $this->captureLock = true; $this->captureType = $type; if ((null !== $key) && is_scalar($key)) { $this->captureKey = (string) $key; } ob_start(); } public function captureEnd() { $data = ob_get_clean(); $key = null; $this->captureLock = false; if (null !== $this->captureKey) { $key = $this->captureKey; } switch ($this->captureType) { case self::SET: if (null !== $key) { $this[$key] = $data; } else { $this->exchangeArray(array($data)); } break; case self::PREPEND: if (null !== $key) { $array = array($key => $data); $values = $this->getArrayCopy(); $final = $array + $values; $this->exchangeArray($final); } else { $this->prepend($data); } break; case self::APPEND: default: if (null !== $key) { if (empty($this[$key])) { $this[$key] = $data; } else { $this[$key] .= $data; } } else { $this[$this->nextIndex()] = $data; } break; } } public function getKeys() { $array = $this->getArrayCopy(); return array_keys($array); } public function getValue() { if (1 == count($this)) { $keys = $this->getKeys(); $key = array_shift($keys); return $this[$key]; } return $this->getArrayCopy(); } public function getWhitespace($indent) { if (is_int($indent)) { $indent = str_repeat(' ', $indent); } return (string) $indent; } public function set($value) { $this->exchangeArray(array($value)); return $this; } public function prepend($value) { $values = $this->getArrayCopy(); array_unshift($values, $value); $this->exchangeArray($values); return $this; } public function append($value) { parent::append($value); return $this; } public function nextIndex() { $keys = $this->getKeys(); if (0 == count($keys)) { return 0; } return $nextIndex = max($keys) + 1; } public function setIndent($indent) { $this->indent = $this->getWhitespace($indent); return $this; } public function getIndent() { return $this->indent; } public function setPostfix($postfix) { $this->postfix = (string) $postfix; return $this; } public function getPostfix() { return $this->postfix; } public function setPrefix($prefix) { $this->prefix = (string) $prefix; return $this; } public function getPrefix() { return $this->prefix; } public function setSeparator($separator) { $this->separator = (string) $separator; return $this; } public function getSeparator() { return $this->separator; } } 
namespace Zend\View\Helper\Placeholder; class Container extends Container\AbstractContainer { } 
namespace Zend\View\Helper; use stdClass; use Zend\View; use Zend\View\Exception; class HeadMeta extends Placeholder\Container\AbstractStandalone { protected $typeKeys = array('name', 'http-equiv', 'charset', 'property', 'itemprop'); protected $requiredKeys = array('content'); protected $modifierKeys = array('lang', 'scheme'); protected $regKey = 'Zend_View_Helper_HeadMeta'; public function __construct() { parent::__construct(); $this->setSeparator(PHP_EOL); } public function __invoke($content = null, $keyValue = null, $keyType = 'name', $modifiers = array(), $placement = Placeholder\Container\AbstractContainer::APPEND) { if ((null !== $content) && (null !== $keyValue)) { $item = $this->createData($keyType, $keyValue, $content, $modifiers); $action = strtolower($placement); switch ($action) { case 'append': case 'prepend': case 'set': $this->$action($item); break; default: $this->append($item); break; } } return $this; } public function __call($method, $args) { if (preg_match( '/^(?P<action>set|(pre|ap)pend|offsetSet)(?P<type>Name|HttpEquiv|Property|Itemprop)$/', $method, $matches) ) { $action = $matches['action']; $type = $this->normalizeType($matches['type']); $argc = count($args); $index = null; if ('offsetSet' == $action) { if (0 < $argc) { $index = array_shift($args); --$argc; } } if (2 > $argc) { throw new Exception\BadMethodCallException( 'Too few arguments provided; requires key value, and content' ); } if (3 > $argc) { $args[] = array(); } $item = $this->createData($type, $args[0], $args[1], $args[2]); if ('offsetSet' == $action) { return $this->offsetSet($index, $item); } $this->$action($item); return $this; } return parent::__call($method, $args); } public function toString($indent = null) { $indent = (null !== $indent) ? $this->getWhitespace($indent) : $this->getIndent(); $items = array(); $this->getContainer()->ksort(); try { foreach ($this as $item) { $items[] = $this->itemToString($item); } } catch (Exception\InvalidArgumentException $e) { trigger_error($e->getMessage(), E_USER_WARNING); return ''; } return $indent . implode($this->escape($this->getSeparator()) . $indent, $items); } public function createData($type, $typeValue, $content, array $modifiers) { $data = new stdClass; $data->type = $type; $data->$type = $typeValue; $data->content = $content; $data->modifiers = $modifiers; return $data; } public function itemToString(stdClass $item) { if (!in_array($item->type, $this->typeKeys)) { throw new Exception\InvalidArgumentException(sprintf( 'Invalid type "%s" provided for meta', $item->type )); } $type = $item->type; $modifiersString = ''; foreach ($item->modifiers as $key => $value) { if ($this->view->plugin('doctype')->isHtml5() && $key == 'scheme' ) { throw new Exception\InvalidArgumentException( 'Invalid modifier "scheme" provided; not supported by HTML5' ); } if (!in_array($key, $this->modifierKeys)) { continue; } $modifiersString .= $key . '="' . $this->escape($value) . '" '; } $modifiersString = rtrim($modifiersString); if ('' != $modifiersString) { $modifiersString = ' ' . $modifiersString; } if (method_exists($this->view, 'plugin')) { if ($this->view->plugin('doctype')->isHtml5() && $type == 'charset' ) { $tpl = ($this->view->plugin('doctype')->isXhtml()) ? '<meta %s="%s"/>' : '<meta %s="%s">'; } elseif ($this->view->plugin('doctype')->isXhtml()) { $tpl = '<meta %s="%s" content="%s"%s />'; } else { $tpl = '<meta %s="%s" content="%s"%s>'; } } else { $tpl = '<meta %s="%s" content="%s"%s />'; } $meta = sprintf( $tpl, $type, $this->escape($item->$type), $this->escape($item->content), $modifiersString ); if (isset($item->modifiers['conditional']) && !empty($item->modifiers['conditional']) && is_string($item->modifiers['conditional'])) { $meta = '<!--[if ' . $this->escape($item->modifiers['conditional']) . ']>' . $meta . '<![endif]-->'; } return $meta; } protected function normalizeType($type) { switch ($type) { case 'Name': return 'name'; case 'HttpEquiv': return 'http-equiv'; case 'Property': return 'property'; case 'Itemprop': return 'itemprop'; default: throw new Exception\DomainException(sprintf( 'Invalid type "%s" passed to normalizeType', $type )); } } protected function isValid($item) { if ((!$item instanceof stdClass) || !isset($item->type) || !isset($item->modifiers) ) { return false; } if (!isset($item->content) && (! $this->view->plugin('doctype')->isHtml5() || (! $this->view->plugin('doctype')->isHtml5() && $item->type !== 'charset')) ) { return false; } if (! $this->view->plugin('doctype')->isHtml5() && $item->type === 'itemprop' ) { return false; } if (!$this->view->plugin('doctype')->isRdfa() && $item->type === 'property' ) { return false; } return true; } public function append($value) { if (!$this->isValid($value)) { throw new Exception\InvalidArgumentException( 'Invalid value passed to append; please use appendMeta()' ); } return $this->getContainer()->append($value); } public function offsetSet($index, $value) { if (!$this->isValid($value)) { throw new Exception\InvalidArgumentException( 'Invalid value passed to offsetSet; please use offsetSetName() or offsetSetHttpEquiv()' ); } return $this->getContainer()->offsetSet($index, $value); } public function offsetUnset($index) { if (!in_array($index, $this->getContainer()->getKeys())) { throw new Exception\InvalidArgumentException('Invalid index passed to offsetUnset()'); } return $this->getContainer()->offsetUnset($index); } public function prepend($value) { if (!$this->isValid($value)) { throw new Exception\InvalidArgumentException( 'Invalid value passed to prepend; please use prependMeta()' ); } return $this->getContainer()->prepend($value); } public function set($value) { if (!$this->isValid($value)) { throw new Exception\InvalidArgumentException('Invalid value passed to set; please use setMeta()'); } $container = $this->getContainer(); foreach ($container->getArrayCopy() as $index => $item) { if ($item->type == $value->type && $item->{$item->type} == $value->{$value->type}) { $this->offsetUnset($index); } } return $this->append($value); } public function setCharset($charset) { $item = new stdClass; $item->type = 'charset'; $item->charset = $charset; $item->content = null; $item->modifiers = array(); $this->set($item); return $this; } } 
namespace Zend\Escaper; use Zend\Escaper\Exception; class Escaper { protected static $htmlNamedEntityMap = array( 34 => 'quot', 38 => 'amp', 60 => 'lt', 62 => 'gt', ); protected $encoding = 'utf-8'; protected $htmlSpecialCharsFlags = ENT_QUOTES; protected $htmlAttrMatcher; protected $jsMatcher; protected $cssMatcher; protected $supportedEncodings = array( 'iso-8859-1', 'iso8859-1', 'iso-8859-5', 'iso8859-5', 'iso-8859-15', 'iso8859-15', 'utf-8', 'cp866', 'ibm866', '866', 'cp1251', 'windows-1251', 'win-1251', '1251', 'cp1252', 'windows-1252', '1252', 'koi8-r', 'koi8-ru', 'koi8r', 'big5', '950', 'gb2312', '936', 'big5-hkscs', 'shift_jis', 'sjis', 'sjis-win', 'cp932', '932', 'euc-jp', 'eucjp', 'eucjp-win', 'macroman' ); public function __construct($encoding = null) { if ($encoding !== null) { $encoding = (string) $encoding; if ($encoding === '') { throw new Exception\InvalidArgumentException( get_class($this) . ' constructor parameter does not allow a blank value' ); } $encoding = strtolower($encoding); if (!in_array($encoding, $this->supportedEncodings)) { throw new Exception\InvalidArgumentException( 'Value of \'' . $encoding . '\' passed to ' . get_class($this) . ' constructor parameter is invalid. Provide an encoding supported by htmlspecialchars()' ); } $this->encoding = $encoding; } if (defined('ENT_SUBSTITUTE')) { $this->htmlSpecialCharsFlags|= ENT_SUBSTITUTE; } $this->htmlAttrMatcher = array($this, 'htmlAttrMatcher'); $this->jsMatcher = array($this, 'jsMatcher'); $this->cssMatcher = array($this, 'cssMatcher'); } public function getEncoding() { return $this->encoding; } public function escapeHtml($string) { $result = htmlspecialchars($string, $this->htmlSpecialCharsFlags, $this->encoding); return $result; } public function escapeHtmlAttr($string) { $string = $this->toUtf8($string); if ($string === '' || ctype_digit($string)) { return $string; } $result = preg_replace_callback('/[^a-z0-9,\.\-_]/iSu', $this->htmlAttrMatcher, $string); return $this->fromUtf8($result); } public function escapeJs($string) { $string = $this->toUtf8($string); if ($string === '' || ctype_digit($string)) { return $string; } $result = preg_replace_callback('/[^a-z0-9,\._]/iSu', $this->jsMatcher, $string); return $this->fromUtf8($result); } public function escapeUrl($string) { return rawurlencode($string); } public function escapeCss($string) { $string = $this->toUtf8($string); if ($string === '' || ctype_digit($string)) { return $string; } $result = preg_replace_callback('/[^a-z0-9]/iSu', $this->cssMatcher, $string); return $this->fromUtf8($result); } protected function htmlAttrMatcher($matches) { $chr = $matches[0]; $ord = ord($chr); if (($ord <= 0x1f && $chr != "\t" && $chr != "\n" && $chr != "\r") || ($ord >= 0x7f && $ord <= 0x9f) ) { return '&#xFFFD;'; } if (strlen($chr) > 1) { $chr = $this->convertEncoding($chr, 'UTF-16BE', 'UTF-8'); } $hex = bin2hex($chr); $ord = hexdec($hex); if (isset(static::$htmlNamedEntityMap[$ord])) { return '&' . static::$htmlNamedEntityMap[$ord] . ';'; } if ($ord > 255) { return sprintf('&#x%04X;', $ord); } return sprintf('&#x%02X;', $ord); } protected function jsMatcher($matches) { $chr = $matches[0]; if (strlen($chr) == 1) { return sprintf('\\x%02X', ord($chr)); } $chr = $this->convertEncoding($chr, 'UTF-16BE', 'UTF-8'); return sprintf('\\u%04s', strtoupper(bin2hex($chr))); } protected function cssMatcher($matches) { $chr = $matches[0]; if (strlen($chr) == 1) { $ord = ord($chr); } else { $chr = $this->convertEncoding($chr, 'UTF-16BE', 'UTF-8'); $ord = hexdec(bin2hex($chr)); } return sprintf('\\%X ', $ord); } protected function toUtf8($string) { if ($this->getEncoding() === 'utf-8') { $result = $string; } else { $result = $this->convertEncoding($string, 'UTF-8', $this->getEncoding()); } if (!$this->isUtf8($result)) { throw new Exception\RuntimeException(sprintf( 'String to be escaped was not valid UTF-8 or could not be converted: %s', $result )); } return $result; } protected function fromUtf8($string) { if ($this->getEncoding() === 'utf-8') { return $string; } return $this->convertEncoding($string, $this->getEncoding(), 'UTF-8'); } protected function isUtf8($string) { return ($string === '' || preg_match('/^./su', $string)); } protected function convertEncoding($string, $to, $from) { $result = ''; if (function_exists('iconv')) { $result = iconv($from, $to, $string); } elseif (function_exists('mb_convert_encoding')) { $result = mb_convert_encoding($string, $to, $from); } else { throw new Exception\RuntimeException( get_class($this) . ' requires either the iconv or mbstring extension to be installed' . ' when escaping for non UTF-8 strings.' ); } if ($result === false) { return ''; } return $result; } } 
namespace Zend\View\Helper; use Zend\View\Exception; class BasePath extends AbstractHelper { protected $basePath; public function __invoke($file = null) { if (null === $this->basePath) { throw new Exception\RuntimeException('No base path provided'); } if (null !== $file) { $file = '/' . ltrim($file, '/'); } return $this->basePath . $file; } public function setBasePath($basePath) { $this->basePath = rtrim($basePath, '/'); return $this; } } 
namespace Zend\View\Helper; use stdClass; use Zend\View; use Zend\View\Exception; class HeadLink extends Placeholder\Container\AbstractStandalone { protected $itemKeys = array('charset', 'href', 'hreflang', 'id', 'media', 'rel', 'rev', 'type', 'title', 'extras'); protected $regKey = 'Zend_View_Helper_HeadLink'; public function __construct() { parent::__construct(); $this->setSeparator(PHP_EOL); } public function headLink(array $attributes = null, $placement = Placeholder\Container\AbstractContainer::APPEND) { return call_user_func_array(array($this, '__invoke'), func_get_args()); } public function __invoke(array $attributes = null, $placement = Placeholder\Container\AbstractContainer::APPEND) { if (null !== $attributes) { $item = $this->createData($attributes); switch ($placement) { case Placeholder\Container\AbstractContainer::SET: $this->set($item); break; case Placeholder\Container\AbstractContainer::PREPEND: $this->prepend($item); break; case Placeholder\Container\AbstractContainer::APPEND: default: $this->append($item); break; } } return $this; } public function __call($method, $args) { if (preg_match('/^(?P<action>set|(ap|pre)pend|offsetSet)(?P<type>Stylesheet|Alternate|Prev|Next)$/', $method, $matches)) { $argc = count($args); $action = $matches['action']; $type = $matches['type']; $index = null; if ('offsetSet' == $action) { if (0 < $argc) { $index = array_shift($args); --$argc; } } if (1 > $argc) { throw new Exception\BadMethodCallException(sprintf( '%s requires at least one argument', $method )); } if (is_array($args[0])) { $item = $this->createData($args[0]); } else { $dataMethod = 'createData' . $type; $item = $this->$dataMethod($args); } if ($item) { if ('offsetSet' == $action) { $this->offsetSet($index, $item); } else { $this->$action($item); } } return $this; } return parent::__call($method, $args); } protected function isValid($value) { if (!$value instanceof stdClass) { return false; } $vars = get_object_vars($value); $keys = array_keys($vars); $intersection = array_intersect($this->itemKeys, $keys); if (empty($intersection)) { return false; } return true; } public function append($value) { if (!$this->isValid($value)) { throw new Exception\InvalidArgumentException( 'append() expects a data token; please use one of the custom append*() methods' ); } return $this->getContainer()->append($value); } public function offsetSet($index, $value) { if (!$this->isValid($value)) { throw new Exception\InvalidArgumentException( 'offsetSet() expects a data token; please use one of the custom offsetSet*() methods' ); } return $this->getContainer()->offsetSet($index, $value); } public function prepend($value) { if (!$this->isValid($value)) { throw new Exception\InvalidArgumentException( 'prepend() expects a data token; please use one of the custom prepend*() methods' ); } return $this->getContainer()->prepend($value); } public function set($value) { if (!$this->isValid($value)) { throw new Exception\InvalidArgumentException( 'set() expects a data token; please use one of the custom set*() methods' ); } return $this->getContainer()->set($value); } public function itemToString(stdClass $item) { $attributes = (array) $item; $link = '<link'; foreach ($this->itemKeys as $itemKey) { if (isset($attributes[$itemKey])) { if (is_array($attributes[$itemKey])) { foreach ($attributes[$itemKey] as $key => $value) { $link .= sprintf(' %s="%s"', $key, ($this->autoEscape) ? $this->escape($value) : $value); } } else { $link .= sprintf(' %s="%s"', $itemKey, ($this->autoEscape) ? $this->escape($attributes[$itemKey]) : $attributes[$itemKey]); } } } if (method_exists($this->view, 'plugin')) { $link .= ($this->view->plugin('doctype')->isXhtml()) ? ' />' : '>'; } else { $link .= ' />'; } if (($link == '<link />') || ($link == '<link>')) { return ''; } if (isset($attributes['conditionalStylesheet']) && !empty($attributes['conditionalStylesheet']) && is_string($attributes['conditionalStylesheet'])) { $link = '<!--[if ' . $attributes['conditionalStylesheet'] . ']> ' . $link . '<![endif]-->'; } return $link; } public function toString($indent = null) { $indent = (null !== $indent) ? $this->getWhitespace($indent) : $this->getIndent(); $items = array(); $this->getContainer()->ksort(); foreach ($this as $item) { $items[] = $this->itemToString($item); } return $indent . implode($this->escape($this->getSeparator()) . $indent, $items); } public function createData(array $attributes) { return (object) $attributes; } public function createDataStylesheet(array $args) { $rel = 'stylesheet'; $type = 'text/css'; $media = 'screen'; $conditionalStylesheet = false; $href = array_shift($args); if ($this->isDuplicateStylesheet($href)) { return false; } if (0 < count($args)) { $media = array_shift($args); if (is_array($media)) { $media = implode(',', $media); } else { $media = (string) $media; } } if (0 < count($args)) { $conditionalStylesheet = array_shift($args); if (!empty($conditionalStylesheet) && is_string($conditionalStylesheet)) { $conditionalStylesheet = (string) $conditionalStylesheet; } else { $conditionalStylesheet = null; } } if (0 < count($args) && is_array($args[0])) { $extras = array_shift($args); $extras = (array) $extras; } $attributes = compact('rel', 'type', 'href', 'media', 'conditionalStylesheet', 'extras'); return $this->createData($attributes); } protected function isDuplicateStylesheet($uri) { foreach ($this->getContainer() as $item) { if (($item->rel == 'stylesheet') && ($item->href == $uri)) { return true; } } return false; } public function createDataAlternate(array $args) { if (3 > count($args)) { throw new Exception\InvalidArgumentException(sprintf( 'Alternate tags require 3 arguments; %s provided', count($args) )); } $rel = 'alternate'; $href = array_shift($args); $type = array_shift($args); $title = array_shift($args); if (0 < count($args) && is_array($args[0])) { $extras = array_shift($args); $extras = (array) $extras; if (isset($extras['media']) && is_array($extras['media'])) { $extras['media'] = implode(',', $extras['media']); } } $href = (string) $href; $type = (string) $type; $title = (string) $title; $attributes = compact('rel', 'href', 'type', 'title', 'extras'); return $this->createData($attributes); } public function createDataPrev(array $args) { $rel = 'prev'; $href = (string) array_shift($args); $attributes = compact('rel', 'href'); return $this->createData($attributes); } public function createDataNext(array $args) { $rel = 'next'; $href = (string) array_shift($args); $attributes = compact('rel', 'href'); return $this->createData($attributes); } } 
namespace Zend\View\Helper; use stdClass; use Zend\View; use Zend\View\Exception; class HeadScript extends Placeholder\Container\AbstractStandalone { const FILE = 'FILE'; const SCRIPT = 'SCRIPT'; protected $regKey = 'Zend_View_Helper_HeadScript'; protected $arbitraryAttributes = false; protected $captureLock; protected $captureScriptType; protected $captureScriptAttrs = null; protected $captureType; protected $optionalAttributes = array('charset', 'defer', 'language', 'src'); protected $requiredAttributes = array('type'); public $useCdata = false; public function __construct() { parent::__construct(); $this->setSeparator(PHP_EOL); } public function __invoke($mode = self::FILE, $spec = null, $placement = 'APPEND', array $attrs = array(), $type = 'text/javascript') { if ((null !== $spec) && is_string($spec)) { $action = ucfirst(strtolower($mode)); $placement = strtolower($placement); switch ($placement) { case 'set': case 'prepend': case 'append': $action = $placement . $action; break; default: $action = 'append' . $action; break; } $this->$action($spec, $type, $attrs); } return $this; } public function __call($method, $args) { if (preg_match('/^(?P<action>set|(ap|pre)pend|offsetSet)(?P<mode>File|Script)$/', $method, $matches)) { if (1 > count($args)) { throw new Exception\BadMethodCallException(sprintf( 'Method "%s" requires at least one argument', $method )); } $action = $matches['action']; $mode = strtolower($matches['mode']); $type = 'text/javascript'; $attrs = array(); if ('offsetSet' == $action) { $index = array_shift($args); if (1 > count($args)) { throw new Exception\BadMethodCallException(sprintf( 'Method "%s" requires at least two arguments, an index and source', $method )); } } $content = $args[0]; if (isset($args[1])) { $type = (string) $args[1]; } if (isset($args[2])) { $attrs = (array) $args[2]; } switch ($mode) { case 'script': $item = $this->createData($type, $attrs, $content); if ('offsetSet' == $action) { $this->offsetSet($index, $item); } else { $this->$action($item); } break; case 'file': default: if (!$this->isDuplicate($content)) { $attrs['src'] = $content; $item = $this->createData($type, $attrs); if ('offsetSet' == $action) { $this->offsetSet($index, $item); } else { $this->$action($item); } } break; } return $this; } return parent::__call($method, $args); } public function toString($indent = null) { $indent = (null !== $indent) ? $this->getWhitespace($indent) : $this->getIndent(); if ($this->view) { $useCdata = $this->view->plugin('doctype')->isXhtml() ? true : false; } else { $useCdata = $this->useCdata ? true : false; } $escapeStart = ($useCdata) ? '//<![CDATA[' : '//<!--'; $escapeEnd = ($useCdata) ? '//]]>' : '//-->'; $items = array(); $this->getContainer()->ksort(); foreach ($this as $item) { if (!$this->isValid($item)) { continue; } $items[] = $this->itemToString($item, $indent, $escapeStart, $escapeEnd); } return implode($this->getSeparator(), $items); } public function captureStart($captureType = Placeholder\Container\AbstractContainer::APPEND, $type = 'text/javascript', $attrs = array()) { if ($this->captureLock) { throw new Exception\RuntimeException('Cannot nest headScript captures'); } $this->captureLock = true; $this->captureType = $captureType; $this->captureScriptType = $type; $this->captureScriptAttrs = $attrs; ob_start(); } public function captureEnd() { $content = ob_get_clean(); $type = $this->captureScriptType; $attrs = $this->captureScriptAttrs; $this->captureScriptType = null; $this->captureScriptAttrs = null; $this->captureLock = false; switch ($this->captureType) { case Placeholder\Container\AbstractContainer::SET: case Placeholder\Container\AbstractContainer::PREPEND: case Placeholder\Container\AbstractContainer::APPEND: $action = strtolower($this->captureType) . 'Script'; break; default: $action = 'appendScript'; break; } $this->$action($content, $type, $attrs); } public function createData($type, array $attributes, $content = null) { $data = new stdClass(); $data->type = $type; $data->attributes = $attributes; $data->source = $content; return $data; } protected function isDuplicate($file) { foreach ($this->getContainer() as $item) { if (($item->source === null) && array_key_exists('src', $item->attributes) && ($file == $item->attributes['src'])) { return true; } } return false; } protected function isValid($value) { if ((!$value instanceof stdClass) || !isset($value->type) || (!isset($value->source) && !isset($value->attributes))) { return false; } return true; } public function itemToString($item, $indent, $escapeStart, $escapeEnd) { $attrString = ''; if (!empty($item->attributes)) { foreach ($item->attributes as $key => $value) { if ((!$this->arbitraryAttributesAllowed() && !in_array($key, $this->optionalAttributes)) || in_array($key, array('conditional', 'noescape'))) { continue; } if ('defer' == $key) { $value = 'defer'; } $attrString .= sprintf(' %s="%s"', $key, ($this->autoEscape) ? $this->escape($value) : $value); } } $addScriptEscape = !(isset($item->attributes['noescape']) && filter_var($item->attributes['noescape'], FILTER_VALIDATE_BOOLEAN)); $type = ($this->autoEscape) ? $this->escape($item->type) : $item->type; $html = '<script type="' . $type . '"' . $attrString . '>'; if (!empty($item->source)) { $html .= PHP_EOL; if ($addScriptEscape) { $html .= $indent . '    ' . $escapeStart . PHP_EOL; } $html .= $indent . '    ' . $item->source; if ($addScriptEscape) { $html .= PHP_EOL . $indent . '    ' . $escapeEnd; } $html .= PHP_EOL . $indent; } $html .= '</script>'; if (isset($item->attributes['conditional']) && !empty($item->attributes['conditional']) && is_string($item->attributes['conditional'])) { $html = $indent . '<!--[if ' . $item->attributes['conditional'] . ']>' . $html . '<![endif]-->'; } else { $html = $indent . $html; } return $html; } public function append($value) { if (!$this->isValid($value)) { throw new Exception\InvalidArgumentException( 'Invalid argument passed to append(); please use one of the helper methods, appendScript() or appendFile()' ); } return $this->getContainer()->append($value); } public function prepend($value) { if (!$this->isValid($value)) { throw new Exception\InvalidArgumentException( 'Invalid argument passed to prepend(); please use one of the helper methods, prependScript() or prependFile()' ); } return $this->getContainer()->prepend($value); } public function set($value) { if (!$this->isValid($value)) { throw new Exception\InvalidArgumentException( 'Invalid argument passed to set(); please use one of the helper methods, setScript() or setFile()' ); } return $this->getContainer()->set($value); } public function offsetSet($index, $value) { if (!$this->isValid($value)) { throw new Exception\InvalidArgumentException( 'Invalid argument passed to offsetSet(); please use one of the helper methods, offsetSetScript() or offsetSetFile()' ); } return $this->getContainer()->offsetSet($index, $value); } public function setAllowArbitraryAttributes($flag) { $this->arbitraryAttributes = (bool) $flag; return $this; } public function arbitraryAttributesAllowed() { return $this->arbitraryAttributes; } } 
namespace Zend\View\Helper; use Traversable; use Zend\Mvc\ModuleRouteListener; use Zend\Mvc\Router\RouteMatch; use Zend\Mvc\Router\RouteStackInterface; use Zend\Stdlib\ArrayUtils; use Zend\View\Exception; use Zend\Stdlib\Exception as StdlibException; class Url extends AbstractHelper { protected $router; protected $routeMatch; public function __invoke($name = null, $params = array(), $options = array(), $reuseMatchedParams = false) { if (null === $this->router) { throw new Exception\RuntimeException('No RouteStackInterface instance provided'); } if (3 == func_num_args() && is_bool($options)) { $reuseMatchedParams = $options; $options = array(); } if ($name === null) { if ($this->routeMatch === null) { throw new Exception\RuntimeException('No RouteMatch instance provided'); } $name = $this->routeMatch->getMatchedRouteName(); if ($name === null) { throw new Exception\RuntimeException('RouteMatch does not contain a matched route name'); } } if (!is_array($params)) { if (!$params instanceof Traversable) { throw new Exception\InvalidArgumentException( 'Params is expected to be an array or a Traversable object' ); } $params = iterator_to_array($params); } if ($reuseMatchedParams && $this->routeMatch !== null) { $routeMatchParams = $this->routeMatch->getParams(); if (isset($routeMatchParams[ModuleRouteListener::ORIGINAL_CONTROLLER])) { $routeMatchParams['controller'] = $routeMatchParams[ModuleRouteListener::ORIGINAL_CONTROLLER]; unset($routeMatchParams[ModuleRouteListener::ORIGINAL_CONTROLLER]); } if (isset($routeMatchParams[ModuleRouteListener::MODULE_NAMESPACE])) { unset($routeMatchParams[ModuleRouteListener::MODULE_NAMESPACE]); } $params = array_merge($routeMatchParams, $params); } $options['name'] = $name; return $this->router->assemble($params, $options); } public function setRouter(RouteStackInterface $router) { $this->router = $router; return $this; } public function setRouteMatch(RouteMatch $routeMatch) { $this->routeMatch = $routeMatch; return $this; } } 
namespace Zend\View\Helper; class InlineScript extends HeadScript { protected $regKey = 'Zend_View_Helper_InlineScript'; public function __invoke($mode = self::FILE, $spec = null, $placement = 'APPEND', array $attrs = array(), $type = 'text/javascript') { return parent::__invoke($mode, $spec, $placement, $attrs, $type); } } 
?>